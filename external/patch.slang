diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./external/xxhash/xxhash.c ./external/xxhash/xxhash.c
--- ./external/xxhash/xxhash.c	2019-10-15 18:26:53.568949244 -0700
+++ ./external/xxhash/xxhash.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1029 +0,0 @@
-/*
-*  xxHash - Fast Hash algorithm
-*  Copyright (C) 2012-2016, Yann Collet
-*
-*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions are
-*  met:
-*
-*  * Redistributions of source code must retain the above copyright
-*  notice, this list of conditions and the following disclaimer.
-*  * Redistributions in binary form must reproduce the above
-*  copyright notice, this list of conditions and the following disclaimer
-*  in the documentation and/or other materials provided with the
-*  distribution.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*  You can contact the author at :
-*  - xxHash homepage: http://www.xxhash.com
-*  - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-
-/* *************************************
-*  Tuning parameters
-***************************************/
-/*!XXH_FORCE_MEMORY_ACCESS :
- * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
- * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
- * The below switch allow to select different access method for improved performance.
- * Method 0 (default) : use `memcpy()`. Safe and portable.
- * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
- *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
- * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
- *            It can generate buggy code on targets which do not support unaligned memory accesses.
- *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
- * See http://stackoverflow.com/a/32095106/646947 for details.
- * Prefer these methods in priority order (0 > 1 > 2)
- */
-#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
-#  if defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
-                        || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
-                        || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
-#    define XXH_FORCE_MEMORY_ACCESS 2
-#  elif (defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
-  (defined(__GNUC__) && ( defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
-                    || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
-                    || defined(__ARM_ARCH_7S__) ))
-#    define XXH_FORCE_MEMORY_ACCESS 1
-#  endif
-#endif
-
-/*!XXH_ACCEPT_NULL_INPUT_POINTER :
- * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
- * When this macro is enabled, xxHash actively checks input for null pointer.
- * It it is, result for null input pointers is the same as a null-length input.
- */
-#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
-#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
-#endif
-
-/*!XXH_FORCE_NATIVE_FORMAT :
- * By default, xxHash library provides endian-independent Hash values, based on little-endian convention.
- * Results are therefore identical for little-endian and big-endian CPU.
- * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
- * Should endian-independence be of no importance for your application, you may set the #define below to 1,
- * to improve speed for Big-endian CPU.
- * This option has no impact on Little_Endian CPU.
- */
-#ifndef XXH_FORCE_NATIVE_FORMAT   /* can be defined externally */
-#  define XXH_FORCE_NATIVE_FORMAT 0
-#endif
-
-/*!XXH_FORCE_ALIGN_CHECK :
- * This is a minor performance trick, only useful with lots of very small keys.
- * It means : check for aligned/unaligned input.
- * The check costs one initial branch per hash;
- * set it to 0 when the input is guaranteed to be aligned,
- * or when alignment doesn't matter for performance.
- */
-#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
-#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
-#    define XXH_FORCE_ALIGN_CHECK 0
-#  else
-#    define XXH_FORCE_ALIGN_CHECK 1
-#  endif
-#endif
-
-
-/* *************************************
-*  Includes & Memory related functions
-***************************************/
-/*! Modify the local functions below should you wish to use some other memory routines
-*   for malloc(), free() */
-#include <stdlib.h>
-static void* XXH_malloc(size_t s) { return malloc(s); }
-static void  XXH_free  (void* p)  { free(p); }
-/*! and for memcpy() */
-#include <string.h>
-static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
-
-#include <assert.h>   /* assert */
-
-#define XXH_STATIC_LINKING_ONLY
-#include "xxhash.h"
-
-
-/* *************************************
-*  Compiler Specific Options
-***************************************/
-#ifdef _MSC_VER    /* Visual Studio */
-#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
-#  define FORCE_INLINE static __forceinline
-#else
-#  if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
-#    ifdef __GNUC__
-#      define FORCE_INLINE static inline __attribute__((always_inline))
-#    else
-#      define FORCE_INLINE static inline
-#    endif
-#  else
-#    define FORCE_INLINE static
-#  endif /* __STDC_VERSION__ */
-#endif
-
-
-/* *************************************
-*  Basic Types
-***************************************/
-#ifndef MEM_MODULE
-# if !defined (__VMS) \
-  && (defined (__cplusplus) \
-  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-#   include <stdint.h>
-    typedef uint8_t  BYTE;
-    typedef uint16_t U16;
-    typedef uint32_t U32;
-# else
-    typedef unsigned char      BYTE;
-    typedef unsigned short     U16;
-    typedef unsigned int       U32;
-# endif
-#endif
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { U32 u32; } __attribute__((packed)) unalign;
-static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-static U32 XXH_read32(const void* memPtr)
-{
-    U32 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-
-/* ****************************************
-*  Compiler-specific Functions and Macros
-******************************************/
-#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-
-/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
-#if defined(_MSC_VER)
-#  define XXH_rotl32(x,r) _rotl(x,r)
-#  define XXH_rotl64(x,r) _rotl64(x,r)
-#else
-#  define XXH_rotl32(x,r) ((x << r) | (x >> (32 - r)))
-#  define XXH_rotl64(x,r) ((x << r) | (x >> (64 - r)))
-#endif
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap32 _byteswap_ulong
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap32 __builtin_bswap32
-#else
-static U32 XXH_swap32 (U32 x)
-{
-    return  ((x << 24) & 0xff000000 ) |
-            ((x <<  8) & 0x00ff0000 ) |
-            ((x >>  8) & 0x0000ff00 ) |
-            ((x >> 24) & 0x000000ff );
-}
-#endif
-
-
-/* *************************************
-*  Architecture Macros
-***************************************/
-typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
-
-/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
-#ifndef XXH_CPU_LITTLE_ENDIAN
-static int XXH_isLittleEndian(void)
-{
-    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
-    return one.c[0];
-}
-#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
-#endif
-
-
-/* ***************************
-*  Memory reads
-*****************************/
-typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
-
-FORCE_INLINE U32 XXH_readLE32_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
-    else
-        return endian==XXH_littleEndian ? *(const U32*)ptr : XXH_swap32(*(const U32*)ptr);
-}
-
-FORCE_INLINE U32 XXH_readLE32(const void* ptr, XXH_endianess endian)
-{
-    return XXH_readLE32_align(ptr, endian, XXH_unaligned);
-}
-
-static U32 XXH_readBE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
-}
-
-
-/* *************************************
-*  Macros
-***************************************/
-#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }  /* use after variable declarations */
-XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
-
-
-/* *******************************************************************
-*  32-bit hash functions
-*********************************************************************/
-static const U32 PRIME32_1 = 2654435761U;
-static const U32 PRIME32_2 = 2246822519U;
-static const U32 PRIME32_3 = 3266489917U;
-static const U32 PRIME32_4 =  668265263U;
-static const U32 PRIME32_5 =  374761393U;
-
-static U32 XXH32_round(U32 seed, U32 input)
-{
-    seed += input * PRIME32_2;
-    seed  = XXH_rotl32(seed, 13);
-    seed *= PRIME32_1;
-    return seed;
-}
-
-/* mix all bits */
-static U32 XXH32_avalanche(U32 h32)
-{
-    h32 ^= h32 >> 15;
-    h32 *= PRIME32_2;
-    h32 ^= h32 >> 13;
-    h32 *= PRIME32_3;
-    h32 ^= h32 >> 16;
-    return(h32);
-}
-
-#define XXH_get32bits(p) XXH_readLE32_align(p, endian, align)
-
-static U32
-XXH32_finalize(U32 h32, const void* ptr, size_t len,
-                XXH_endianess endian, XXH_alignment align)
-
-{
-    const BYTE* p = (const BYTE*)ptr;
-#define PROCESS1             \
-    h32 += (*p) * PRIME32_5; \
-    p++;                     \
-    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
-
-#define PROCESS4                         \
-    h32 += XXH_get32bits(p) * PRIME32_3; \
-    p+=4;                                \
-    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
-
-    switch(len&15)  /* or switch(bEnd - p) */
-    {
-      case 12:      PROCESS4;
-                    [[fallthrough]];
-      case 8:       PROCESS4;
-                    [[fallthrough]];
-      case 4:       PROCESS4;
-                    return XXH32_avalanche(h32);
-
-      case 13:      PROCESS4;
-                    [[fallthrough]];
-      case 9:       PROCESS4;
-                    [[fallthrough]];
-      case 5:       PROCESS4;
-                    PROCESS1;
-                    return XXH32_avalanche(h32);
-
-      case 14:      PROCESS4;
-                    [[fallthrough]];
-      case 10:      PROCESS4;
-                    [[fallthrough]];
-      case 6:       PROCESS4;
-                    PROCESS1;
-                    PROCESS1;
-                    return XXH32_avalanche(h32);
-
-      case 15:      PROCESS4;
-                    [[fallthrough]];
-      case 11:      PROCESS4;
-                    [[fallthrough]];
-      case 7:       PROCESS4;
-                    [[fallthrough]];
-      case 3:       PROCESS1;
-                    [[fallthrough]];
-      case 2:       PROCESS1;
-                    [[fallthrough]];
-      case 1:       PROCESS1;
-                    [[fallthrough]];
-      case 0:       return XXH32_avalanche(h32);
-    }
-    assert(0);
-    return h32;   /* reaching this point is deemed impossible */
-}
-
-
-FORCE_INLINE U32
-XXH32_endian_align(const void* input, size_t len, U32 seed,
-                    XXH_endianess endian, XXH_alignment align)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* bEnd = p + len;
-    U32 h32;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (p==NULL) {
-        len=0;
-        bEnd=p=(const BYTE*)(size_t)16;
-    }
-#endif
-
-    if (len>=16) {
-        const BYTE* const limit = bEnd - 15;
-        U32 v1 = seed + PRIME32_1 + PRIME32_2;
-        U32 v2 = seed + PRIME32_2;
-        U32 v3 = seed + 0;
-        U32 v4 = seed - PRIME32_1;
-
-        do {
-            v1 = XXH32_round(v1, XXH_get32bits(p)); p+=4;
-            v2 = XXH32_round(v2, XXH_get32bits(p)); p+=4;
-            v3 = XXH32_round(v3, XXH_get32bits(p)); p+=4;
-            v4 = XXH32_round(v4, XXH_get32bits(p)); p+=4;
-        } while (p < limit);
-
-        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
-            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
-    } else {
-        h32  = seed + PRIME32_5;
-    }
-
-    h32 += (U32)len;
-
-    return XXH32_finalize(h32, p, len&15, endian, align);
-}
-
-
-XXH_PUBLIC_API unsigned int XXH32 (const void* input, size_t len, unsigned int seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH32_state_t state;
-    XXH32_reset(&state, seed);
-    XXH32_update(&state, input, len);
-    return XXH32_digest(&state);
-#else
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
-            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-                return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
-            else
-                return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
-    }   }
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
-    else
-        return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
-#endif
-}
-
-
-
-/*======   Hash streaming   ======*/
-
-XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
-{
-    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, unsigned int seed)
-{
-    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME32_1 + PRIME32_2;
-    state.v2 = seed + PRIME32_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME32_1;
-    /* do not write into reserved, planned to be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
-    return XXH_OK;
-}
-
-
-FORCE_INLINE
-XXH_errorcode XXH32_update_endian (XXH32_state_t* state, const void* input, size_t len, XXH_endianess endian)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* const bEnd = p + len;
-
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    state->total_len_32 += (unsigned)len;
-    state->large_len |= (len>=16) | (state->total_len_32>=16);
-
-    if (state->memsize + len < 16)  {   /* fill in tmp buffer */
-        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, len);
-        state->memsize += (unsigned)len;
-        return XXH_OK;
-    }
-
-    if (state->memsize) {   /* some data left from previous update */
-        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, 16-state->memsize);
-        {   const U32* p32 = state->mem32;
-            state->v1 = XXH32_round(state->v1, XXH_readLE32(p32, endian)); p32++;
-            state->v2 = XXH32_round(state->v2, XXH_readLE32(p32, endian)); p32++;
-            state->v3 = XXH32_round(state->v3, XXH_readLE32(p32, endian)); p32++;
-            state->v4 = XXH32_round(state->v4, XXH_readLE32(p32, endian));
-        }
-        p += 16-state->memsize;
-        state->memsize = 0;
-    }
-
-    if (p <= bEnd-16) {
-        const BYTE* const limit = bEnd - 16;
-        U32 v1 = state->v1;
-        U32 v2 = state->v2;
-        U32 v3 = state->v3;
-        U32 v4 = state->v4;
-
-        do {
-            v1 = XXH32_round(v1, XXH_readLE32(p, endian)); p+=4;
-            v2 = XXH32_round(v2, XXH_readLE32(p, endian)); p+=4;
-            v3 = XXH32_round(v3, XXH_readLE32(p, endian)); p+=4;
-            v4 = XXH32_round(v4, XXH_readLE32(p, endian)); p+=4;
-        } while (p<=limit);
-
-        state->v1 = v1;
-        state->v2 = v2;
-        state->v3 = v3;
-        state->v4 = v4;
-    }
-
-    if (p < bEnd) {
-        XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
-        state->memsize = (unsigned)(bEnd-p);
-    }
-
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* state_in, const void* input, size_t len)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_update_endian(state_in, input, len, XXH_littleEndian);
-    else
-        return XXH32_update_endian(state_in, input, len, XXH_bigEndian);
-}
-
-
-FORCE_INLINE U32
-XXH32_digest_endian (const XXH32_state_t* state, XXH_endianess endian)
-{
-    U32 h32;
-
-    if (state->large_len) {
-        h32 = XXH_rotl32(state->v1, 1)
-            + XXH_rotl32(state->v2, 7)
-            + XXH_rotl32(state->v3, 12)
-            + XXH_rotl32(state->v4, 18);
-    } else {
-        h32 = state->v3 /* == seed */ + PRIME32_5;
-    }
-
-    h32 += state->total_len_32;
-
-    return XXH32_finalize(h32, state->mem32, state->memsize, endian, XXH_aligned);
-}
-
-
-XXH_PUBLIC_API unsigned int XXH32_digest (const XXH32_state_t* state_in)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_digest_endian(state_in, XXH_littleEndian);
-    else
-        return XXH32_digest_endian(state_in, XXH_bigEndian);
-}
-
-
-/*======   Canonical representation   ======*/
-
-/*! Default XXH result types are basic unsigned 32 and 64 bits.
-*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
-*   These functions allow transformation of hash result into and from its canonical format.
-*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
-*/
-
-XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
-{
-    return XXH_readBE32(src);
-}
-
-
-#ifndef XXH_NO_LONG_LONG
-
-/* *******************************************************************
-*  64-bit hash functions
-*********************************************************************/
-
-/*======   Memory access   ======*/
-
-#ifndef MEM_MODULE
-# define MEM_MODULE
-# if !defined (__VMS) \
-  && (defined (__cplusplus) \
-  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-#   include <stdint.h>
-    typedef uint64_t U64;
-# else
-    /* if compiler doesn't support unsigned long long, replace by another 64-bit type */
-    typedef unsigned long long U64;
-# endif
-#endif
-
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign64;
-static U64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-
-static U64 XXH_read64(const void* memPtr)
-{
-    U64 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap64 _byteswap_uint64
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap64 __builtin_bswap64
-#else
-static U64 XXH_swap64 (U64 x)
-{
-    return  ((x << 56) & 0xff00000000000000ULL) |
-            ((x << 40) & 0x00ff000000000000ULL) |
-            ((x << 24) & 0x0000ff0000000000ULL) |
-            ((x << 8)  & 0x000000ff00000000ULL) |
-            ((x >> 8)  & 0x00000000ff000000ULL) |
-            ((x >> 24) & 0x0000000000ff0000ULL) |
-            ((x >> 40) & 0x000000000000ff00ULL) |
-            ((x >> 56) & 0x00000000000000ffULL);
-}
-#endif
-
-FORCE_INLINE U64 XXH_readLE64_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
-    else
-        return endian==XXH_littleEndian ? *(const U64*)ptr : XXH_swap64(*(const U64*)ptr);
-}
-
-FORCE_INLINE U64 XXH_readLE64(const void* ptr, XXH_endianess endian)
-{
-    return XXH_readLE64_align(ptr, endian, XXH_unaligned);
-}
-
-static U64 XXH_readBE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
-}
-
-
-/*======   xxh64   ======*/
-
-static const U64 PRIME64_1 = 11400714785074694791ULL;
-static const U64 PRIME64_2 = 14029467366897019727ULL;
-static const U64 PRIME64_3 =  1609587929392839161ULL;
-static const U64 PRIME64_4 =  9650029242287828579ULL;
-static const U64 PRIME64_5 =  2870177450012600261ULL;
-
-static U64 XXH64_round(U64 acc, U64 input)
-{
-    acc += input * PRIME64_2;
-    acc  = XXH_rotl64(acc, 31);
-    acc *= PRIME64_1;
-    return acc;
-}
-
-static U64 XXH64_mergeRound(U64 acc, U64 val)
-{
-    val  = XXH64_round(0, val);
-    acc ^= val;
-    acc  = acc * PRIME64_1 + PRIME64_4;
-    return acc;
-}
-
-static U64 XXH64_avalanche(U64 h64)
-{
-    h64 ^= h64 >> 33;
-    h64 *= PRIME64_2;
-    h64 ^= h64 >> 29;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
-    return h64;
-}
-
-
-#define XXH_get64bits(p) XXH_readLE64_align(p, endian, align)
-
-static U64
-XXH64_finalize(U64 h64, const void* ptr, size_t len,
-               XXH_endianess endian, XXH_alignment align)
-{
-    const BYTE* p = (const BYTE*)ptr;
-
-#define PROCESS1_64          \
-    h64 ^= (*p) * PRIME64_5; \
-    p++;                     \
-    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
-
-#define PROCESS4_64          \
-    h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1; \
-    p+=4;                    \
-    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
-
-#define PROCESS8_64 {        \
-    U64 const k1 = XXH64_round(0, XXH_get64bits(p)); \
-    p+=8;                    \
-    h64 ^= k1;               \
-    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
-}
-
-    switch(len&31) {
-      case 24: PROCESS8_64;
-                    [[fallthrough]];
-      case 16: PROCESS8_64;
-                    [[fallthrough]];
-      case  8: PROCESS8_64;
-               return XXH64_avalanche(h64);
-
-      case 28: PROCESS8_64;
-                    [[fallthrough]];
-      case 20: PROCESS8_64;
-                    [[fallthrough]];
-      case 12: PROCESS8_64;
-                    [[fallthrough]];
-      case  4: PROCESS4_64;
-               return XXH64_avalanche(h64);
-
-      case 25: PROCESS8_64;
-                    [[fallthrough]];
-      case 17: PROCESS8_64;
-                    [[fallthrough]];
-      case  9: PROCESS8_64;
-               PROCESS1_64;
-               return XXH64_avalanche(h64);
-
-      case 29: PROCESS8_64;
-                    [[fallthrough]];
-      case 21: PROCESS8_64;
-                    [[fallthrough]];
-      case 13: PROCESS8_64;
-                    [[fallthrough]];
-      case  5: PROCESS4_64;
-               PROCESS1_64;
-               return XXH64_avalanche(h64);
-
-      case 26: PROCESS8_64;
-                    [[fallthrough]];
-      case 18: PROCESS8_64;
-                    [[fallthrough]];
-      case 10: PROCESS8_64;
-               PROCESS1_64;
-               PROCESS1_64;
-               return XXH64_avalanche(h64);
-
-      case 30: PROCESS8_64;
-                    [[fallthrough]];
-      case 22: PROCESS8_64;
-                    [[fallthrough]];
-      case 14: PROCESS8_64;
-                    [[fallthrough]];
-      case  6: PROCESS4_64;
-               PROCESS1_64;
-               PROCESS1_64;
-               return XXH64_avalanche(h64);
-
-      case 27: PROCESS8_64;
-                    [[fallthrough]];
-      case 19: PROCESS8_64;
-                    [[fallthrough]];
-      case 11: PROCESS8_64;
-               PROCESS1_64;
-               PROCESS1_64;
-               PROCESS1_64;
-               return XXH64_avalanche(h64);
-
-      case 31: PROCESS8_64;
-                    [[fallthrough]];
-      case 23: PROCESS8_64;
-                    [[fallthrough]];
-      case 15: PROCESS8_64;
-                    [[fallthrough]];
-      case  7: PROCESS4_64;
-                    [[fallthrough]];
-      case  3: PROCESS1_64;
-                    [[fallthrough]];
-      case  2: PROCESS1_64;
-                    [[fallthrough]];
-      case  1: PROCESS1_64;
-                    [[fallthrough]];
-      case  0: return XXH64_avalanche(h64);
-    }
-
-    /* impossible to reach */
-    assert(0);
-    return 0;  /* unreachable, but some compilers complain without it */
-}
-
-FORCE_INLINE U64
-XXH64_endian_align(const void* input, size_t len, U64 seed,
-                XXH_endianess endian, XXH_alignment align)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* bEnd = p + len;
-    U64 h64;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (p==NULL) {
-        len=0;
-        bEnd=p=(const BYTE*)(size_t)32;
-    }
-#endif
-
-    if (len>=32) {
-        const BYTE* const limit = bEnd - 32;
-        U64 v1 = seed + PRIME64_1 + PRIME64_2;
-        U64 v2 = seed + PRIME64_2;
-        U64 v3 = seed + 0;
-        U64 v4 = seed - PRIME64_1;
-
-        do {
-            v1 = XXH64_round(v1, XXH_get64bits(p)); p+=8;
-            v2 = XXH64_round(v2, XXH_get64bits(p)); p+=8;
-            v3 = XXH64_round(v3, XXH_get64bits(p)); p+=8;
-            v4 = XXH64_round(v4, XXH_get64bits(p)); p+=8;
-        } while (p<=limit);
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-
-    } else {
-        h64  = seed + PRIME64_5;
-    }
-
-    h64 += (U64) len;
-
-    return XXH64_finalize(h64, p, len, endian, align);
-}
-
-
-XXH_PUBLIC_API unsigned long long XXH64 (const void* input, size_t len, unsigned long long seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH64_state_t state;
-    XXH64_reset(&state, seed);
-    XXH64_update(&state, input, len);
-    return XXH64_digest(&state);
-#else
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
-            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-                return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
-            else
-                return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
-    }   }
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
-    else
-        return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
-#endif
-}
-
-/*======   Hash Streaming   ======*/
-
-XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
-{
-    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, unsigned long long seed)
-{
-    XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME64_1 + PRIME64_2;
-    state.v2 = seed + PRIME64_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME64_1;
-     /* do not write into reserved, planned to be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
-    return XXH_OK;
-}
-
-FORCE_INLINE
-XXH_errorcode XXH64_update_endian (XXH64_state_t* state, const void* input, size_t len, XXH_endianess endian)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* const bEnd = p + len;
-
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    state->total_len += len;
-
-    if (state->memsize + len < 32) {  /* fill in tmp buffer */
-        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, len);
-        state->memsize += (U32)len;
-        return XXH_OK;
-    }
-
-    if (state->memsize) {   /* tmp buffer is full */
-        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, 32-state->memsize);
-        state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));
-        state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));
-        state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));
-        state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));
-        p += 32-state->memsize;
-        state->memsize = 0;
-    }
-
-    if (p+32 <= bEnd) {
-        const BYTE* const limit = bEnd - 32;
-        U64 v1 = state->v1;
-        U64 v2 = state->v2;
-        U64 v3 = state->v3;
-        U64 v4 = state->v4;
-
-        do {
-            v1 = XXH64_round(v1, XXH_readLE64(p, endian)); p+=8;
-            v2 = XXH64_round(v2, XXH_readLE64(p, endian)); p+=8;
-            v3 = XXH64_round(v3, XXH_readLE64(p, endian)); p+=8;
-            v4 = XXH64_round(v4, XXH_readLE64(p, endian)); p+=8;
-        } while (p<=limit);
-
-        state->v1 = v1;
-        state->v2 = v2;
-        state->v3 = v3;
-        state->v4 = v4;
-    }
-
-    if (p < bEnd) {
-        XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
-        state->memsize = (unsigned)(bEnd-p);
-    }
-
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* state_in, const void* input, size_t len)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
-    else
-        return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
-}
-
-FORCE_INLINE U64 XXH64_digest_endian (const XXH64_state_t* state, XXH_endianess endian)
-{
-    U64 h64;
-
-    if (state->total_len >= 32) {
-        U64 const v1 = state->v1;
-        U64 const v2 = state->v2;
-        U64 const v3 = state->v3;
-        U64 const v4 = state->v4;
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-    } else {
-        h64  = state->v3 /*seed*/ + PRIME64_5;
-    }
-
-    h64 += (U64) state->total_len;
-
-    return XXH64_finalize(h64, state->mem64, (size_t)state->total_len, endian, XXH_aligned);
-}
-
-XXH_PUBLIC_API unsigned long long XXH64_digest (const XXH64_state_t* state_in)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_digest_endian(state_in, XXH_littleEndian);
-    else
-        return XXH64_digest_endian(state_in, XXH_bigEndian);
-}
-
-
-/*====== Canonical representation   ======*/
-
-XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
-{
-    return XXH_readBE64(src);
-}
-
-#endif  /* XXH_NO_LONG_LONG */
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./external/xxhash/xxhash.cpp ./external/xxhash/xxhash.cpp
--- ./external/xxhash/xxhash.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./external/xxhash/xxhash.cpp	2020-04-12 19:57:39.337095835 -0700
@@ -0,0 +1,1029 @@
+/*
+*  xxHash - Fast Hash algorithm
+*  Copyright (C) 2012-2016, Yann Collet
+*
+*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions are
+*  met:
+*
+*  * Redistributions of source code must retain the above copyright
+*  notice, this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above
+*  copyright notice, this list of conditions and the following disclaimer
+*  in the documentation and/or other materials provided with the
+*  distribution.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*  You can contact the author at :
+*  - xxHash homepage: http://www.xxhash.com
+*  - xxHash source repository : https://github.com/Cyan4973/xxHash
+*/
+
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+/*!XXH_FORCE_MEMORY_ACCESS :
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
+ * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
+ * The below switch allow to select different access method for improved performance.
+ * Method 0 (default) : use `memcpy()`. Safe and portable.
+ * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
+ *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
+ * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
+ *            It can generate buggy code on targets which do not support unaligned memory accesses.
+ *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
+ * See http://stackoverflow.com/a/32095106/646947 for details.
+ * Prefer these methods in priority order (0 > 1 > 2)
+ */
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+#  if defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
+                        || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
+                        || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
+#    define XXH_FORCE_MEMORY_ACCESS 2
+#  elif (defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
+  (defined(__GNUC__) && ( defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \
+                    || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \
+                    || defined(__ARM_ARCH_7S__) ))
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
+#endif
+
+/*!XXH_ACCEPT_NULL_INPUT_POINTER :
+ * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
+ * When this macro is enabled, xxHash actively checks input for null pointer.
+ * It it is, result for null input pointers is the same as a null-length input.
+ */
+#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
+#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
+#endif
+
+/*!XXH_FORCE_NATIVE_FORMAT :
+ * By default, xxHash library provides endian-independent Hash values, based on little-endian convention.
+ * Results are therefore identical for little-endian and big-endian CPU.
+ * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
+ * Should endian-independence be of no importance for your application, you may set the #define below to 1,
+ * to improve speed for Big-endian CPU.
+ * This option has no impact on Little_Endian CPU.
+ */
+#ifndef XXH_FORCE_NATIVE_FORMAT   /* can be defined externally */
+#  define XXH_FORCE_NATIVE_FORMAT 0
+#endif
+
+/*!XXH_FORCE_ALIGN_CHECK :
+ * This is a minor performance trick, only useful with lots of very small keys.
+ * It means : check for aligned/unaligned input.
+ * The check costs one initial branch per hash;
+ * set it to 0 when the input is guaranteed to be aligned,
+ * or when alignment doesn't matter for performance.
+ */
+#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
+#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+/*! Modify the local functions below should you wish to use some other memory routines
+*   for malloc(), free() */
+#include <stdlib.h>
+static void* XXH_malloc(size_t s) { return malloc(s); }
+static void  XXH_free  (void* p)  { free(p); }
+/*! and for memcpy() */
+#include <string.h>
+static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
+
+#include <assert.h>   /* assert */
+
+#define XXH_STATIC_LINKING_ONLY
+#include "xxhash.h"
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER    /* Visual Studio */
+#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
+#  define FORCE_INLINE static __forceinline
+#else
+#  if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#    ifdef __GNUC__
+#      define FORCE_INLINE static inline __attribute__((always_inline))
+#    else
+#      define FORCE_INLINE static inline
+#    endif
+#  else
+#    define FORCE_INLINE static
+#  endif /* __STDC_VERSION__ */
+#endif
+
+
+/* *************************************
+*  Basic Types
+***************************************/
+#ifndef MEM_MODULE
+# if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   include <stdint.h>
+    typedef uint8_t  BYTE;
+    typedef uint16_t U16;
+    typedef uint32_t U32;
+# else
+    typedef unsigned char      BYTE;
+    typedef unsigned short     U16;
+    typedef unsigned int       U32;
+# endif
+#endif
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
+/* currently only defined for gcc and icc */
+typedef union { U32 u32; } __attribute__((packed)) unalign;
+static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
+
+#else
+
+/* portable and safe solution. Generally efficient.
+ * see : http://stackoverflow.com/a/32095106/646947
+ */
+static U32 XXH_read32(const void* memPtr)
+{
+    U32 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
+#if defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) ((x << r) | (x >> (32 - r)))
+#  define XXH_rotl64(x,r) ((x << r) | (x >> (64 - r)))
+#endif
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap32 __builtin_bswap32
+#else
+static U32 XXH_swap32 (U32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* *************************************
+*  Architecture Macros
+***************************************/
+typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
+
+/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+static int XXH_isLittleEndian(void)
+{
+    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
+
+FORCE_INLINE U32 XXH_readLE32_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+    else
+        return endian==XXH_littleEndian ? *(const U32*)ptr : XXH_swap32(*(const U32*)ptr);
+}
+
+FORCE_INLINE U32 XXH_readLE32(const void* ptr, XXH_endianess endian)
+{
+    return XXH_readLE32_align(ptr, endian, XXH_unaligned);
+}
+
+static U32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+
+
+/* *************************************
+*  Macros
+***************************************/
+#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }  /* use after variable declarations */
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+static const U32 PRIME32_1 = 2654435761U;
+static const U32 PRIME32_2 = 2246822519U;
+static const U32 PRIME32_3 = 3266489917U;
+static const U32 PRIME32_4 =  668265263U;
+static const U32 PRIME32_5 =  374761393U;
+
+static U32 XXH32_round(U32 seed, U32 input)
+{
+    seed += input * PRIME32_2;
+    seed  = XXH_rotl32(seed, 13);
+    seed *= PRIME32_1;
+    return seed;
+}
+
+/* mix all bits */
+static U32 XXH32_avalanche(U32 h32)
+{
+    h32 ^= h32 >> 15;
+    h32 *= PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= PRIME32_3;
+    h32 ^= h32 >> 16;
+    return(h32);
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, endian, align)
+
+static U32
+XXH32_finalize(U32 h32, const void* ptr, size_t len,
+                XXH_endianess endian, XXH_alignment align)
+
+{
+    const BYTE* p = (const BYTE*)ptr;
+#define PROCESS1             \
+    h32 += (*p) * PRIME32_5; \
+    p++;                     \
+    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
+
+#define PROCESS4                         \
+    h32 += XXH_get32bits(p) * PRIME32_3; \
+    p+=4;                                \
+    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
+
+    switch(len&15)  /* or switch(bEnd - p) */
+    {
+      case 12:      PROCESS4;
+                    [[fallthrough]];
+      case 8:       PROCESS4;
+                    [[fallthrough]];
+      case 4:       PROCESS4;
+                    return XXH32_avalanche(h32);
+
+      case 13:      PROCESS4;
+                    [[fallthrough]];
+      case 9:       PROCESS4;
+                    [[fallthrough]];
+      case 5:       PROCESS4;
+                    PROCESS1;
+                    return XXH32_avalanche(h32);
+
+      case 14:      PROCESS4;
+                    [[fallthrough]];
+      case 10:      PROCESS4;
+                    [[fallthrough]];
+      case 6:       PROCESS4;
+                    PROCESS1;
+                    PROCESS1;
+                    return XXH32_avalanche(h32);
+
+      case 15:      PROCESS4;
+                    [[fallthrough]];
+      case 11:      PROCESS4;
+                    [[fallthrough]];
+      case 7:       PROCESS4;
+                    [[fallthrough]];
+      case 3:       PROCESS1;
+                    [[fallthrough]];
+      case 2:       PROCESS1;
+                    [[fallthrough]];
+      case 1:       PROCESS1;
+                    [[fallthrough]];
+      case 0:       return XXH32_avalanche(h32);
+    }
+    assert(0);
+    return h32;   /* reaching this point is deemed impossible */
+}
+
+
+FORCE_INLINE U32
+XXH32_endian_align(const void* input, size_t len, U32 seed,
+                    XXH_endianess endian, XXH_alignment align)
+{
+    const BYTE* p = (const BYTE*)input;
+    const BYTE* bEnd = p + len;
+    U32 h32;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (p==NULL) {
+        len=0;
+        bEnd=p=(const BYTE*)(size_t)16;
+    }
+#endif
+
+    if (len>=16) {
+        const BYTE* const limit = bEnd - 15;
+        U32 v1 = seed + PRIME32_1 + PRIME32_2;
+        U32 v2 = seed + PRIME32_2;
+        U32 v3 = seed + 0;
+        U32 v4 = seed - PRIME32_1;
+
+        do {
+            v1 = XXH32_round(v1, XXH_get32bits(p)); p+=4;
+            v2 = XXH32_round(v2, XXH_get32bits(p)); p+=4;
+            v3 = XXH32_round(v3, XXH_get32bits(p)); p+=4;
+            v4 = XXH32_round(v4, XXH_get32bits(p)); p+=4;
+        } while (p < limit);
+
+        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
+            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
+    } else {
+        h32  = seed + PRIME32_5;
+    }
+
+    h32 += (U32)len;
+
+    return XXH32_finalize(h32, p, len&15, endian, align);
+}
+
+
+XXH_PUBLIC_API unsigned int XXH32 (const void* input, size_t len, unsigned int seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, input, len);
+    return XXH32_digest(&state);
+#else
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+                return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
+            else
+                return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
+    }   }
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
+    else
+        return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
+#endif
+}
+
+
+
+/*======   Hash streaming   ======*/
+
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, unsigned int seed)
+{
+    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME32_1 + PRIME32_2;
+    state.v2 = seed + PRIME32_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME32_1;
+    /* do not write into reserved, planned to be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
+    return XXH_OK;
+}
+
+
+FORCE_INLINE
+XXH_errorcode XXH32_update_endian (XXH32_state_t* state, const void* input, size_t len, XXH_endianess endian)
+{
+    const BYTE* p = (const BYTE*)input;
+    const BYTE* const bEnd = p + len;
+
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    state->total_len_32 += (unsigned)len;
+    state->large_len |= (len>=16) | (state->total_len_32>=16);
+
+    if (state->memsize + len < 16)  {   /* fill in tmp buffer */
+        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, len);
+        state->memsize += (unsigned)len;
+        return XXH_OK;
+    }
+
+    if (state->memsize) {   /* some data left from previous update */
+        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, 16-state->memsize);
+        {   const U32* p32 = state->mem32;
+            state->v1 = XXH32_round(state->v1, XXH_readLE32(p32, endian)); p32++;
+            state->v2 = XXH32_round(state->v2, XXH_readLE32(p32, endian)); p32++;
+            state->v3 = XXH32_round(state->v3, XXH_readLE32(p32, endian)); p32++;
+            state->v4 = XXH32_round(state->v4, XXH_readLE32(p32, endian));
+        }
+        p += 16-state->memsize;
+        state->memsize = 0;
+    }
+
+    if (p <= bEnd-16) {
+        const BYTE* const limit = bEnd - 16;
+        U32 v1 = state->v1;
+        U32 v2 = state->v2;
+        U32 v3 = state->v3;
+        U32 v4 = state->v4;
+
+        do {
+            v1 = XXH32_round(v1, XXH_readLE32(p, endian)); p+=4;
+            v2 = XXH32_round(v2, XXH_readLE32(p, endian)); p+=4;
+            v3 = XXH32_round(v3, XXH_readLE32(p, endian)); p+=4;
+            v4 = XXH32_round(v4, XXH_readLE32(p, endian)); p+=4;
+        } while (p<=limit);
+
+        state->v1 = v1;
+        state->v2 = v2;
+        state->v3 = v3;
+        state->v4 = v4;
+    }
+
+    if (p < bEnd) {
+        XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
+        state->memsize = (unsigned)(bEnd-p);
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* state_in, const void* input, size_t len)
+{
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH32_update_endian(state_in, input, len, XXH_littleEndian);
+    else
+        return XXH32_update_endian(state_in, input, len, XXH_bigEndian);
+}
+
+
+FORCE_INLINE U32
+XXH32_digest_endian (const XXH32_state_t* state, XXH_endianess endian)
+{
+    U32 h32;
+
+    if (state->large_len) {
+        h32 = XXH_rotl32(state->v1, 1)
+            + XXH_rotl32(state->v2, 7)
+            + XXH_rotl32(state->v3, 12)
+            + XXH_rotl32(state->v4, 18);
+    } else {
+        h32 = state->v3 /* == seed */ + PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, state->mem32, state->memsize, endian, XXH_aligned);
+}
+
+
+XXH_PUBLIC_API unsigned int XXH32_digest (const XXH32_state_t* state_in)
+{
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH32_digest_endian(state_in, XXH_littleEndian);
+    else
+        return XXH32_digest_endian(state_in, XXH_bigEndian);
+}
+
+
+/*======   Canonical representation   ======*/
+
+/*! Default XXH result types are basic unsigned 32 and 64 bits.
+*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
+*   These functions allow transformation of hash result into and from its canonical format.
+*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
+*/
+
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+
+/*======   Memory access   ======*/
+
+#ifndef MEM_MODULE
+# define MEM_MODULE
+# if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   include <stdint.h>
+    typedef uint64_t U64;
+# else
+    /* if compiler doesn't support unsigned long long, replace by another 64-bit type */
+    typedef unsigned long long U64;
+# endif
+#endif
+
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
+/* currently only defined for gcc and icc */
+typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign64;
+static U64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
+
+#else
+
+/* portable and safe solution. Generally efficient.
+ * see : http://stackoverflow.com/a/32095106/646947
+ */
+
+static U64 XXH_read64(const void* memPtr)
+{
+    U64 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap64 __builtin_bswap64
+#else
+static U64 XXH_swap64 (U64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+FORCE_INLINE U64 XXH_readLE64_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+    else
+        return endian==XXH_littleEndian ? *(const U64*)ptr : XXH_swap64(*(const U64*)ptr);
+}
+
+FORCE_INLINE U64 XXH_readLE64(const void* ptr, XXH_endianess endian)
+{
+    return XXH_readLE64_align(ptr, endian, XXH_unaligned);
+}
+
+static U64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+
+
+/*======   xxh64   ======*/
+
+static const U64 PRIME64_1 = 11400714785074694791ULL;
+static const U64 PRIME64_2 = 14029467366897019727ULL;
+static const U64 PRIME64_3 =  1609587929392839161ULL;
+static const U64 PRIME64_4 =  9650029242287828579ULL;
+static const U64 PRIME64_5 =  2870177450012600261ULL;
+
+static U64 XXH64_round(U64 acc, U64 input)
+{
+    acc += input * PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= PRIME64_1;
+    return acc;
+}
+
+static U64 XXH64_mergeRound(U64 acc, U64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * PRIME64_1 + PRIME64_4;
+    return acc;
+}
+
+static U64 XXH64_avalanche(U64 h64)
+{
+    h64 ^= h64 >> 33;
+    h64 *= PRIME64_2;
+    h64 ^= h64 >> 29;
+    h64 *= PRIME64_3;
+    h64 ^= h64 >> 32;
+    return h64;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, endian, align)
+
+static U64
+XXH64_finalize(U64 h64, const void* ptr, size_t len,
+               XXH_endianess endian, XXH_alignment align)
+{
+    const BYTE* p = (const BYTE*)ptr;
+
+#define PROCESS1_64          \
+    h64 ^= (*p) * PRIME64_5; \
+    p++;                     \
+    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
+
+#define PROCESS4_64          \
+    h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1; \
+    p+=4;                    \
+    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
+
+#define PROCESS8_64 {        \
+    U64 const k1 = XXH64_round(0, XXH_get64bits(p)); \
+    p+=8;                    \
+    h64 ^= k1;               \
+    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
+}
+
+    switch(len&31) {
+      case 24: PROCESS8_64;
+                    [[fallthrough]];
+      case 16: PROCESS8_64;
+                    [[fallthrough]];
+      case  8: PROCESS8_64;
+               return XXH64_avalanche(h64);
+
+      case 28: PROCESS8_64;
+                    [[fallthrough]];
+      case 20: PROCESS8_64;
+                    [[fallthrough]];
+      case 12: PROCESS8_64;
+                    [[fallthrough]];
+      case  4: PROCESS4_64;
+               return XXH64_avalanche(h64);
+
+      case 25: PROCESS8_64;
+                    [[fallthrough]];
+      case 17: PROCESS8_64;
+                    [[fallthrough]];
+      case  9: PROCESS8_64;
+               PROCESS1_64;
+               return XXH64_avalanche(h64);
+
+      case 29: PROCESS8_64;
+                    [[fallthrough]];
+      case 21: PROCESS8_64;
+                    [[fallthrough]];
+      case 13: PROCESS8_64;
+                    [[fallthrough]];
+      case  5: PROCESS4_64;
+               PROCESS1_64;
+               return XXH64_avalanche(h64);
+
+      case 26: PROCESS8_64;
+                    [[fallthrough]];
+      case 18: PROCESS8_64;
+                    [[fallthrough]];
+      case 10: PROCESS8_64;
+               PROCESS1_64;
+               PROCESS1_64;
+               return XXH64_avalanche(h64);
+
+      case 30: PROCESS8_64;
+                    [[fallthrough]];
+      case 22: PROCESS8_64;
+                    [[fallthrough]];
+      case 14: PROCESS8_64;
+                    [[fallthrough]];
+      case  6: PROCESS4_64;
+               PROCESS1_64;
+               PROCESS1_64;
+               return XXH64_avalanche(h64);
+
+      case 27: PROCESS8_64;
+                    [[fallthrough]];
+      case 19: PROCESS8_64;
+                    [[fallthrough]];
+      case 11: PROCESS8_64;
+               PROCESS1_64;
+               PROCESS1_64;
+               PROCESS1_64;
+               return XXH64_avalanche(h64);
+
+      case 31: PROCESS8_64;
+                    [[fallthrough]];
+      case 23: PROCESS8_64;
+                    [[fallthrough]];
+      case 15: PROCESS8_64;
+                    [[fallthrough]];
+      case  7: PROCESS4_64;
+                    [[fallthrough]];
+      case  3: PROCESS1_64;
+                    [[fallthrough]];
+      case  2: PROCESS1_64;
+                    [[fallthrough]];
+      case  1: PROCESS1_64;
+                    [[fallthrough]];
+      case  0: return XXH64_avalanche(h64);
+    }
+
+    /* impossible to reach */
+    assert(0);
+    return 0;  /* unreachable, but some compilers complain without it */
+}
+
+FORCE_INLINE U64
+XXH64_endian_align(const void* input, size_t len, U64 seed,
+                XXH_endianess endian, XXH_alignment align)
+{
+    const BYTE* p = (const BYTE*)input;
+    const BYTE* bEnd = p + len;
+    U64 h64;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (p==NULL) {
+        len=0;
+        bEnd=p=(const BYTE*)(size_t)32;
+    }
+#endif
+
+    if (len>=32) {
+        const BYTE* const limit = bEnd - 32;
+        U64 v1 = seed + PRIME64_1 + PRIME64_2;
+        U64 v2 = seed + PRIME64_2;
+        U64 v3 = seed + 0;
+        U64 v4 = seed - PRIME64_1;
+
+        do {
+            v1 = XXH64_round(v1, XXH_get64bits(p)); p+=8;
+            v2 = XXH64_round(v2, XXH_get64bits(p)); p+=8;
+            v3 = XXH64_round(v3, XXH_get64bits(p)); p+=8;
+            v4 = XXH64_round(v4, XXH_get64bits(p)); p+=8;
+        } while (p<=limit);
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+
+    } else {
+        h64  = seed + PRIME64_5;
+    }
+
+    h64 += (U64) len;
+
+    return XXH64_finalize(h64, p, len, endian, align);
+}
+
+
+XXH_PUBLIC_API unsigned long long XXH64 (const void* input, size_t len, unsigned long long seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, input, len);
+    return XXH64_digest(&state);
+#else
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+                return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
+            else
+                return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
+    }   }
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
+    else
+        return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
+#endif
+}
+
+/*======   Hash Streaming   ======*/
+
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, unsigned long long seed)
+{
+    XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME64_1 + PRIME64_2;
+    state.v2 = seed + PRIME64_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME64_1;
+     /* do not write into reserved, planned to be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
+    return XXH_OK;
+}
+
+FORCE_INLINE
+XXH_errorcode XXH64_update_endian (XXH64_state_t* state, const void* input, size_t len, XXH_endianess endian)
+{
+    const BYTE* p = (const BYTE*)input;
+    const BYTE* const bEnd = p + len;
+
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    state->total_len += len;
+
+    if (state->memsize + len < 32) {  /* fill in tmp buffer */
+        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, len);
+        state->memsize += (U32)len;
+        return XXH_OK;
+    }
+
+    if (state->memsize) {   /* tmp buffer is full */
+        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, 32-state->memsize);
+        state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));
+        state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));
+        state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));
+        state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));
+        p += 32-state->memsize;
+        state->memsize = 0;
+    }
+
+    if (p+32 <= bEnd) {
+        const BYTE* const limit = bEnd - 32;
+        U64 v1 = state->v1;
+        U64 v2 = state->v2;
+        U64 v3 = state->v3;
+        U64 v4 = state->v4;
+
+        do {
+            v1 = XXH64_round(v1, XXH_readLE64(p, endian)); p+=8;
+            v2 = XXH64_round(v2, XXH_readLE64(p, endian)); p+=8;
+            v3 = XXH64_round(v3, XXH_readLE64(p, endian)); p+=8;
+            v4 = XXH64_round(v4, XXH_readLE64(p, endian)); p+=8;
+        } while (p<=limit);
+
+        state->v1 = v1;
+        state->v2 = v2;
+        state->v3 = v3;
+        state->v4 = v4;
+    }
+
+    if (p < bEnd) {
+        XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
+        state->memsize = (unsigned)(bEnd-p);
+    }
+
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* state_in, const void* input, size_t len)
+{
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
+    else
+        return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
+}
+
+FORCE_INLINE U64 XXH64_digest_endian (const XXH64_state_t* state, XXH_endianess endian)
+{
+    U64 h64;
+
+    if (state->total_len >= 32) {
+        U64 const v1 = state->v1;
+        U64 const v2 = state->v2;
+        U64 const v3 = state->v3;
+        U64 const v4 = state->v4;
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+    } else {
+        h64  = state->v3 /*seed*/ + PRIME64_5;
+    }
+
+    h64 += (U64) state->total_len;
+
+    return XXH64_finalize(h64, state->mem64, (size_t)state->total_len, endian, XXH_aligned);
+}
+
+XXH_PUBLIC_API unsigned long long XXH64_digest (const XXH64_state_t* state_in)
+{
+    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
+
+    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
+        return XXH64_digest_endian(state_in, XXH_littleEndian);
+    else
+        return XXH64_digest_endian(state_in, XXH_bigEndian);
+}
+
+
+/*====== Canonical representation   ======*/
+
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+#endif  /* XXH_NO_LONG_LONG */
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./external/xxhash/xxhash.h ./external/xxhash/xxhash.h
--- ./external/xxhash/xxhash.h	2019-10-15 18:26:53.568949244 -0700
+++ ./external/xxhash/xxhash.h	2020-04-12 20:09:05.632633131 -0700
@@ -313,11 +313,11 @@
 
 # endif
 
 
 #if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
-#  include "xxhash.c"   /* include xxhash function bodies as `static`, for inlining */
+#  include "xxhash.cpp"   /* include xxhash function bodies as `static`, for inlining */
 #endif
 
 #endif /* XXH_STATIC_LINKING_ONLY */
 
 
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/AllSyntax.cpp ./generated/AllSyntax.cpp
--- ./generated/AllSyntax.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/AllSyntax.cpp	2020-04-13 10:23:52.710371660 -0700
@@ -0,0 +1,12978 @@
+//------------------------------------------------------------------------------
+// AllSyntax.cpp
+// All generated syntax node data structures
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#include "slang/syntax/AllSyntax.h"
+
+// This file contains all parse tree syntax node generated definitions.
+// It is auto-generated by the syntax_gen.py script under the scripts/ directory.
+
+namespace slang {
+
+size_t SyntaxNode::getChildCount() const {
+    switch (kind) {
+        case SyntaxKind::Unknown: return 0;
+        case SyntaxKind::SyntaxList:
+        case SyntaxKind::TokenList:
+        case SyntaxKind::SeparatedList:
+            return ((const SyntaxListBase*)this)->getChildCount();
+        case SyntaxKind::AcceptOnPropertyExpression: return 3;
+        case SyntaxKind::ActionBlock: return 2;
+        case SyntaxKind::AddAssignmentExpression: return 4;
+        case SyntaxKind::AddExpression: return 4;
+        case SyntaxKind::AlwaysBlock: return 3;
+        case SyntaxKind::AlwaysCombBlock: return 3;
+        case SyntaxKind::AlwaysFFBlock: return 3;
+        case SyntaxKind::AlwaysLatchBlock: return 3;
+        case SyntaxKind::AlwaysPropertyExpression: return 3;
+        case SyntaxKind::AndAssignmentExpression: return 4;
+        case SyntaxKind::AndSequenceExpression: return 4;
+        case SyntaxKind::AnsiPortList: return 3;
+        case SyntaxKind::ArgumentList: return 3;
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return 4;
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return 4;
+        case SyntaxKind::ArithmeticShiftLeftExpression: return 4;
+        case SyntaxKind::ArithmeticShiftRightExpression: return 4;
+        case SyntaxKind::ArrayAndMethod: return 1;
+        case SyntaxKind::ArrayOrMethod: return 1;
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return 4;
+        case SyntaxKind::ArrayUniqueMethod: return 1;
+        case SyntaxKind::ArrayXorMethod: return 1;
+        case SyntaxKind::AscendingRangeSelect: return 3;
+        case SyntaxKind::AssertPropertyStatement: return 8;
+        case SyntaxKind::AssertionItemPort: return 5;
+        case SyntaxKind::AssertionItemPortList: return 3;
+        case SyntaxKind::AssignmentExpression: return 4;
+        case SyntaxKind::AssignmentPatternExpression: return 2;
+        case SyntaxKind::AssignmentPatternItem: return 3;
+        case SyntaxKind::AssumePropertyStatement: return 8;
+        case SyntaxKind::AttributeInstance: return 3;
+        case SyntaxKind::AttributeSpec: return 2;
+        case SyntaxKind::BadExpression: return 1;
+        case SyntaxKind::BeginKeywordsDirective: return 2;
+        case SyntaxKind::BinaryAndExpression: return 4;
+        case SyntaxKind::BinaryBlockEventExpression: return 3;
+        case SyntaxKind::BinaryEventExpression: return 3;
+        case SyntaxKind::BinaryOrExpression: return 4;
+        case SyntaxKind::BinarySequenceDelayExpression: return 4;
+        case SyntaxKind::BinaryXnorExpression: return 4;
+        case SyntaxKind::BinaryXorExpression: return 4;
+        case SyntaxKind::BitSelect: return 1;
+        case SyntaxKind::BitType: return 3;
+        case SyntaxKind::BlockCoverageEvent: return 4;
+        case SyntaxKind::BlockingEventTriggerStatement: return 5;
+        case SyntaxKind::ByteType: return 3;
+        case SyntaxKind::CHandleType: return 1;
+        case SyntaxKind::CaseEqualityExpression: return 4;
+        case SyntaxKind::CaseGenerate: return 7;
+        case SyntaxKind::CaseInequalityExpression: return 4;
+        case SyntaxKind::CaseStatement: return 10;
+        case SyntaxKind::CastExpression: return 3;
+        case SyntaxKind::CellDefineDirective: return 1;
+        case SyntaxKind::ChargeStrength: return 3;
+        case SyntaxKind::ClassDeclaration: return 12;
+        case SyntaxKind::ClassMethodDeclaration: return 3;
+        case SyntaxKind::ClassMethodPrototype: return 4;
+        case SyntaxKind::ClassName: return 2;
+        case SyntaxKind::ClassPropertyDeclaration: return 3;
+        case SyntaxKind::ClassScope: return 2;
+        case SyntaxKind::ClockingDeclaration: return 11;
+        case SyntaxKind::ClockingDirection: return 5;
+        case SyntaxKind::ClockingItem: return 5;
+        case SyntaxKind::ClockingSkew: return 3;
+        case SyntaxKind::ColonExpressionClause: return 2;
+        case SyntaxKind::CompilationUnit: return 2;
+        case SyntaxKind::ConcatenationExpression: return 3;
+        case SyntaxKind::ConcurrentAssertionMember: return 2;
+        case SyntaxKind::ConditionalConstraint: return 6;
+        case SyntaxKind::ConditionalExpression: return 6;
+        case SyntaxKind::ConditionalPattern: return 2;
+        case SyntaxKind::ConditionalPredicate: return 1;
+        case SyntaxKind::ConditionalStatement: return 9;
+        case SyntaxKind::ConstraintBlock: return 3;
+        case SyntaxKind::ConstraintDeclaration: return 5;
+        case SyntaxKind::ConstraintPrototype: return 5;
+        case SyntaxKind::ConstructorName: return 1;
+        case SyntaxKind::ContinuousAssign: return 6;
+        case SyntaxKind::CoverPropertyStatement: return 8;
+        case SyntaxKind::CoverSequenceStatement: return 8;
+        case SyntaxKind::CoverageBins: return 9;
+        case SyntaxKind::CoverageOption: return 7;
+        case SyntaxKind::CovergroupDeclaration: return 9;
+        case SyntaxKind::Coverpoint: return 9;
+        case SyntaxKind::CycleDelay: return 2;
+        case SyntaxKind::DPIImportExport: return 8;
+        case SyntaxKind::DataDeclaration: return 5;
+        case SyntaxKind::Declarator: return 3;
+        case SyntaxKind::DefParam: return 4;
+        case SyntaxKind::DefParamAssignment: return 2;
+        case SyntaxKind::DefaultCaseItem: return 3;
+        case SyntaxKind::DefaultCoverageBinInitializer: return 2;
+        case SyntaxKind::DefaultNetTypeDirective: return 2;
+        case SyntaxKind::DefaultPatternKeyExpression: return 1;
+        case SyntaxKind::DeferredAssertion: return 3;
+        case SyntaxKind::DefineDirective: return 4;
+        case SyntaxKind::Delay3: return 8;
+        case SyntaxKind::DelayControl: return 2;
+        case SyntaxKind::DescendingRangeSelect: return 3;
+        case SyntaxKind::DisableConstraint: return 4;
+        case SyntaxKind::DisableForkStatement: return 5;
+        case SyntaxKind::DisableIff: return 5;
+        case SyntaxKind::DisableStatement: return 5;
+        case SyntaxKind::DistConstraintList: return 4;
+        case SyntaxKind::DistItem: return 2;
+        case SyntaxKind::DistWeight: return 2;
+        case SyntaxKind::DivideAssignmentExpression: return 4;
+        case SyntaxKind::DivideExpression: return 4;
+        case SyntaxKind::DividerClause: return 2;
+        case SyntaxKind::DoWhileStatement: return 9;
+        case SyntaxKind::DotMemberClause: return 2;
+        case SyntaxKind::DriveStrength: return 5;
+        case SyntaxKind::ElementSelect: return 3;
+        case SyntaxKind::ElementSelectExpression: return 2;
+        case SyntaxKind::ElsIfDirective: return 3;
+        case SyntaxKind::ElseClause: return 2;
+        case SyntaxKind::ElseConstraintClause: return 2;
+        case SyntaxKind::ElseDirective: return 2;
+        case SyntaxKind::EmptyArgument: return 1;
+        case SyntaxKind::EmptyIdentifierName: return 1;
+        case SyntaxKind::EmptyMember: return 3;
+        case SyntaxKind::EmptyQueueExpression: return 2;
+        case SyntaxKind::EmptyStatement: return 3;
+        case SyntaxKind::EndCellDefineDirective: return 1;
+        case SyntaxKind::EndIfDirective: return 2;
+        case SyntaxKind::EndKeywordsDirective: return 1;
+        case SyntaxKind::EnumType: return 6;
+        case SyntaxKind::EqualityExpression: return 4;
+        case SyntaxKind::EqualsTypeClause: return 2;
+        case SyntaxKind::EqualsValueClause: return 2;
+        case SyntaxKind::EventControl: return 2;
+        case SyntaxKind::EventControlWithExpression: return 2;
+        case SyntaxKind::EventType: return 1;
+        case SyntaxKind::EventuallyPropertyExpression: return 3;
+        case SyntaxKind::ExpectPropertyStatement: return 8;
+        case SyntaxKind::ExplicitAnsiPort: return 7;
+        case SyntaxKind::ExplicitNonAnsiPort: return 5;
+        case SyntaxKind::ExpressionConstraint: return 3;
+        case SyntaxKind::ExpressionCoverageBinInitializer: return 2;
+        case SyntaxKind::ExpressionOrDist: return 2;
+        case SyntaxKind::ExpressionPattern: return 1;
+        case SyntaxKind::ExpressionStatement: return 4;
+        case SyntaxKind::ExtendsClause: return 3;
+        case SyntaxKind::ExternModule: return 2;
+        case SyntaxKind::FinalBlock: return 3;
+        case SyntaxKind::ForLoopStatement: return 11;
+        case SyntaxKind::ForVariableDeclaration: return 3;
+        case SyntaxKind::ForeachLoopList: return 6;
+        case SyntaxKind::ForeachLoopStatement: return 5;
+        case SyntaxKind::ForeverStatement: return 4;
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return 6;
+        case SyntaxKind::ForwardTypedefDeclaration: return 5;
+        case SyntaxKind::FunctionDeclaration: return 6;
+        case SyntaxKind::FunctionPort: return 6;
+        case SyntaxKind::FunctionPortList: return 3;
+        case SyntaxKind::FunctionPrototype: return 5;
+        case SyntaxKind::GateInstance: return 4;
+        case SyntaxKind::GateInstanceName: return 2;
+        case SyntaxKind::GateInstantiation: return 6;
+        case SyntaxKind::GenerateBlock: return 7;
+        case SyntaxKind::GenerateRegion: return 4;
+        case SyntaxKind::GenvarDeclaration: return 4;
+        case SyntaxKind::GreaterThanEqualExpression: return 4;
+        case SyntaxKind::GreaterThanExpression: return 4;
+        case SyntaxKind::HierarchicalInstance: return 5;
+        case SyntaxKind::HierarchyInstantiation: return 5;
+        case SyntaxKind::IdentifierName: return 1;
+        case SyntaxKind::IdentifierSelectName: return 2;
+        case SyntaxKind::IfDefDirective: return 3;
+        case SyntaxKind::IfGenerate: return 7;
+        case SyntaxKind::IfNDefDirective: return 3;
+        case SyntaxKind::IffClause: return 4;
+        case SyntaxKind::IffPropertyExpression: return 4;
+        case SyntaxKind::ImmediateAssertStatement: return 6;
+        case SyntaxKind::ImmediateAssertionMember: return 2;
+        case SyntaxKind::ImmediateAssumeStatement: return 6;
+        case SyntaxKind::ImmediateCoverStatement: return 6;
+        case SyntaxKind::ImplementsClause: return 2;
+        case SyntaxKind::ImplicationConstraint: return 3;
+        case SyntaxKind::ImplicitAnsiPort: return 3;
+        case SyntaxKind::ImplicitEventControl: return 4;
+        case SyntaxKind::ImplicitNonAnsiPort: return 1;
+        case SyntaxKind::ImplicitType: return 2;
+        case SyntaxKind::ImpliesPropertyExpression: return 4;
+        case SyntaxKind::IncludeDirective: return 2;
+        case SyntaxKind::InequalityExpression: return 4;
+        case SyntaxKind::InitialBlock: return 3;
+        case SyntaxKind::InsideExpression: return 3;
+        case SyntaxKind::IntType: return 3;
+        case SyntaxKind::IntegerLiteralExpression: return 1;
+        case SyntaxKind::IntegerType: return 3;
+        case SyntaxKind::IntegerVectorExpression: return 3;
+        case SyntaxKind::InterconnectPortHeader: return 3;
+        case SyntaxKind::InterfaceDeclaration: return 5;
+        case SyntaxKind::InterfaceHeader: return 7;
+        case SyntaxKind::InterfacePortHeader: return 2;
+        case SyntaxKind::IntersectSequenceExpression: return 4;
+        case SyntaxKind::InvocationExpression: return 3;
+        case SyntaxKind::JumpStatement: return 4;
+        case SyntaxKind::LessThanEqualExpression: return 4;
+        case SyntaxKind::LessThanExpression: return 4;
+        case SyntaxKind::LetDeclaration: return 6;
+        case SyntaxKind::LineDirective: return 4;
+        case SyntaxKind::LocalScope: return 1;
+        case SyntaxKind::LogicType: return 3;
+        case SyntaxKind::LogicalAndExpression: return 4;
+        case SyntaxKind::LogicalEquivalenceExpression: return 4;
+        case SyntaxKind::LogicalImplicationExpression: return 4;
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return 4;
+        case SyntaxKind::LogicalOrExpression: return 4;
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return 4;
+        case SyntaxKind::LogicalShiftLeftExpression: return 4;
+        case SyntaxKind::LogicalShiftRightExpression: return 4;
+        case SyntaxKind::LongIntType: return 3;
+        case SyntaxKind::LoopConstraint: return 3;
+        case SyntaxKind::LoopGenerate: return 13;
+        case SyntaxKind::LoopStatement: return 7;
+        case SyntaxKind::MacroActualArgument: return 1;
+        case SyntaxKind::MacroActualArgumentList: return 3;
+        case SyntaxKind::MacroArgumentDefault: return 2;
+        case SyntaxKind::MacroFormalArgument: return 2;
+        case SyntaxKind::MacroFormalArgumentList: return 3;
+        case SyntaxKind::MacroUsage: return 2;
+        case SyntaxKind::MatchesClause: return 2;
+        case SyntaxKind::MemberAccessExpression: return 3;
+        case SyntaxKind::MinTypMaxExpression: return 5;
+        case SyntaxKind::ModAssignmentExpression: return 4;
+        case SyntaxKind::ModExpression: return 4;
+        case SyntaxKind::ModportClockingPort: return 3;
+        case SyntaxKind::ModportDeclaration: return 4;
+        case SyntaxKind::ModportExplicitPort: return 5;
+        case SyntaxKind::ModportItem: return 2;
+        case SyntaxKind::ModportNamedPort: return 1;
+        case SyntaxKind::ModportSimplePortList: return 3;
+        case SyntaxKind::ModportSubroutinePort: return 1;
+        case SyntaxKind::ModportSubroutinePortList: return 3;
+        case SyntaxKind::ModuleDeclaration: return 5;
+        case SyntaxKind::ModuleHeader: return 7;
+        case SyntaxKind::MultipleConcatenationExpression: return 4;
+        case SyntaxKind::MultiplyAssignmentExpression: return 4;
+        case SyntaxKind::MultiplyExpression: return 4;
+        case SyntaxKind::NameValuePragmaExpression: return 3;
+        case SyntaxKind::NamedArgument: return 5;
+        case SyntaxKind::NamedBlockClause: return 2;
+        case SyntaxKind::NamedLabel: return 2;
+        case SyntaxKind::NamedPortConnection: return 6;
+        case SyntaxKind::NamedStructurePatternMember: return 3;
+        case SyntaxKind::NamedType: return 1;
+        case SyntaxKind::NetDeclaration: return 8;
+        case SyntaxKind::NetPortHeader: return 3;
+        case SyntaxKind::NetTypeDeclaration: return 6;
+        case SyntaxKind::NewArrayExpression: return 5;
+        case SyntaxKind::NewClassExpression: return 3;
+        case SyntaxKind::NewExpression: return 2;
+        case SyntaxKind::NextTimePropertyExpression: return 3;
+        case SyntaxKind::NoUnconnectedDriveDirective: return 1;
+        case SyntaxKind::NonAnsiPortList: return 3;
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return 4;
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return 4;
+        case SyntaxKind::NonblockingAssignmentExpression: return 4;
+        case SyntaxKind::NonblockingEventTriggerStatement: return 5;
+        case SyntaxKind::NullLiteralExpression: return 1;
+        case SyntaxKind::NumberPragmaExpression: return 3;
+        case SyntaxKind::OneStepLiteralExpression: return 1;
+        case SyntaxKind::OpenRangeExpression: return 5;
+        case SyntaxKind::OpenRangeList: return 3;
+        case SyntaxKind::OrAssignmentExpression: return 4;
+        case SyntaxKind::OrSequenceExpression: return 4;
+        case SyntaxKind::OrderedArgument: return 1;
+        case SyntaxKind::OrderedPortConnection: return 2;
+        case SyntaxKind::OrderedStructurePatternMember: return 1;
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return 4;
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return 4;
+        case SyntaxKind::PackageDeclaration: return 5;
+        case SyntaxKind::PackageHeader: return 7;
+        case SyntaxKind::PackageImportDeclaration: return 4;
+        case SyntaxKind::PackageImportItem: return 3;
+        case SyntaxKind::ParallelBlockStatement: return 7;
+        case SyntaxKind::ParameterDeclaration: return 3;
+        case SyntaxKind::ParameterDeclarationStatement: return 3;
+        case SyntaxKind::ParameterPortList: return 4;
+        case SyntaxKind::ParameterValueAssignment: return 2;
+        case SyntaxKind::ParenExpressionList: return 3;
+        case SyntaxKind::ParenPragmaExpression: return 3;
+        case SyntaxKind::ParenthesizedEventExpression: return 3;
+        case SyntaxKind::ParenthesizedExpression: return 3;
+        case SyntaxKind::PatternCaseItem: return 5;
+        case SyntaxKind::PortConcatenation: return 3;
+        case SyntaxKind::PortDeclaration: return 4;
+        case SyntaxKind::PortReference: return 2;
+        case SyntaxKind::PostdecrementExpression: return 3;
+        case SyntaxKind::PostincrementExpression: return 3;
+        case SyntaxKind::PowerExpression: return 4;
+        case SyntaxKind::PragmaDirective: return 3;
+        case SyntaxKind::PrimaryBlockEventExpression: return 2;
+        case SyntaxKind::ProceduralAssignStatement: return 7;
+        case SyntaxKind::ProceduralDeassignStatement: return 5;
+        case SyntaxKind::ProceduralForceStatement: return 7;
+        case SyntaxKind::ProceduralReleaseStatement: return 5;
+        case SyntaxKind::ProgramDeclaration: return 5;
+        case SyntaxKind::ProgramHeader: return 7;
+        case SyntaxKind::PropertyDeclaration: return 10;
+        case SyntaxKind::PropertySpec: return 3;
+        case SyntaxKind::PropertyType: return 1;
+        case SyntaxKind::QueueDimensionSpecifier: return 2;
+        case SyntaxKind::RandCaseItem: return 3;
+        case SyntaxKind::RandCaseStatement: return 5;
+        case SyntaxKind::RangeCoverageBinInitializer: return 2;
+        case SyntaxKind::RangeDimensionSpecifier: return 1;
+        case SyntaxKind::RealLiteralExpression: return 1;
+        case SyntaxKind::RealTimeType: return 1;
+        case SyntaxKind::RealType: return 1;
+        case SyntaxKind::RegType: return 3;
+        case SyntaxKind::RejectOnPropertyExpression: return 3;
+        case SyntaxKind::RepeatedEventControl: return 5;
+        case SyntaxKind::ReplicatedAssignmentPattern: return 6;
+        case SyntaxKind::ResetAllDirective: return 1;
+        case SyntaxKind::RestrictPropertyStatement: return 8;
+        case SyntaxKind::ReturnStatement: return 5;
+        case SyntaxKind::RootScope: return 1;
+        case SyntaxKind::SAlwaysPropertyExpression: return 3;
+        case SyntaxKind::SEventuallyPropertyExpression: return 3;
+        case SyntaxKind::SNextTimePropertyExpression: return 3;
+        case SyntaxKind::SUntilPropertyExpression: return 4;
+        case SyntaxKind::SUntilWithPropertyExpression: return 4;
+        case SyntaxKind::ScopedName: return 3;
+        case SyntaxKind::SequenceDeclaration: return 10;
+        case SyntaxKind::SequenceType: return 1;
+        case SyntaxKind::SequentialBlockStatement: return 7;
+        case SyntaxKind::ShortIntType: return 3;
+        case SyntaxKind::ShortRealType: return 1;
+        case SyntaxKind::ShortcutCycleDelayRange: return 4;
+        case SyntaxKind::SignalEventExpression: return 2;
+        case SyntaxKind::SignedCastExpression: return 3;
+        case SyntaxKind::SimpleAssignmentPattern: return 3;
+        case SyntaxKind::SimplePragmaExpression: return 1;
+        case SyntaxKind::SimpleRangeSelect: return 3;
+        case SyntaxKind::SolveBeforeConstraint: return 5;
+        case SyntaxKind::StandardCaseItem: return 3;
+        case SyntaxKind::StreamExpression: return 2;
+        case SyntaxKind::StreamExpressionWithRange: return 2;
+        case SyntaxKind::StreamingConcatenationExpression: return 7;
+        case SyntaxKind::StringLiteralExpression: return 1;
+        case SyntaxKind::StringType: return 1;
+        case SyntaxKind::StructType: return 8;
+        case SyntaxKind::StructUnionMember: return 5;
+        case SyntaxKind::StructurePattern: return 3;
+        case SyntaxKind::StructuredAssignmentPattern: return 3;
+        case SyntaxKind::SubtractAssignmentExpression: return 4;
+        case SyntaxKind::SubtractExpression: return 4;
+        case SyntaxKind::SuperHandle: return 1;
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return 3;
+        case SyntaxKind::SyncRejectOnPropertyExpression: return 3;
+        case SyntaxKind::SystemName: return 1;
+        case SyntaxKind::TaggedPattern: return 3;
+        case SyntaxKind::TaggedUnionExpression: return 3;
+        case SyntaxKind::TaskDeclaration: return 6;
+        case SyntaxKind::ThisHandle: return 1;
+        case SyntaxKind::ThroughoutSequenceExpression: return 4;
+        case SyntaxKind::TimeLiteralExpression: return 1;
+        case SyntaxKind::TimeScaleDirective: return 4;
+        case SyntaxKind::TimeType: return 3;
+        case SyntaxKind::TimeUnitsDeclaration: return 5;
+        case SyntaxKind::TimingControlExpression: return 2;
+        case SyntaxKind::TimingControlExpressionConcatenation: return 3;
+        case SyntaxKind::TimingControlStatement: return 4;
+        case SyntaxKind::TransListCoverageBinInitializer: return 2;
+        case SyntaxKind::TransRange: return 2;
+        case SyntaxKind::TransRepeatRange: return 4;
+        case SyntaxKind::TransSet: return 3;
+        case SyntaxKind::TypeAssignment: return 2;
+        case SyntaxKind::TypeParameterDeclaration: return 3;
+        case SyntaxKind::TypeReference: return 4;
+        case SyntaxKind::TypedefDeclaration: return 6;
+        case SyntaxKind::UnaryBitwiseAndExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNandExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNorExpression: return 3;
+        case SyntaxKind::UnaryBitwiseNotExpression: return 3;
+        case SyntaxKind::UnaryBitwiseOrExpression: return 3;
+        case SyntaxKind::UnaryBitwiseXnorExpression: return 3;
+        case SyntaxKind::UnaryBitwiseXorExpression: return 3;
+        case SyntaxKind::UnaryLogicalNotExpression: return 3;
+        case SyntaxKind::UnaryMinusExpression: return 3;
+        case SyntaxKind::UnaryNotPropertyExpression: return 3;
+        case SyntaxKind::UnaryPlusExpression: return 3;
+        case SyntaxKind::UnaryPredecrementExpression: return 3;
+        case SyntaxKind::UnaryPreincrementExpression: return 3;
+        case SyntaxKind::UnarySequenceDelayExpression: return 3;
+        case SyntaxKind::UnarySequenceEventExpression: return 3;
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return 1;
+        case SyntaxKind::UnconnectedDriveDirective: return 2;
+        case SyntaxKind::UndefDirective: return 2;
+        case SyntaxKind::UndefineAllDirective: return 1;
+        case SyntaxKind::UnionType: return 8;
+        case SyntaxKind::UniquenessConstraint: return 3;
+        case SyntaxKind::UnitScope: return 1;
+        case SyntaxKind::UntilPropertyExpression: return 4;
+        case SyntaxKind::UntilWithPropertyExpression: return 4;
+        case SyntaxKind::Untyped: return 1;
+        case SyntaxKind::VariableDimension: return 3;
+        case SyntaxKind::VariablePattern: return 2;
+        case SyntaxKind::VariablePortHeader: return 3;
+        case SyntaxKind::VirtualInterfaceType: return 5;
+        case SyntaxKind::VoidCastedCallStatement: return 8;
+        case SyntaxKind::VoidType: return 1;
+        case SyntaxKind::WaitForkStatement: return 5;
+        case SyntaxKind::WaitOrderStatement: return 7;
+        case SyntaxKind::WaitStatement: return 7;
+        case SyntaxKind::WildcardDimensionSpecifier: return 1;
+        case SyntaxKind::WildcardEqualityExpression: return 4;
+        case SyntaxKind::WildcardInequalityExpression: return 4;
+        case SyntaxKind::WildcardLiteralExpression: return 1;
+        case SyntaxKind::WildcardPattern: return 1;
+        case SyntaxKind::WildcardPortConnection: return 2;
+        case SyntaxKind::WildcardPortList: return 3;
+        case SyntaxKind::WithClause: return 4;
+        case SyntaxKind::WithFunctionClause: return 2;
+        case SyntaxKind::WithFunctionSample: return 4;
+        case SyntaxKind::WithinSequenceExpression: return 4;
+        case SyntaxKind::XorAssignmentExpression: return 4;
+    }
+    THROW_UNREACHABLE;
+}
+
+bool ActionBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ActionBlock;
+}
+
+TokenOrSyntax ActionBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return statement;
+        case 1: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ActionBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return statement;
+        case 1: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ActionBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: statement = &child.node()->as<StatementSyntax>(); return;
+        case 1: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ActionBlockSyntax* ActionBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ActionBlockSyntax>(*this);
+}
+
+bool AnsiPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AnsiPortList;
+}
+
+TokenOrSyntax AnsiPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AnsiPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AnsiPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<MemberSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AnsiPortListSyntax* AnsiPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AnsiPortListSyntax>(*this);
+}
+
+bool ArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ArgumentList;
+}
+
+TokenOrSyntax ArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &parameters;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &parameters;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: parameters = child.node()->as<SeparatedSyntaxList<ArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ArgumentListSyntax* ArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ArgumentListSyntax>(*this);
+}
+
+bool ArgumentSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::EmptyArgument:
+        case SyntaxKind::NamedArgument:
+        case SyntaxKind::OrderedArgument:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ArrayOrRandomizeMethodExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ArrayOrRandomizeMethodExpression;
+}
+
+TokenOrSyntax ArrayOrRandomizeMethodExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return method.get();
+        case 1: return with;
+        case 2: return args;
+        case 3: return constraints;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ArrayOrRandomizeMethodExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return method.get();
+        case 1: return with;
+        case 2: return args;
+        case 3: return constraints;
+        default: return nullptr;
+    }
+}
+
+void ArrayOrRandomizeMethodExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: method = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: with = child.token(); return;
+        case 2: args = &child.node()->as<ParenExpressionListSyntax>(); return;
+        case 3: constraints = &child.node()->as<ConstraintBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ArrayOrRandomizeMethodExpressionSyntax* ArrayOrRandomizeMethodExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ArrayOrRandomizeMethodExpressionSyntax>(*this);
+}
+
+bool AssertionItemPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssertionItemPortList;
+}
+
+TokenOrSyntax AssertionItemPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssertionItemPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AssertionItemPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<AssertionItemPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssertionItemPortListSyntax* AssertionItemPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssertionItemPortListSyntax>(*this);
+}
+
+bool AssertionItemPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssertionItemPort;
+}
+
+TokenOrSyntax AssertionItemPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return local;
+        case 2: return direction;
+        case 3: return type.get();
+        case 4: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssertionItemPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return local;
+        case 2: return direction;
+        case 3: return type.get();
+        case 4: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void AssertionItemPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: local = child.token(); return;
+        case 2: direction = child.token(); return;
+        case 3: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 4: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssertionItemPortSyntax* AssertionItemPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssertionItemPortSyntax>(*this);
+}
+
+bool AssignmentPatternExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssignmentPatternExpression;
+}
+
+TokenOrSyntax AssignmentPatternExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return type;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssignmentPatternExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return type;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void AssignmentPatternExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 1: pattern = &child.node()->as<AssignmentPatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssignmentPatternExpressionSyntax* AssignmentPatternExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssignmentPatternExpressionSyntax>(*this);
+}
+
+bool AssignmentPatternItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AssignmentPatternItem;
+}
+
+TokenOrSyntax AssignmentPatternItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return key.get();
+        case 1: return colon;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AssignmentPatternItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return key.get();
+        case 1: return colon;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void AssignmentPatternItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: key = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AssignmentPatternItemSyntax* AssignmentPatternItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AssignmentPatternItemSyntax>(*this);
+}
+
+bool AssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ReplicatedAssignmentPattern:
+        case SyntaxKind::SimpleAssignmentPattern:
+        case SyntaxKind::StructuredAssignmentPattern:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool AttributeInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AttributeInstance;
+}
+
+TokenOrSyntax AttributeInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &specs;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AttributeInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &specs;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void AttributeInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: specs = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AttributeInstanceSyntax* AttributeInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AttributeInstanceSyntax>(*this);
+}
+
+bool AttributeSpecSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::AttributeSpec;
+}
+
+TokenOrSyntax AttributeSpecSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax AttributeSpecSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+void AttributeSpecSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: value = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+AttributeSpecSyntax* AttributeSpecSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<AttributeSpecSyntax>(*this);
+}
+
+bool BadExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BadExpression;
+}
+
+TokenOrSyntax BadExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BadExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void BadExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BadExpressionSyntax* BadExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BadExpressionSyntax>(*this);
+}
+
+bool BeginKeywordsDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BeginKeywordsDirective;
+}
+
+TokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return versionSpecifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return versionSpecifier;
+        default: return nullptr;
+    }
+}
+
+void BeginKeywordsDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: versionSpecifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BeginKeywordsDirectiveSyntax* BeginKeywordsDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BeginKeywordsDirectiveSyntax>(*this);
+}
+
+bool BinaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BinaryBlockEventExpression;
+}
+
+TokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return orKeyword;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return orKeyword;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryBlockEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        case 1: orKeyword = child.token(); return;
+        case 2: right = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryBlockEventExpressionSyntax* BinaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryBlockEventExpressionSyntax>(*this);
+}
+
+bool BinaryEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BinaryEventExpression;
+}
+
+TokenOrSyntax BinaryEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<EventExpressionSyntax>(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: right = &child.node()->as<EventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryEventExpressionSyntax* BinaryEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryEventExpressionSyntax>(*this);
+}
+
+bool BinaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AddAssignmentExpression:
+        case SyntaxKind::AddExpression:
+        case SyntaxKind::AndAssignmentExpression:
+        case SyntaxKind::AndSequenceExpression:
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticShiftLeftExpression:
+        case SyntaxKind::ArithmeticShiftRightExpression:
+        case SyntaxKind::AssignmentExpression:
+        case SyntaxKind::BinaryAndExpression:
+        case SyntaxKind::BinaryOrExpression:
+        case SyntaxKind::BinarySequenceDelayExpression:
+        case SyntaxKind::BinaryXnorExpression:
+        case SyntaxKind::BinaryXorExpression:
+        case SyntaxKind::CaseEqualityExpression:
+        case SyntaxKind::CaseInequalityExpression:
+        case SyntaxKind::DivideAssignmentExpression:
+        case SyntaxKind::DivideExpression:
+        case SyntaxKind::EqualityExpression:
+        case SyntaxKind::GreaterThanEqualExpression:
+        case SyntaxKind::GreaterThanExpression:
+        case SyntaxKind::IffPropertyExpression:
+        case SyntaxKind::ImpliesPropertyExpression:
+        case SyntaxKind::InequalityExpression:
+        case SyntaxKind::IntersectSequenceExpression:
+        case SyntaxKind::LessThanEqualExpression:
+        case SyntaxKind::LessThanExpression:
+        case SyntaxKind::LogicalAndExpression:
+        case SyntaxKind::LogicalEquivalenceExpression:
+        case SyntaxKind::LogicalImplicationExpression:
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
+        case SyntaxKind::LogicalOrExpression:
+        case SyntaxKind::LogicalRightShiftAssignmentExpression:
+        case SyntaxKind::LogicalShiftLeftExpression:
+        case SyntaxKind::LogicalShiftRightExpression:
+        case SyntaxKind::ModAssignmentExpression:
+        case SyntaxKind::ModExpression:
+        case SyntaxKind::MultiplyAssignmentExpression:
+        case SyntaxKind::MultiplyExpression:
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
+        case SyntaxKind::NonblockingAssignmentExpression:
+        case SyntaxKind::OrAssignmentExpression:
+        case SyntaxKind::OrSequenceExpression:
+        case SyntaxKind::OverlappedFollowedByPropertyExpression:
+        case SyntaxKind::OverlappedImplicationPropertyExpression:
+        case SyntaxKind::PowerExpression:
+        case SyntaxKind::SUntilPropertyExpression:
+        case SyntaxKind::SUntilWithPropertyExpression:
+        case SyntaxKind::SubtractAssignmentExpression:
+        case SyntaxKind::SubtractExpression:
+        case SyntaxKind::ThroughoutSequenceExpression:
+        case SyntaxKind::UntilPropertyExpression:
+        case SyntaxKind::UntilWithPropertyExpression:
+        case SyntaxKind::WildcardEqualityExpression:
+        case SyntaxKind::WildcardInequalityExpression:
+        case SyntaxKind::WithinSequenceExpression:
+        case SyntaxKind::XorAssignmentExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax BinaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return &attributes;
+        case 3: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BinaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return operatorToken;
+        case 2: return &attributes;
+        case 3: return right.get();
+        default: return nullptr;
+    }
+}
+
+void BinaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 3: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BinaryExpressionSyntax* BinaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BinaryExpressionSyntax>(*this);
+}
+
+bool BitSelectSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BitSelect;
+}
+
+TokenOrSyntax BitSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BitSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void BitSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BitSelectSyntax* BitSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BitSelectSyntax>(*this);
+}
+
+bool BlockCoverageEventSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::BlockCoverageEvent;
+}
+
+TokenOrSyntax BlockCoverageEventSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return atat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BlockCoverageEventSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return atat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void BlockCoverageEventSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: atat = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<BlockEventExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BlockCoverageEventSyntax* BlockCoverageEventSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BlockCoverageEventSyntax>(*this);
+}
+
+bool BlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BinaryBlockEventExpression:
+        case SyntaxKind::PrimaryBlockEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool BlockStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ParallelBlockStatement:
+        case SyntaxKind::SequentialBlockStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax BlockStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return begin;
+        case 3: return blockName;
+        case 4: return &items;
+        case 5: return end;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax BlockStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return begin;
+        case 3: return blockName;
+        case 4: return &items;
+        case 5: return end;
+        case 6: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void BlockStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: begin = child.token(); return;
+        case 3: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        case 4: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
+        case 5: end = child.token(); return;
+        case 6: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+BlockStatementSyntax* BlockStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<BlockStatementSyntax>(*this);
+}
+
+bool CaseGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CaseGenerate;
+}
+
+TokenOrSyntax CaseGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return &items;
+        case 6: return endCase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CaseGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return &items;
+        case 6: return endCase;
+        default: return nullptr;
+    }
+}
+
+void CaseGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
+        case 6: endCase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CaseGenerateSyntax* CaseGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CaseGenerateSyntax>(*this);
+}
+
+bool CaseItemSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultCaseItem:
+        case SyntaxKind::PatternCaseItem:
+        case SyntaxKind::StandardCaseItem:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool CaseStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CaseStatement;
+}
+
+TokenOrSyntax CaseStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return caseKeyword;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return matchesOrInside;
+        case 8: return &items;
+        case 9: return endcase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CaseStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return caseKeyword;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return matchesOrInside;
+        case 8: return &items;
+        case 9: return endcase;
+        default: return nullptr;
+    }
+}
+
+void CaseStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: uniqueOrPriority = child.token(); return;
+        case 3: caseKeyword = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: matchesOrInside = child.token(); return;
+        case 8: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
+        case 9: endcase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CaseStatementSyntax* CaseStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CaseStatementSyntax>(*this);
+}
+
+bool CastExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CastExpression;
+}
+
+TokenOrSyntax CastExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return apostrophe;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CastExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return apostrophe;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void CastExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: apostrophe = child.token(); return;
+        case 2: right = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CastExpressionSyntax* CastExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CastExpressionSyntax>(*this);
+}
+
+bool ChargeStrengthSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ChargeStrength;
+}
+
+TokenOrSyntax ChargeStrengthSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ChargeStrengthSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ChargeStrengthSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: strength = child.token(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ChargeStrengthSyntax* ChargeStrengthSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ChargeStrengthSyntax>(*this);
+}
+
+bool ClassDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassDeclaration;
+}
+
+TokenOrSyntax ClassDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return virtualOrInterface;
+        case 2: return classKeyword;
+        case 3: return lifetime;
+        case 4: return name;
+        case 5: return parameters;
+        case 6: return extendsClause;
+        case 7: return implementsClause;
+        case 8: return semi;
+        case 9: return &items;
+        case 10: return endClass;
+        case 11: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return virtualOrInterface;
+        case 2: return classKeyword;
+        case 3: return lifetime;
+        case 4: return name;
+        case 5: return parameters;
+        case 6: return extendsClause;
+        case 7: return implementsClause;
+        case 8: return semi;
+        case 9: return &items;
+        case 10: return endClass;
+        case 11: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void ClassDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: virtualOrInterface = child.token(); return;
+        case 2: classKeyword = child.token(); return;
+        case 3: lifetime = child.token(); return;
+        case 4: name = child.token(); return;
+        case 5: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
+        case 6: extendsClause = &child.node()->as<ExtendsClauseSyntax>(); return;
+        case 7: implementsClause = &child.node()->as<ImplementsClauseSyntax>(); return;
+        case 8: semi = child.token(); return;
+        case 9: items = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 10: endClass = child.token(); return;
+        case 11: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassDeclarationSyntax* ClassDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassDeclarationSyntax>(*this);
+}
+
+bool ClassMethodDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassMethodDeclaration;
+}
+
+TokenOrSyntax ClassMethodDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassMethodDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+void ClassMethodDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: declaration = &child.node()->as<FunctionDeclarationSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassMethodDeclarationSyntax* ClassMethodDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassMethodDeclarationSyntax>(*this);
+}
+
+bool ClassMethodPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassMethodPrototype;
+}
+
+TokenOrSyntax ClassMethodPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return prototype.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassMethodPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return prototype.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ClassMethodPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassMethodPrototypeSyntax* ClassMethodPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassMethodPrototypeSyntax>(*this);
+}
+
+bool ClassNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassName;
+}
+
+TokenOrSyntax ClassNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return parameters.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return parameters.get();
+        default: return nullptr;
+    }
+}
+
+void ClassNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        case 1: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassNameSyntax* ClassNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassNameSyntax>(*this);
+}
+
+bool ClassPropertyDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassPropertyDeclaration;
+}
+
+TokenOrSyntax ClassPropertyDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassPropertyDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return declaration.get();
+        default: return nullptr;
+    }
+}
+
+void ClassPropertyDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: declaration = &child.node()->as<MemberSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassPropertyDeclarationSyntax* ClassPropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassPropertyDeclarationSyntax>(*this);
+}
+
+bool ClassScopeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClassScope;
+}
+
+TokenOrSyntax ClassScopeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClassScopeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        default: return nullptr;
+    }
+}
+
+void ClassScopeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<NameSyntax>(); return;
+        case 1: separator = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClassScopeSyntax* ClassScopeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClassScopeSyntax>(*this);
+}
+
+bool ClockingDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingDeclaration;
+}
+
+TokenOrSyntax ClockingDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return globalOrDefault;
+        case 2: return clocking;
+        case 3: return blockName;
+        case 4: return at;
+        case 5: return event;
+        case 6: return eventIdentifier;
+        case 7: return semi;
+        case 8: return &items;
+        case 9: return endClocking;
+        case 10: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return globalOrDefault;
+        case 2: return clocking;
+        case 3: return blockName;
+        case 4: return at;
+        case 5: return event;
+        case 6: return eventIdentifier;
+        case 7: return semi;
+        case 8: return &items;
+        case 9: return endClocking;
+        case 10: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void ClockingDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: globalOrDefault = child.token(); return;
+        case 2: clocking = child.token(); return;
+        case 3: blockName = child.token(); return;
+        case 4: at = child.token(); return;
+        case 5: event = &child.node()->as<ParenthesizedEventExpressionSyntax>(); return;
+        case 6: eventIdentifier = child.token(); return;
+        case 7: semi = child.token(); return;
+        case 8: items = child.node()->as<SyntaxList<ClockingItemSyntax>>(); return;
+        case 9: endClocking = child.token(); return;
+        case 10: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingDeclarationSyntax* ClockingDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingDeclarationSyntax>(*this);
+}
+
+bool ClockingDirectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingDirection;
+}
+
+TokenOrSyntax ClockingDirectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return input;
+        case 1: return inputSkew;
+        case 2: return output;
+        case 3: return ouputSkew;
+        case 4: return inout;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingDirectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return input;
+        case 1: return inputSkew;
+        case 2: return output;
+        case 3: return ouputSkew;
+        case 4: return inout;
+        default: return nullptr;
+    }
+}
+
+void ClockingDirectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: input = child.token(); return;
+        case 1: inputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
+        case 2: output = child.token(); return;
+        case 3: ouputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
+        case 4: inout = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingDirectionSyntax* ClockingDirectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingDirectionSyntax>(*this);
+}
+
+bool ClockingItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingItem;
+}
+
+TokenOrSyntax ClockingItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return direction;
+        case 2: return &assignments;
+        case 3: return semi;
+        case 4: return declaration;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return direction;
+        case 2: return &assignments;
+        case 3: return semi;
+        case 4: return declaration;
+        default: return nullptr;
+    }
+}
+
+void ClockingItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: defaultKeyword = child.token(); return;
+        case 1: direction = &child.node()->as<ClockingDirectionSyntax>(); return;
+        case 2: assignments = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        case 4: declaration = &child.node()->as<MemberSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingItemSyntax* ClockingItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingItemSyntax>(*this);
+}
+
+bool ClockingSkewSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ClockingSkew;
+}
+
+TokenOrSyntax ClockingSkewSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return edge;
+        case 1: return hash;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ClockingSkewSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return edge;
+        case 1: return hash;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+void ClockingSkewSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: edge = child.token(); return;
+        case 1: hash = child.token(); return;
+        case 2: value = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ClockingSkewSyntax* ClockingSkewSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ClockingSkewSyntax>(*this);
+}
+
+bool ColonExpressionClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ColonExpressionClause;
+}
+
+TokenOrSyntax ColonExpressionClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return colon;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ColonExpressionClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return colon;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void ColonExpressionClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: colon = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ColonExpressionClauseSyntax* ColonExpressionClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ColonExpressionClauseSyntax>(*this);
+}
+
+bool CompilationUnitSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CompilationUnit;
+}
+
+TokenOrSyntax CompilationUnitSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &members;
+        case 1: return endOfFile;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CompilationUnitSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &members;
+        case 1: return endOfFile;
+        default: return nullptr;
+    }
+}
+
+void CompilationUnitSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 1: endOfFile = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CompilationUnitSyntax* CompilationUnitSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CompilationUnitSyntax>(*this);
+}
+
+bool ConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConcatenationExpression;
+}
+
+TokenOrSyntax ConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &expressions;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &expressions;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcatenationExpressionSyntax* ConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcatenationExpressionSyntax>(*this);
+}
+
+bool ConcurrentAssertionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConcurrentAssertionMember;
+}
+
+TokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ConcurrentAssertionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: statement = &child.node()->as<ConcurrentAssertionStatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcurrentAssertionMemberSyntax* ConcurrentAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcurrentAssertionMemberSyntax>(*this);
+}
+
+bool ConcurrentAssertionStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssertPropertyStatement:
+        case SyntaxKind::AssumePropertyStatement:
+        case SyntaxKind::CoverPropertyStatement:
+        case SyntaxKind::CoverSequenceStatement:
+        case SyntaxKind::ExpectPropertyStatement:
+        case SyntaxKind::RestrictPropertyStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return propertyOrSequence;
+        case 4: return openParen;
+        case 5: return propertySpec.get();
+        case 6: return closeParen;
+        case 7: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return propertyOrSequence;
+        case 4: return openParen;
+        case 5: return propertySpec.get();
+        case 6: return closeParen;
+        case 7: return action.get();
+        default: return nullptr;
+    }
+}
+
+void ConcurrentAssertionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: propertyOrSequence = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConcurrentAssertionStatementSyntax* ConcurrentAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConcurrentAssertionStatementSyntax>(*this);
+}
+
+bool ConditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ElsIfDirective:
+        case SyntaxKind::IfDefDirective:
+        case SyntaxKind::IfNDefDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+void ConditionalBranchDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: disabledTokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalBranchDirectiveSyntax* ConditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalBranchDirectiveSyntax>(*this);
+}
+
+bool ConditionalConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalConstraint;
+}
+
+TokenOrSyntax ConditionalConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return ifKeyword;
+        case 1: return openParen;
+        case 2: return condition.get();
+        case 3: return closeParen;
+        case 4: return constraints.get();
+        case 5: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return ifKeyword;
+        case 1: return openParen;
+        case 2: return condition.get();
+        case 3: return closeParen;
+        case 4: return constraints.get();
+        case 5: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: ifKeyword = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        case 4: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        case 5: elseClause = &child.node()->as<ElseConstraintClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalConstraintSyntax* ConditionalConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalConstraintSyntax>(*this);
+}
+
+bool ConditionalExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalExpression;
+}
+
+TokenOrSyntax ConditionalExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return predicate.get();
+        case 1: return question;
+        case 2: return &attributes;
+        case 3: return left.get();
+        case 4: return colon;
+        case 5: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return predicate.get();
+        case 1: return question;
+        case 2: return &attributes;
+        case 3: return left.get();
+        case 4: return colon;
+        case 5: return right.get();
+        default: return nullptr;
+    }
+}
+
+void ConditionalExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
+        case 1: question = child.token(); return;
+        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 3: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: colon = child.token(); return;
+        case 5: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalExpressionSyntax* ConditionalExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalExpressionSyntax>(*this);
+}
+
+bool ConditionalPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalPattern;
+}
+
+TokenOrSyntax ConditionalPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return matchesClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return matchesClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: matchesClause = &child.node()->as<MatchesClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalPatternSyntax* ConditionalPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalPatternSyntax>(*this);
+}
+
+bool ConditionalPredicateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalPredicate;
+}
+
+TokenOrSyntax ConditionalPredicateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &conditions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalPredicateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &conditions;
+        default: return nullptr;
+    }
+}
+
+void ConditionalPredicateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: conditions = child.node()->as<SeparatedSyntaxList<ConditionalPatternSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalPredicateSyntax* ConditionalPredicateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalPredicateSyntax>(*this);
+}
+
+bool ConditionalStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConditionalStatement;
+}
+
+TokenOrSyntax ConditionalStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return ifKeyword;
+        case 4: return openParen;
+        case 5: return predicate.get();
+        case 6: return closeParen;
+        case 7: return statement.get();
+        case 8: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConditionalStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return uniqueOrPriority;
+        case 3: return ifKeyword;
+        case 4: return openParen;
+        case 5: return predicate.get();
+        case 6: return closeParen;
+        case 7: return statement.get();
+        case 8: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void ConditionalStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: uniqueOrPriority = child.token(); return;
+        case 3: ifKeyword = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: statement = &child.node()->as<StatementSyntax>(); return;
+        case 8: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConditionalStatementSyntax* ConditionalStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConditionalStatementSyntax>(*this);
+}
+
+bool ConstraintBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintBlock;
+}
+
+TokenOrSyntax ConstraintBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ConstraintBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SyntaxList<ConstraintItemSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintBlockSyntax* ConstraintBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintBlockSyntax>(*this);
+}
+
+bool ConstraintDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintDeclaration;
+}
+
+TokenOrSyntax ConstraintDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return block.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return block.get();
+        default: return nullptr;
+    }
+}
+
+void ConstraintDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: block = &child.node()->as<ConstraintBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintDeclarationSyntax* ConstraintDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintDeclarationSyntax>(*this);
+}
+
+bool ConstraintItemSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ConditionalConstraint:
+        case SyntaxKind::ConstraintBlock:
+        case SyntaxKind::DisableConstraint:
+        case SyntaxKind::ExpressionConstraint:
+        case SyntaxKind::ImplicationConstraint:
+        case SyntaxKind::LoopConstraint:
+        case SyntaxKind::SolveBeforeConstraint:
+        case SyntaxKind::UniquenessConstraint:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ConstraintPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ConstraintPrototype;
+}
+
+TokenOrSyntax ConstraintPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ConstraintPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ConstraintPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ConstraintPrototypeSyntax* ConstraintPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ConstraintPrototypeSyntax>(*this);
+}
+
+bool ContinuousAssignSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ContinuousAssign;
+}
+
+TokenOrSyntax ContinuousAssignSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return assign;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &assignments;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ContinuousAssignSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return assign;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &assignments;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void ContinuousAssignSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: assign = child.token(); return;
+        case 2: strength = &child.node()->as<DriveStrengthSyntax>(); return;
+        case 3: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: assignments = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ContinuousAssignSyntax* ContinuousAssignSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ContinuousAssignSyntax>(*this);
+}
+
+bool CoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultCoverageBinInitializer:
+        case SyntaxKind::ExpressionCoverageBinInitializer:
+        case SyntaxKind::RangeCoverageBinInitializer:
+        case SyntaxKind::TransListCoverageBinInitializer:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool CoverageBinsSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CoverageBins;
+}
+
+TokenOrSyntax CoverageBinsSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return wildcard;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return selector;
+        case 5: return equals;
+        case 6: return initializer.get();
+        case 7: return iff;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverageBinsSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return wildcard;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return selector;
+        case 5: return equals;
+        case 6: return initializer.get();
+        case 7: return iff;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+void CoverageBinsSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: wildcard = child.token(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: selector = &child.node()->as<ElementSelectSyntax>(); return;
+        case 5: equals = child.token(); return;
+        case 6: initializer = &child.node()->as<CoverageBinInitializerSyntax>(); return;
+        case 7: iff = &child.node()->as<IffClauseSyntax>(); return;
+        case 8: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverageBinsSyntax* CoverageBinsSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverageBinsSyntax>(*this);
+}
+
+bool CoverageOptionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CoverageOption;
+}
+
+TokenOrSyntax CoverageOptionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return option;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return equals;
+        case 5: return expr.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverageOptionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return option;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return equals;
+        case 5: return expr.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void CoverageOptionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: option = child.token(); return;
+        case 2: dot = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: equals = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverageOptionSyntax* CoverageOptionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverageOptionSyntax>(*this);
+}
+
+bool CovergroupDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::CovergroupDeclaration;
+}
+
+TokenOrSyntax CovergroupDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return covergroup;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return event;
+        case 5: return semi;
+        case 6: return &members;
+        case 7: return endgroup;
+        case 8: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CovergroupDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return covergroup;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return event;
+        case 5: return semi;
+        case 6: return &members;
+        case 7: return endgroup;
+        case 8: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void CovergroupDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: covergroup = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
+        case 4: event = &child.node()->as<SyntaxNode>(); return;
+        case 5: semi = child.token(); return;
+        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 7: endgroup = child.token(); return;
+        case 8: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CovergroupDeclarationSyntax* CovergroupDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CovergroupDeclarationSyntax>(*this);
+}
+
+bool CoverpointSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Coverpoint;
+}
+
+TokenOrSyntax CoverpointSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return label;
+        case 3: return coverpoint;
+        case 4: return expr.get();
+        case 5: return openBrace;
+        case 6: return &members;
+        case 7: return closeBrace;
+        case 8: return emptySemi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax CoverpointSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return label;
+        case 3: return coverpoint;
+        case 4: return expr.get();
+        case 5: return openBrace;
+        case 6: return &members;
+        case 7: return closeBrace;
+        case 8: return emptySemi;
+        default: return nullptr;
+    }
+}
+
+void CoverpointSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 3: coverpoint = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: openBrace = child.token(); return;
+        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 7: closeBrace = child.token(); return;
+        case 8: emptySemi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+CoverpointSyntax* CoverpointSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<CoverpointSyntax>(*this);
+}
+
+bool DPIImportExportSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DPIImportExport;
+}
+
+TokenOrSyntax DPIImportExportSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return stringLiteral;
+        case 3: return property;
+        case 4: return c_identifier;
+        case 5: return equals;
+        case 6: return method.get();
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DPIImportExportSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return stringLiteral;
+        case 3: return property;
+        case 4: return c_identifier;
+        case 5: return equals;
+        case 6: return method.get();
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void DPIImportExportSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: stringLiteral = child.token(); return;
+        case 3: property = child.token(); return;
+        case 4: c_identifier = child.token(); return;
+        case 5: equals = child.token(); return;
+        case 6: method = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DPIImportExportSyntax* DPIImportExportSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DPIImportExportSyntax>(*this);
+}
+
+bool DataDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DataDeclaration;
+}
+
+TokenOrSyntax DataDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &modifiers;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DataDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &modifiers;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DataDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: modifiers = child.node()->as<TokenList>(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DataDeclarationSyntax* DataDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DataDeclarationSyntax>(*this);
+}
+
+bool DataTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::EnumType:
+        case SyntaxKind::EventType:
+        case SyntaxKind::ImplicitType:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::NamedType:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::StringType:
+        case SyntaxKind::StructType:
+        case SyntaxKind::TimeType:
+        case SyntaxKind::TypeReference:
+        case SyntaxKind::UnionType:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VirtualInterfaceType:
+        case SyntaxKind::VoidType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool DeclaratorSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Declarator;
+}
+
+TokenOrSyntax DeclaratorSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return initializer;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DeclaratorSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return initializer;
+        default: return nullptr;
+    }
+}
+
+void DeclaratorSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 2: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DeclaratorSyntax* DeclaratorSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DeclaratorSyntax>(*this);
+}
+
+bool DefParamAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefParamAssignment;
+}
+
+TokenOrSyntax DefParamAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name.get();
+        case 1: return setter;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefParamAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name.get();
+        case 1: return setter;
+        default: return nullptr;
+    }
+}
+
+void DefParamAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = &child.node()->as<NameSyntax>(); return;
+        case 1: setter = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefParamAssignmentSyntax* DefParamAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefParamAssignmentSyntax>(*this);
+}
+
+bool DefParamSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefParam;
+}
+
+TokenOrSyntax DefParamSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defparam;
+        case 2: return &assignments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefParamSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return defparam;
+        case 2: return &assignments;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void DefParamSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: defparam = child.token(); return;
+        case 2: assignments = child.node()->as<SeparatedSyntaxList<DefParamAssignmentSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefParamSyntax* DefParamSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefParamSyntax>(*this);
+}
+
+bool DefaultCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultCaseItem;
+}
+
+TokenOrSyntax DefaultCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void DefaultCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: defaultKeyword = child.token(); return;
+        case 1: colon = child.token(); return;
+        case 2: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultCaseItemSyntax* DefaultCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultCaseItemSyntax>(*this);
+}
+
+bool DefaultCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultCoverageBinInitializer;
+}
+
+TokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return sequenceKeyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return defaultKeyword;
+        case 1: return sequenceKeyword;
+        default: return nullptr;
+    }
+}
+
+void DefaultCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: defaultKeyword = child.token(); return;
+        case 1: sequenceKeyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultCoverageBinInitializerSyntax* DefaultCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultCoverageBinInitializerSyntax>(*this);
+}
+
+bool DefaultNetTypeDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefaultNetTypeDirective;
+}
+
+TokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return netType;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return netType;
+        default: return nullptr;
+    }
+}
+
+void DefaultNetTypeDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: netType = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefaultNetTypeDirectiveSyntax* DefaultNetTypeDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefaultNetTypeDirectiveSyntax>(*this);
+}
+
+bool DeferredAssertionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DeferredAssertion;
+}
+
+TokenOrSyntax DeferredAssertionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return zero;
+        case 2: return finalKeyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DeferredAssertionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return zero;
+        case 2: return finalKeyword;
+        default: return nullptr;
+    }
+}
+
+void DeferredAssertionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: zero = child.token(); return;
+        case 2: finalKeyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DeferredAssertionSyntax* DeferredAssertionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DeferredAssertionSyntax>(*this);
+}
+
+bool DefineDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DefineDirective;
+}
+
+TokenOrSyntax DefineDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return formalArguments;
+        case 3: return &body;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DefineDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return formalArguments;
+        case 3: return &body;
+        default: return nullptr;
+    }
+}
+
+void DefineDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: formalArguments = &child.node()->as<MacroFormalArgumentListSyntax>(); return;
+        case 3: body = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DefineDirectiveSyntax* DefineDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DefineDirectiveSyntax>(*this);
+}
+
+bool Delay3Syntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::Delay3;
+}
+
+TokenOrSyntax Delay3Syntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return delay1.get();
+        case 3: return comma1;
+        case 4: return delay2;
+        case 5: return comma2;
+        case 6: return delay3;
+        case 7: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax Delay3Syntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return delay1.get();
+        case 3: return comma1;
+        case 4: return delay2;
+        case 5: return comma2;
+        case 6: return delay3;
+        case 7: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void Delay3Syntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: delay1 = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: comma1 = child.token(); return;
+        case 4: delay2 = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: comma2 = child.token(); return;
+        case 6: delay3 = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+Delay3Syntax* Delay3Syntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<Delay3Syntax>(*this);
+}
+
+bool DelaySyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CycleDelay:
+        case SyntaxKind::DelayControl:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax DelaySyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return delayValue.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DelaySyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return delayValue.get();
+        default: return nullptr;
+    }
+}
+
+void DelaySyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: delayValue = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DelaySyntax* DelaySyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DelaySyntax>(*this);
+}
+
+bool DimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::QueueDimensionSpecifier:
+        case SyntaxKind::RangeDimensionSpecifier:
+        case SyntaxKind::WildcardDimensionSpecifier:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool DirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BeginKeywordsDirective:
+        case SyntaxKind::CellDefineDirective:
+        case SyntaxKind::DefaultNetTypeDirective:
+        case SyntaxKind::DefineDirective:
+        case SyntaxKind::ElsIfDirective:
+        case SyntaxKind::ElseDirective:
+        case SyntaxKind::EndCellDefineDirective:
+        case SyntaxKind::EndIfDirective:
+        case SyntaxKind::EndKeywordsDirective:
+        case SyntaxKind::IfDefDirective:
+        case SyntaxKind::IfNDefDirective:
+        case SyntaxKind::IncludeDirective:
+        case SyntaxKind::LineDirective:
+        case SyntaxKind::MacroUsage:
+        case SyntaxKind::NoUnconnectedDriveDirective:
+        case SyntaxKind::PragmaDirective:
+        case SyntaxKind::ResetAllDirective:
+        case SyntaxKind::TimeScaleDirective:
+        case SyntaxKind::UnconnectedDriveDirective:
+        case SyntaxKind::UndefDirective:
+        case SyntaxKind::UndefineAllDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax DirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+void DirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DirectiveSyntax* DirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DirectiveSyntax>(*this);
+}
+
+bool DisableConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableConstraint;
+}
+
+TokenOrSyntax DisableConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return disable;
+        case 1: return soft;
+        case 2: return name.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return disable;
+        case 1: return soft;
+        case 2: return name.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: disable = child.token(); return;
+        case 1: soft = child.token(); return;
+        case 2: name = &child.node()->as<NameSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableConstraintSyntax* DisableConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableConstraintSyntax>(*this);
+}
+
+bool DisableForkStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableForkStatement;
+}
+
+TokenOrSyntax DisableForkStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableForkStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableForkStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: disable = child.token(); return;
+        case 3: fork = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableForkStatementSyntax* DisableForkStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableForkStatementSyntax>(*this);
+}
+
+bool DisableIffSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableIff;
+}
+
+TokenOrSyntax DisableIffSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return disable;
+        case 1: return iff;
+        case 2: return openParen;
+        case 3: return expr.get();
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableIffSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return disable;
+        case 1: return iff;
+        case 2: return openParen;
+        case 3: return expr.get();
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void DisableIffSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: disable = child.token(); return;
+        case 1: iff = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableIffSyntax* DisableIffSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableIffSyntax>(*this);
+}
+
+bool DisableStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DisableStatement;
+}
+
+TokenOrSyntax DisableStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DisableStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return disable;
+        case 3: return name.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void DisableStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: disable = child.token(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DisableStatementSyntax* DisableStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DisableStatementSyntax>(*this);
+}
+
+bool DistConstraintListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistConstraintList;
+}
+
+TokenOrSyntax DistConstraintListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dist;
+        case 1: return openBrace;
+        case 2: return &items;
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistConstraintListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dist;
+        case 1: return openBrace;
+        case 2: return &items;
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void DistConstraintListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dist = child.token(); return;
+        case 1: openBrace = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<DistItemSyntax>>(); return;
+        case 3: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistConstraintListSyntax* DistConstraintListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistConstraintListSyntax>(*this);
+}
+
+bool DistItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistItem;
+}
+
+TokenOrSyntax DistItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return range.get();
+        case 1: return weight;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return range.get();
+        case 1: return weight;
+        default: return nullptr;
+    }
+}
+
+void DistItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: range = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: weight = &child.node()->as<DistWeightSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistItemSyntax* DistItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistItemSyntax>(*this);
+}
+
+bool DistWeightSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DistWeight;
+}
+
+TokenOrSyntax DistWeightSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return op;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DistWeightSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return op;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void DistWeightSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: op = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DistWeightSyntax* DistWeightSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DistWeightSyntax>(*this);
+}
+
+bool DividerClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DividerClause;
+}
+
+TokenOrSyntax DividerClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return divide;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DividerClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return divide;
+        case 1: return value;
+        default: return nullptr;
+    }
+}
+
+void DividerClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: divide = child.token(); return;
+        case 1: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DividerClauseSyntax* DividerClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DividerClauseSyntax>(*this);
+}
+
+bool DoWhileStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DoWhileStatement;
+}
+
+TokenOrSyntax DoWhileStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return doKeyword;
+        case 3: return statement.get();
+        case 4: return whileKeyword;
+        case 5: return openParen;
+        case 6: return expr.get();
+        case 7: return closeParen;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DoWhileStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return doKeyword;
+        case 3: return statement.get();
+        case 4: return whileKeyword;
+        case 5: return openParen;
+        case 6: return expr.get();
+        case 7: return closeParen;
+        case 8: return semi;
+        default: return nullptr;
+    }
+}
+
+void DoWhileStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: doKeyword = child.token(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        case 4: whileKeyword = child.token(); return;
+        case 5: openParen = child.token(); return;
+        case 6: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: closeParen = child.token(); return;
+        case 8: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DoWhileStatementSyntax* DoWhileStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DoWhileStatementSyntax>(*this);
+}
+
+bool DotMemberClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DotMemberClause;
+}
+
+TokenOrSyntax DotMemberClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return member;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DotMemberClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return member;
+        default: return nullptr;
+    }
+}
+
+void DotMemberClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: member = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DotMemberClauseSyntax* DotMemberClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DotMemberClauseSyntax>(*this);
+}
+
+bool DriveStrengthSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::DriveStrength;
+}
+
+TokenOrSyntax DriveStrengthSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength0;
+        case 2: return comma;
+        case 3: return strength1;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax DriveStrengthSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return strength0;
+        case 2: return comma;
+        case 3: return strength1;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void DriveStrengthSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: strength0 = child.token(); return;
+        case 2: comma = child.token(); return;
+        case 3: strength1 = child.token(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+DriveStrengthSyntax* DriveStrengthSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<DriveStrengthSyntax>(*this);
+}
+
+bool ElementSelectExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElementSelectExpression;
+}
+
+TokenOrSyntax ElementSelectExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return select.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElementSelectExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return select.get();
+        default: return nullptr;
+    }
+}
+
+void ElementSelectExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: select = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElementSelectExpressionSyntax* ElementSelectExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElementSelectExpressionSyntax>(*this);
+}
+
+bool ElementSelectSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElementSelect;
+}
+
+TokenOrSyntax ElementSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return selector;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElementSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return selector;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void ElementSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: selector = &child.node()->as<SelectorSyntax>(); return;
+        case 2: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElementSelectSyntax* ElementSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElementSelectSyntax>(*this);
+}
+
+bool ElseClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElseClause;
+}
+
+TokenOrSyntax ElseClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElseClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void ElseClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: elseKeyword = child.token(); return;
+        case 1: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElseClauseSyntax* ElseClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElseClauseSyntax>(*this);
+}
+
+bool ElseConstraintClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ElseConstraintClause;
+}
+
+TokenOrSyntax ElseConstraintClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ElseConstraintClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return elseKeyword;
+        case 1: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void ElseConstraintClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: elseKeyword = child.token(); return;
+        case 1: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ElseConstraintClauseSyntax* ElseConstraintClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ElseConstraintClauseSyntax>(*this);
+}
+
+bool EmptyArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyArgument;
+}
+
+TokenOrSyntax EmptyArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyArgumentSyntax* EmptyArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyArgumentSyntax>(*this);
+}
+
+bool EmptyIdentifierNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyIdentifierName;
+}
+
+TokenOrSyntax EmptyIdentifierNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyIdentifierNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return placeholder;
+        default: return nullptr;
+    }
+}
+
+void EmptyIdentifierNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: placeholder = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyIdentifierNameSyntax* EmptyIdentifierNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyIdentifierNameSyntax>(*this);
+}
+
+bool EmptyMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyMember;
+}
+
+TokenOrSyntax EmptyMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return &qualifiers;
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void EmptyMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: qualifiers = child.node()->as<TokenList>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyMemberSyntax* EmptyMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyMemberSyntax>(*this);
+}
+
+bool EmptyQueueExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyQueueExpression;
+}
+
+TokenOrSyntax EmptyQueueExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyQueueExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void EmptyQueueExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyQueueExpressionSyntax* EmptyQueueExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyQueueExpressionSyntax>(*this);
+}
+
+bool EmptyStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EmptyStatement;
+}
+
+TokenOrSyntax EmptyStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return semicolon;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EmptyStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return semicolon;
+        default: return nullptr;
+    }
+}
+
+void EmptyStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: semicolon = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EmptyStatementSyntax* EmptyStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EmptyStatementSyntax>(*this);
+}
+
+bool EnumTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EnumType;
+}
+
+TokenOrSyntax EnumTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseType;
+        case 2: return openBrace;
+        case 3: return &members;
+        case 4: return closeBrace;
+        case 5: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EnumTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseType;
+        case 2: return openBrace;
+        case 3: return &members;
+        case 4: return closeBrace;
+        case 5: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void EnumTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: baseType = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: openBrace = child.token(); return;
+        case 3: members = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: closeBrace = child.token(); return;
+        case 5: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EnumTypeSyntax* EnumTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EnumTypeSyntax>(*this);
+}
+
+bool EqualsTypeClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EqualsTypeClause;
+}
+
+TokenOrSyntax EqualsTypeClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return type.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EqualsTypeClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return type.get();
+        default: return nullptr;
+    }
+}
+
+void EqualsTypeClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EqualsTypeClauseSyntax* EqualsTypeClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EqualsTypeClauseSyntax>(*this);
+}
+
+bool EqualsValueClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EqualsValueClause;
+}
+
+TokenOrSyntax EqualsValueClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EqualsValueClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void EqualsValueClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EqualsValueClauseSyntax* EqualsValueClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EqualsValueClauseSyntax>(*this);
+}
+
+bool EventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EventControl;
+}
+
+TokenOrSyntax EventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return eventName.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return eventName.get();
+        default: return nullptr;
+    }
+}
+
+void EventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: eventName = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventControlSyntax* EventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventControlSyntax>(*this);
+}
+
+bool EventControlWithExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::EventControlWithExpression;
+}
+
+TokenOrSyntax EventControlWithExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventControlWithExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void EventControlWithExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventControlWithExpressionSyntax* EventControlWithExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventControlWithExpressionSyntax>(*this);
+}
+
+bool EventExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BinaryEventExpression:
+        case SyntaxKind::ParenthesizedEventExpression:
+        case SyntaxKind::SignalEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool EventTriggerStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BlockingEventTriggerStatement:
+        case SyntaxKind::NonblockingEventTriggerStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax EventTriggerStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return trigger;
+        case 3: return timing;
+        case 4: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax EventTriggerStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return trigger;
+        case 3: return timing;
+        case 4: return name.get();
+        default: return nullptr;
+    }
+}
+
+void EventTriggerStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: trigger = child.token(); return;
+        case 3: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+EventTriggerStatementSyntax* EventTriggerStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<EventTriggerStatementSyntax>(*this);
+}
+
+bool ExplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExplicitAnsiPort;
+}
+
+TokenOrSyntax ExplicitAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return openParen;
+        case 5: return expr;
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExplicitAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return dot;
+        case 3: return name;
+        case 4: return openParen;
+        case 5: return expr;
+        case 6: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ExplicitAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: direction = child.token(); return;
+        case 2: dot = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExplicitAnsiPortSyntax* ExplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExplicitAnsiPortSyntax>(*this);
+}
+
+bool ExplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExplicitNonAnsiPort;
+}
+
+TokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ExplicitNonAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<PortExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExplicitNonAnsiPortSyntax* ExplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExplicitNonAnsiPortSyntax>(*this);
+}
+
+bool ExpressionConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionConstraint;
+}
+
+TokenOrSyntax ExpressionConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return soft;
+        case 1: return expr.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return soft;
+        case 1: return expr.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void ExpressionConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: soft = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionConstraintSyntax* ExpressionConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionConstraintSyntax>(*this);
+}
+
+bool ExpressionCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionCoverageBinInitializer;
+}
+
+TokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void ExpressionCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionCoverageBinInitializerSyntax* ExpressionCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionCoverageBinInitializerSyntax>(*this);
+}
+
+bool ExpressionOrDistSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionOrDist;
+}
+
+TokenOrSyntax ExpressionOrDistSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return distribution.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionOrDistSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return distribution.get();
+        default: return nullptr;
+    }
+}
+
+void ExpressionOrDistSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: distribution = &child.node()->as<DistConstraintListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionOrDistSyntax* ExpressionOrDistSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionOrDistSyntax>(*this);
+}
+
+bool ExpressionPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionPattern;
+}
+
+TokenOrSyntax ExpressionPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void ExpressionPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionPatternSyntax* ExpressionPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionPatternSyntax>(*this);
+}
+
+bool ExpressionStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExpressionStatement;
+}
+
+TokenOrSyntax ExpressionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return expr.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExpressionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return expr.get();
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ExpressionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExpressionStatementSyntax* ExpressionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExpressionStatementSyntax>(*this);
+}
+
+bool ExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression:
+        case SyntaxKind::AddAssignmentExpression:
+        case SyntaxKind::AddExpression:
+        case SyntaxKind::AlwaysPropertyExpression:
+        case SyntaxKind::AndAssignmentExpression:
+        case SyntaxKind::AndSequenceExpression:
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
+        case SyntaxKind::ArithmeticShiftLeftExpression:
+        case SyntaxKind::ArithmeticShiftRightExpression:
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayOrRandomizeMethodExpression:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::AssignmentExpression:
+        case SyntaxKind::AssignmentPatternExpression:
+        case SyntaxKind::BadExpression:
+        case SyntaxKind::BinaryAndExpression:
+        case SyntaxKind::BinaryOrExpression:
+        case SyntaxKind::BinarySequenceDelayExpression:
+        case SyntaxKind::BinaryXnorExpression:
+        case SyntaxKind::BinaryXorExpression:
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::CaseEqualityExpression:
+        case SyntaxKind::CaseInequalityExpression:
+        case SyntaxKind::CastExpression:
+        case SyntaxKind::ClassName:
+        case SyntaxKind::ClassScope:
+        case SyntaxKind::ConcatenationExpression:
+        case SyntaxKind::ConditionalExpression:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::DivideAssignmentExpression:
+        case SyntaxKind::DivideExpression:
+        case SyntaxKind::ElementSelectExpression:
+        case SyntaxKind::EmptyIdentifierName:
+        case SyntaxKind::EmptyQueueExpression:
+        case SyntaxKind::EnumType:
+        case SyntaxKind::EqualityExpression:
+        case SyntaxKind::EventType:
+        case SyntaxKind::EventuallyPropertyExpression:
+        case SyntaxKind::ExpressionOrDist:
+        case SyntaxKind::GreaterThanEqualExpression:
+        case SyntaxKind::GreaterThanExpression:
+        case SyntaxKind::IdentifierName:
+        case SyntaxKind::IdentifierSelectName:
+        case SyntaxKind::IffPropertyExpression:
+        case SyntaxKind::ImplicitType:
+        case SyntaxKind::ImpliesPropertyExpression:
+        case SyntaxKind::InequalityExpression:
+        case SyntaxKind::InsideExpression:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::IntegerVectorExpression:
+        case SyntaxKind::IntersectSequenceExpression:
+        case SyntaxKind::InvocationExpression:
+        case SyntaxKind::LessThanEqualExpression:
+        case SyntaxKind::LessThanExpression:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LogicalAndExpression:
+        case SyntaxKind::LogicalEquivalenceExpression:
+        case SyntaxKind::LogicalImplicationExpression:
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
+        case SyntaxKind::LogicalOrExpression:
+        case SyntaxKind::LogicalRightShiftAssignmentExpression:
+        case SyntaxKind::LogicalShiftLeftExpression:
+        case SyntaxKind::LogicalShiftRightExpression:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::MemberAccessExpression:
+        case SyntaxKind::MinTypMaxExpression:
+        case SyntaxKind::ModAssignmentExpression:
+        case SyntaxKind::ModExpression:
+        case SyntaxKind::MultipleConcatenationExpression:
+        case SyntaxKind::MultiplyAssignmentExpression:
+        case SyntaxKind::MultiplyExpression:
+        case SyntaxKind::NamedType:
+        case SyntaxKind::NewArrayExpression:
+        case SyntaxKind::NewClassExpression:
+        case SyntaxKind::NewExpression:
+        case SyntaxKind::NextTimePropertyExpression:
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
+        case SyntaxKind::NonblockingAssignmentExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::OpenRangeExpression:
+        case SyntaxKind::OrAssignmentExpression:
+        case SyntaxKind::OrSequenceExpression:
+        case SyntaxKind::OverlappedFollowedByPropertyExpression:
+        case SyntaxKind::OverlappedImplicationPropertyExpression:
+        case SyntaxKind::ParenthesizedExpression:
+        case SyntaxKind::PostdecrementExpression:
+        case SyntaxKind::PostincrementExpression:
+        case SyntaxKind::PowerExpression:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::RejectOnPropertyExpression:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::SAlwaysPropertyExpression:
+        case SyntaxKind::SEventuallyPropertyExpression:
+        case SyntaxKind::SNextTimePropertyExpression:
+        case SyntaxKind::SUntilPropertyExpression:
+        case SyntaxKind::SUntilWithPropertyExpression:
+        case SyntaxKind::ScopedName:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::SignedCastExpression:
+        case SyntaxKind::StreamingConcatenationExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::StringType:
+        case SyntaxKind::StructType:
+        case SyntaxKind::SubtractAssignmentExpression:
+        case SyntaxKind::SubtractExpression:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::SyncAcceptOnPropertyExpression:
+        case SyntaxKind::SyncRejectOnPropertyExpression:
+        case SyntaxKind::SystemName:
+        case SyntaxKind::TaggedUnionExpression:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::ThroughoutSequenceExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::TimeType:
+        case SyntaxKind::TimingControlExpression:
+        case SyntaxKind::TimingControlExpressionConcatenation:
+        case SyntaxKind::TypeReference:
+        case SyntaxKind::UnaryBitwiseAndExpression:
+        case SyntaxKind::UnaryBitwiseNandExpression:
+        case SyntaxKind::UnaryBitwiseNorExpression:
+        case SyntaxKind::UnaryBitwiseNotExpression:
+        case SyntaxKind::UnaryBitwiseOrExpression:
+        case SyntaxKind::UnaryBitwiseXnorExpression:
+        case SyntaxKind::UnaryBitwiseXorExpression:
+        case SyntaxKind::UnaryLogicalNotExpression:
+        case SyntaxKind::UnaryMinusExpression:
+        case SyntaxKind::UnaryNotPropertyExpression:
+        case SyntaxKind::UnaryPlusExpression:
+        case SyntaxKind::UnaryPredecrementExpression:
+        case SyntaxKind::UnaryPreincrementExpression:
+        case SyntaxKind::UnarySequenceDelayExpression:
+        case SyntaxKind::UnarySequenceEventExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::UnionType:
+        case SyntaxKind::UnitScope:
+        case SyntaxKind::UntilPropertyExpression:
+        case SyntaxKind::UntilWithPropertyExpression:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VirtualInterfaceType:
+        case SyntaxKind::VoidType:
+        case SyntaxKind::WildcardEqualityExpression:
+        case SyntaxKind::WildcardInequalityExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+        case SyntaxKind::WithinSequenceExpression:
+        case SyntaxKind::XorAssignmentExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ExtendsClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExtendsClause;
+}
+
+TokenOrSyntax ExtendsClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseName.get();
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExtendsClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return baseName.get();
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+void ExtendsClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: baseName = &child.node()->as<NameSyntax>(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExtendsClauseSyntax* ExtendsClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExtendsClauseSyntax>(*this);
+}
+
+bool ExternModuleSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ExternModule;
+}
+
+TokenOrSyntax ExternModuleSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return externKeyword;
+        case 1: return header.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ExternModuleSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return externKeyword;
+        case 1: return header.get();
+        default: return nullptr;
+    }
+}
+
+void ExternModuleSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: externKeyword = child.token(); return;
+        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ExternModuleSyntax* ExternModuleSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ExternModuleSyntax>(*this);
+}
+
+bool ForLoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForLoopStatement;
+}
+
+TokenOrSyntax ForLoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return forKeyword;
+        case 3: return openParen;
+        case 4: return &initializers;
+        case 5: return semi1;
+        case 6: return stopExpr.get();
+        case 7: return semi2;
+        case 8: return &steps;
+        case 9: return closeParen;
+        case 10: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForLoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return forKeyword;
+        case 3: return openParen;
+        case 4: return &initializers;
+        case 5: return semi1;
+        case 6: return stopExpr.get();
+        case 7: return semi2;
+        case 8: return &steps;
+        case 9: return closeParen;
+        case 10: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForLoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: forKeyword = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: initializers = child.node()->as<SeparatedSyntaxList<SyntaxNode>>(); return;
+        case 5: semi1 = child.token(); return;
+        case 6: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: semi2 = child.token(); return;
+        case 8: steps = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 9: closeParen = child.token(); return;
+        case 10: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForLoopStatementSyntax* ForLoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForLoopStatementSyntax>(*this);
+}
+
+bool ForVariableDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForVariableDeclaration;
+}
+
+TokenOrSyntax ForVariableDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return varKeyword;
+        case 1: return type;
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForVariableDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return varKeyword;
+        case 1: return type;
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void ForVariableDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: varKeyword = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForVariableDeclarationSyntax* ForVariableDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForVariableDeclarationSyntax>(*this);
+}
+
+bool ForeachLoopListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeachLoopList;
+}
+
+TokenOrSyntax ForeachLoopListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return arrayName.get();
+        case 2: return openBracket;
+        case 3: return &loopVariables;
+        case 4: return closeBracket;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeachLoopListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return arrayName.get();
+        case 2: return openBracket;
+        case 3: return &loopVariables;
+        case 4: return closeBracket;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ForeachLoopListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: arrayName = &child.node()->as<NameSyntax>(); return;
+        case 2: openBracket = child.token(); return;
+        case 3: loopVariables = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 4: closeBracket = child.token(); return;
+        case 5: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeachLoopListSyntax* ForeachLoopListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeachLoopListSyntax>(*this);
+}
+
+bool ForeachLoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeachLoopStatement;
+}
+
+TokenOrSyntax ForeachLoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return loopList.get();
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeachLoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return loopList.get();
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForeachLoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
+        case 4: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeachLoopStatementSyntax* ForeachLoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeachLoopStatementSyntax>(*this);
+}
+
+bool ForeverStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForeverStatement;
+}
+
+TokenOrSyntax ForeverStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return foreverKeyword;
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForeverStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return foreverKeyword;
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ForeverStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: foreverKeyword = child.token(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForeverStatementSyntax* ForeverStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForeverStatementSyntax>(*this);
+}
+
+bool ForwardInterfaceClassTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForwardInterfaceClassTypedefDeclaration;
+}
+
+TokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return interfaceKeyword;
+        case 3: return classKeyword;
+        case 4: return name;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return interfaceKeyword;
+        case 3: return classKeyword;
+        case 4: return name;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void ForwardInterfaceClassTypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: interfaceKeyword = child.token(); return;
+        case 3: classKeyword = child.token(); return;
+        case 4: name = child.token(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForwardInterfaceClassTypedefDeclarationSyntax* ForwardInterfaceClassTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForwardInterfaceClassTypedefDeclarationSyntax>(*this);
+}
+
+bool ForwardTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ForwardTypedefDeclaration;
+}
+
+TokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return keyword;
+        case 3: return name;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ForwardTypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: keyword = child.token(); return;
+        case 3: name = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ForwardTypedefDeclarationSyntax* ForwardTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ForwardTypedefDeclarationSyntax>(*this);
+}
+
+bool FunctionDeclarationSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::FunctionDeclaration:
+        case SyntaxKind::TaskDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax FunctionDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return prototype.get();
+        case 2: return semi;
+        case 3: return &items;
+        case 4: return end;
+        case 5: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return prototype.get();
+        case 2: return semi;
+        case 3: return &items;
+        case 4: return end;
+        case 5: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void FunctionDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        case 2: semi = child.token(); return;
+        case 3: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
+        case 4: end = child.token(); return;
+        case 5: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionDeclarationSyntax* FunctionDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionDeclarationSyntax>(*this);
+}
+
+bool FunctionPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPortList;
+}
+
+TokenOrSyntax FunctionPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void FunctionPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<FunctionPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPortListSyntax* FunctionPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPortListSyntax>(*this);
+}
+
+bool FunctionPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPort;
+}
+
+TokenOrSyntax FunctionPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return constKeyword;
+        case 2: return direction;
+        case 3: return varKeyword;
+        case 4: return dataType;
+        case 5: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return constKeyword;
+        case 2: return direction;
+        case 3: return varKeyword;
+        case 4: return dataType;
+        case 5: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void FunctionPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: constKeyword = child.token(); return;
+        case 2: direction = child.token(); return;
+        case 3: varKeyword = child.token(); return;
+        case 4: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        case 5: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPortSyntax* FunctionPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPortSyntax>(*this);
+}
+
+bool FunctionPrototypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::FunctionPrototype;
+}
+
+TokenOrSyntax FunctionPrototypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return lifetime;
+        case 2: return returnType.get();
+        case 3: return name.get();
+        case 4: return portList;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax FunctionPrototypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return lifetime;
+        case 2: return returnType.get();
+        case 3: return name.get();
+        case 4: return portList;
+        default: return nullptr;
+    }
+}
+
+void FunctionPrototypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: lifetime = child.token(); return;
+        case 2: returnType = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = &child.node()->as<NameSyntax>(); return;
+        case 4: portList = &child.node()->as<FunctionPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+FunctionPrototypeSyntax* FunctionPrototypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<FunctionPrototypeSyntax>(*this);
+}
+
+bool GateInstanceNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstanceName;
+}
+
+TokenOrSyntax GateInstanceNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstanceNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void GateInstanceNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstanceNameSyntax* GateInstanceNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstanceNameSyntax>(*this);
+}
+
+bool GateInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstance;
+}
+
+TokenOrSyntax GateInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return decl;
+        case 1: return openParen;
+        case 2: return &connections;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return decl;
+        case 1: return openParen;
+        case 2: return &connections;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void GateInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: decl = &child.node()->as<GateInstanceNameSyntax>(); return;
+        case 1: openParen = child.token(); return;
+        case 2: connections = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstanceSyntax* GateInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstanceSyntax>(*this);
+}
+
+bool GateInstantiationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GateInstantiation;
+}
+
+TokenOrSyntax GateInstantiationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return gateType;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &instances;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GateInstantiationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return gateType;
+        case 2: return strength;
+        case 3: return delay;
+        case 4: return &instances;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void GateInstantiationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: gateType = child.token(); return;
+        case 2: strength = &child.node()->as<DriveStrengthSyntax>(); return;
+        case 3: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 4: instances = child.node()->as<SeparatedSyntaxList<GateInstanceSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GateInstantiationSyntax* GateInstantiationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GateInstantiationSyntax>(*this);
+}
+
+bool GenerateBlockSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenerateBlock;
+}
+
+TokenOrSyntax GenerateBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return label;
+        case 2: return begin;
+        case 3: return beginName;
+        case 4: return &members;
+        case 5: return end;
+        case 6: return endName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenerateBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return label;
+        case 2: return begin;
+        case 3: return beginName;
+        case 4: return &members;
+        case 5: return end;
+        case 6: return endName;
+        default: return nullptr;
+    }
+}
+
+void GenerateBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 2: begin = child.token(); return;
+        case 3: beginName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        case 4: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 5: end = child.token(); return;
+        case 6: endName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenerateBlockSyntax* GenerateBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenerateBlockSyntax>(*this);
+}
+
+bool GenerateRegionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenerateRegion;
+}
+
+TokenOrSyntax GenerateRegionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &members;
+        case 3: return endgenerate;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenerateRegionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &members;
+        case 3: return endgenerate;
+        default: return nullptr;
+    }
+}
+
+void GenerateRegionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 3: endgenerate = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenerateRegionSyntax* GenerateRegionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenerateRegionSyntax>(*this);
+}
+
+bool GenvarDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::GenvarDeclaration;
+}
+
+TokenOrSyntax GenvarDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &identifiers;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax GenvarDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &identifiers;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void GenvarDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: identifiers = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+GenvarDeclarationSyntax* GenvarDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<GenvarDeclarationSyntax>(*this);
+}
+
+bool HierarchicalInstanceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::HierarchicalInstance;
+}
+
+TokenOrSyntax HierarchicalInstanceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return openParen;
+        case 3: return &connections;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax HierarchicalInstanceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return &dimensions;
+        case 2: return openParen;
+        case 3: return &connections;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void HierarchicalInstanceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 2: openParen = child.token(); return;
+        case 3: connections = child.node()->as<SeparatedSyntaxList<PortConnectionSyntax>>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+HierarchicalInstanceSyntax* HierarchicalInstanceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<HierarchicalInstanceSyntax>(*this);
+}
+
+bool HierarchyInstantiationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::HierarchyInstantiation;
+}
+
+TokenOrSyntax HierarchyInstantiationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return parameters;
+        case 3: return &instances;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax HierarchyInstantiationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return type;
+        case 2: return parameters;
+        case 3: return &instances;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void HierarchyInstantiationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: type = child.token(); return;
+        case 2: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        case 3: instances = child.node()->as<SeparatedSyntaxList<HierarchicalInstanceSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+HierarchyInstantiationSyntax* HierarchyInstantiationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<HierarchyInstantiationSyntax>(*this);
+}
+
+bool IdentifierNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IdentifierName;
+}
+
+TokenOrSyntax IdentifierNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IdentifierNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        default: return nullptr;
+    }
+}
+
+void IdentifierNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IdentifierNameSyntax* IdentifierNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IdentifierNameSyntax>(*this);
+}
+
+bool IdentifierSelectNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IdentifierSelectName;
+}
+
+TokenOrSyntax IdentifierSelectNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return &selectors;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IdentifierSelectNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return identifier;
+        case 1: return &selectors;
+        default: return nullptr;
+    }
+}
+
+void IdentifierSelectNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: identifier = child.token(); return;
+        case 1: selectors = child.node()->as<SyntaxList<ElementSelectSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IdentifierSelectNameSyntax* IdentifierSelectNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IdentifierSelectNameSyntax>(*this);
+}
+
+bool IfGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IfGenerate;
+}
+
+TokenOrSyntax IfGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return block.get();
+        case 6: return elseClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IfGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return condition.get();
+        case 4: return closeParen;
+        case 5: return block.get();
+        case 6: return elseClause;
+        default: return nullptr;
+    }
+}
+
+void IfGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        case 5: block = &child.node()->as<MemberSyntax>(); return;
+        case 6: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IfGenerateSyntax* IfGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IfGenerateSyntax>(*this);
+}
+
+bool IffClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IffClause;
+}
+
+TokenOrSyntax IffClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return iff;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IffClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return iff;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void IffClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: iff = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IffClauseSyntax* IffClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IffClauseSyntax>(*this);
+}
+
+bool ImmediateAssertionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImmediateAssertionMember;
+}
+
+TokenOrSyntax ImmediateAssertionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImmediateAssertionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ImmediateAssertionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: statement = &child.node()->as<ImmediateAssertionStatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImmediateAssertionMemberSyntax* ImmediateAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImmediateAssertionMemberSyntax>(*this);
+}
+
+bool ImmediateAssertionStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ImmediateAssertStatement:
+        case SyntaxKind::ImmediateAssumeStatement:
+        case SyntaxKind::ImmediateCoverStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ImmediateAssertionStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return delay;
+        case 4: return expr.get();
+        case 5: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImmediateAssertionStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return delay;
+        case 4: return expr.get();
+        case 5: return action.get();
+        default: return nullptr;
+    }
+}
+
+void ImmediateAssertionStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: delay = &child.node()->as<DeferredAssertionSyntax>(); return;
+        case 4: expr = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        case 5: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImmediateAssertionStatementSyntax* ImmediateAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImmediateAssertionStatementSyntax>(*this);
+}
+
+bool ImplementsClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplementsClause;
+}
+
+TokenOrSyntax ImplementsClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return &interfaces;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplementsClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return &interfaces;
+        default: return nullptr;
+    }
+}
+
+void ImplementsClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: interfaces = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplementsClauseSyntax* ImplementsClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplementsClauseSyntax>(*this);
+}
+
+bool ImplicationConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicationConstraint;
+}
+
+TokenOrSyntax ImplicationConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return arrow;
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicationConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return arrow;
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void ImplicationConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: arrow = child.token(); return;
+        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicationConstraintSyntax* ImplicationConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicationConstraintSyntax>(*this);
+}
+
+bool ImplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitAnsiPort;
+}
+
+TokenOrSyntax ImplicitAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return declarator.get();
+        default: return nullptr;
+    }
+}
+
+void ImplicitAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
+        case 2: declarator = &child.node()->as<DeclaratorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitAnsiPortSyntax* ImplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitAnsiPortSyntax>(*this);
+}
+
+bool ImplicitEventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitEventControl;
+}
+
+TokenOrSyntax ImplicitEventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return at;
+        case 1: return openParen;
+        case 2: return star;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitEventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return at;
+        case 1: return openParen;
+        case 2: return star;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ImplicitEventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: at = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: star = child.token(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitEventControlSyntax* ImplicitEventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitEventControlSyntax>(*this);
+}
+
+bool ImplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitNonAnsiPort;
+}
+
+TokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr;
+        default: return nullptr;
+    }
+}
+
+void ImplicitNonAnsiPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<PortExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitNonAnsiPortSyntax* ImplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitNonAnsiPortSyntax>(*this);
+}
+
+bool ImplicitTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ImplicitType;
+}
+
+TokenOrSyntax ImplicitTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return signing;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ImplicitTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return signing;
+        case 1: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void ImplicitTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: signing = child.token(); return;
+        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ImplicitTypeSyntax* ImplicitTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ImplicitTypeSyntax>(*this);
+}
+
+bool IncludeDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IncludeDirective;
+}
+
+TokenOrSyntax IncludeDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return fileName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IncludeDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return fileName;
+        default: return nullptr;
+    }
+}
+
+void IncludeDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: fileName = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IncludeDirectiveSyntax* IncludeDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IncludeDirectiveSyntax>(*this);
+}
+
+bool InsideExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InsideExpression;
+}
+
+TokenOrSyntax InsideExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return inside;
+        case 2: return ranges.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InsideExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return inside;
+        case 2: return ranges.get();
+        default: return nullptr;
+    }
+}
+
+void InsideExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: inside = child.token(); return;
+        case 2: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InsideExpressionSyntax* InsideExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InsideExpressionSyntax>(*this);
+}
+
+bool IntegerTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::BitType:
+        case SyntaxKind::ByteType:
+        case SyntaxKind::IntType:
+        case SyntaxKind::IntegerType:
+        case SyntaxKind::LogicType:
+        case SyntaxKind::LongIntType:
+        case SyntaxKind::RegType:
+        case SyntaxKind::ShortIntType:
+        case SyntaxKind::TimeType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax IntegerTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return signing;
+        case 2: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IntegerTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return signing;
+        case 2: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void IntegerTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: signing = child.token(); return;
+        case 2: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IntegerTypeSyntax* IntegerTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IntegerTypeSyntax>(*this);
+}
+
+bool IntegerVectorExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::IntegerVectorExpression;
+}
+
+TokenOrSyntax IntegerVectorExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax IntegerVectorExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+void IntegerVectorExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: size = child.token(); return;
+        case 1: base = child.token(); return;
+        case 2: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+IntegerVectorExpressionSyntax* IntegerVectorExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<IntegerVectorExpressionSyntax>(*this);
+}
+
+bool InterconnectPortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InterconnectPortHeader;
+}
+
+TokenOrSyntax InterconnectPortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return direction;
+        case 1: return interconnect;
+        case 2: return type.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InterconnectPortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return direction;
+        case 1: return interconnect;
+        case 2: return type.get();
+        default: return nullptr;
+    }
+}
+
+void InterconnectPortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: direction = child.token(); return;
+        case 1: interconnect = child.token(); return;
+        case 2: type = &child.node()->as<ImplicitTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InterconnectPortHeaderSyntax* InterconnectPortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InterconnectPortHeaderSyntax>(*this);
+}
+
+bool InterfacePortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InterfacePortHeader;
+}
+
+TokenOrSyntax InterfacePortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return nameOrKeyword;
+        case 1: return modport;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InterfacePortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return nameOrKeyword;
+        case 1: return modport;
+        default: return nullptr;
+    }
+}
+
+void InterfacePortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: nameOrKeyword = child.token(); return;
+        case 1: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InterfacePortHeaderSyntax* InterfacePortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InterfacePortHeaderSyntax>(*this);
+}
+
+bool InvocationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::InvocationExpression;
+}
+
+TokenOrSyntax InvocationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return &attributes;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax InvocationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return &attributes;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+void InvocationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+InvocationExpressionSyntax* InvocationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<InvocationExpressionSyntax>(*this);
+}
+
+bool JumpStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::JumpStatement;
+}
+
+TokenOrSyntax JumpStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return breakOrContinue;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax JumpStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return breakOrContinue;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void JumpStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: breakOrContinue = child.token(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+JumpStatementSyntax* JumpStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<JumpStatementSyntax>(*this);
+}
+
+bool KeywordNameSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::UnitScope:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax KeywordNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax KeywordNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void KeywordNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+KeywordNameSyntax* KeywordNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<KeywordNameSyntax>(*this);
+}
+
+bool KeywordTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CHandleType:
+        case SyntaxKind::EventType:
+        case SyntaxKind::PropertyType:
+        case SyntaxKind::RealTimeType:
+        case SyntaxKind::RealType:
+        case SyntaxKind::SequenceType:
+        case SyntaxKind::ShortRealType:
+        case SyntaxKind::StringType:
+        case SyntaxKind::Untyped:
+        case SyntaxKind::VoidType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax KeywordTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax KeywordTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void KeywordTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+KeywordTypeSyntax* KeywordTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<KeywordTypeSyntax>(*this);
+}
+
+bool LetDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LetDeclaration;
+}
+
+TokenOrSyntax LetDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return let;
+        case 2: return identifier;
+        case 3: return portList;
+        case 4: return initializer.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LetDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return let;
+        case 2: return identifier;
+        case 3: return portList;
+        case 4: return initializer.get();
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void LetDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: let = child.token(); return;
+        case 2: identifier = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LetDeclarationSyntax* LetDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LetDeclarationSyntax>(*this);
+}
+
+bool LineDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LineDirective;
+}
+
+TokenOrSyntax LineDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return lineNumber;
+        case 2: return fileName;
+        case 3: return level;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LineDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return lineNumber;
+        case 2: return fileName;
+        case 3: return level;
+        default: return nullptr;
+    }
+}
+
+void LineDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: lineNumber = child.token(); return;
+        case 2: fileName = child.token(); return;
+        case 3: level = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LineDirectiveSyntax* LineDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LineDirectiveSyntax>(*this);
+}
+
+bool LiteralExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax LiteralExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return literal;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LiteralExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return literal;
+        default: return nullptr;
+    }
+}
+
+void LiteralExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: literal = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LiteralExpressionSyntax* LiteralExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LiteralExpressionSyntax>(*this);
+}
+
+bool LoopConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopConstraint;
+}
+
+TokenOrSyntax LoopConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return foreachKeyword;
+        case 1: return loopList.get();
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return foreachKeyword;
+        case 1: return loopList.get();
+        case 2: return constraints.get();
+        default: return nullptr;
+    }
+}
+
+void LoopConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: foreachKeyword = child.token(); return;
+        case 1: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
+        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopConstraintSyntax* LoopConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopConstraintSyntax>(*this);
+}
+
+bool LoopGenerateSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopGenerate;
+}
+
+TokenOrSyntax LoopGenerateSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return genvar;
+        case 4: return identifier;
+        case 5: return equals;
+        case 6: return initialExpr.get();
+        case 7: return semi1;
+        case 8: return stopExpr.get();
+        case 9: return semi2;
+        case 10: return iterationExpr.get();
+        case 11: return closeParen;
+        case 12: return block.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopGenerateSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return openParen;
+        case 3: return genvar;
+        case 4: return identifier;
+        case 5: return equals;
+        case 6: return initialExpr.get();
+        case 7: return semi1;
+        case 8: return stopExpr.get();
+        case 9: return semi2;
+        case 10: return iterationExpr.get();
+        case 11: return closeParen;
+        case 12: return block.get();
+        default: return nullptr;
+    }
+}
+
+void LoopGenerateSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: genvar = child.token(); return;
+        case 4: identifier = child.token(); return;
+        case 5: equals = child.token(); return;
+        case 6: initialExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: semi1 = child.token(); return;
+        case 8: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 9: semi2 = child.token(); return;
+        case 10: iterationExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 11: closeParen = child.token(); return;
+        case 12: block = &child.node()->as<MemberSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopGenerateSyntax* LoopGenerateSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopGenerateSyntax>(*this);
+}
+
+bool LoopStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::LoopStatement;
+}
+
+TokenOrSyntax LoopStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return repeatOrWhile;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax LoopStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return repeatOrWhile;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void LoopStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: repeatOrWhile = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+LoopStatementSyntax* LoopStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<LoopStatementSyntax>(*this);
+}
+
+bool MacroActualArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroActualArgumentList;
+}
+
+TokenOrSyntax MacroActualArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroActualArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void MacroActualArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: args = child.node()->as<SeparatedSyntaxList<MacroActualArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroActualArgumentListSyntax* MacroActualArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroActualArgumentListSyntax>(*this);
+}
+
+bool MacroActualArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroActualArgument;
+}
+
+TokenOrSyntax MacroActualArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &tokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroActualArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &tokens;
+        default: return nullptr;
+    }
+}
+
+void MacroActualArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroActualArgumentSyntax* MacroActualArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroActualArgumentSyntax>(*this);
+}
+
+bool MacroArgumentDefaultSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroArgumentDefault;
+}
+
+TokenOrSyntax MacroArgumentDefaultSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return equals;
+        case 1: return &tokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroArgumentDefaultSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return equals;
+        case 1: return &tokens;
+        default: return nullptr;
+    }
+}
+
+void MacroArgumentDefaultSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: equals = child.token(); return;
+        case 1: tokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroArgumentDefaultSyntax* MacroArgumentDefaultSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroArgumentDefaultSyntax>(*this);
+}
+
+bool MacroFormalArgumentListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroFormalArgumentList;
+}
+
+TokenOrSyntax MacroFormalArgumentListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroFormalArgumentListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &args;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void MacroFormalArgumentListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: args = child.node()->as<SeparatedSyntaxList<MacroFormalArgumentSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroFormalArgumentListSyntax* MacroFormalArgumentListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroFormalArgumentListSyntax>(*this);
+}
+
+bool MacroFormalArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroFormalArgument;
+}
+
+TokenOrSyntax MacroFormalArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return defaultValue;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroFormalArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return defaultValue;
+        default: return nullptr;
+    }
+}
+
+void MacroFormalArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: defaultValue = &child.node()->as<MacroArgumentDefaultSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroFormalArgumentSyntax* MacroFormalArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroFormalArgumentSyntax>(*this);
+}
+
+bool MacroUsageSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MacroUsage;
+}
+
+TokenOrSyntax MacroUsageSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return args;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MacroUsageSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return args;
+        default: return nullptr;
+    }
+}
+
+void MacroUsageSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: args = &child.node()->as<MacroActualArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MacroUsageSyntax* MacroUsageSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MacroUsageSyntax>(*this);
+}
+
+bool MatchesClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MatchesClause;
+}
+
+TokenOrSyntax MatchesClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return matchesKeyword;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MatchesClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return matchesKeyword;
+        case 1: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void MatchesClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: matchesKeyword = child.token(); return;
+        case 1: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MatchesClauseSyntax* MatchesClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MatchesClauseSyntax>(*this);
+}
+
+bool MemberAccessExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MemberAccessExpression;
+}
+
+TokenOrSyntax MemberAccessExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return dot;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MemberAccessExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return dot;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+void MemberAccessExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: dot = child.token(); return;
+        case 2: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MemberAccessExpressionSyntax* MemberAccessExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MemberAccessExpressionSyntax>(*this);
+}
+
+bool MemberSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AlwaysBlock:
+        case SyntaxKind::AlwaysCombBlock:
+        case SyntaxKind::AlwaysFFBlock:
+        case SyntaxKind::AlwaysLatchBlock:
+        case SyntaxKind::CaseGenerate:
+        case SyntaxKind::ClassDeclaration:
+        case SyntaxKind::ClassMethodDeclaration:
+        case SyntaxKind::ClassMethodPrototype:
+        case SyntaxKind::ClassPropertyDeclaration:
+        case SyntaxKind::ClockingDeclaration:
+        case SyntaxKind::ConcurrentAssertionMember:
+        case SyntaxKind::ConstraintDeclaration:
+        case SyntaxKind::ConstraintPrototype:
+        case SyntaxKind::ContinuousAssign:
+        case SyntaxKind::CoverageBins:
+        case SyntaxKind::CoverageOption:
+        case SyntaxKind::CovergroupDeclaration:
+        case SyntaxKind::Coverpoint:
+        case SyntaxKind::DPIImportExport:
+        case SyntaxKind::DataDeclaration:
+        case SyntaxKind::DefParam:
+        case SyntaxKind::EmptyMember:
+        case SyntaxKind::ExplicitAnsiPort:
+        case SyntaxKind::FinalBlock:
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration:
+        case SyntaxKind::ForwardTypedefDeclaration:
+        case SyntaxKind::FunctionDeclaration:
+        case SyntaxKind::GateInstantiation:
+        case SyntaxKind::GenerateBlock:
+        case SyntaxKind::GenerateRegion:
+        case SyntaxKind::GenvarDeclaration:
+        case SyntaxKind::HierarchyInstantiation:
+        case SyntaxKind::IfGenerate:
+        case SyntaxKind::ImmediateAssertionMember:
+        case SyntaxKind::ImplicitAnsiPort:
+        case SyntaxKind::InitialBlock:
+        case SyntaxKind::InterfaceDeclaration:
+        case SyntaxKind::LetDeclaration:
+        case SyntaxKind::LoopGenerate:
+        case SyntaxKind::ModportClockingPort:
+        case SyntaxKind::ModportDeclaration:
+        case SyntaxKind::ModportSimplePortList:
+        case SyntaxKind::ModportSubroutinePortList:
+        case SyntaxKind::ModuleDeclaration:
+        case SyntaxKind::NetDeclaration:
+        case SyntaxKind::NetTypeDeclaration:
+        case SyntaxKind::PackageDeclaration:
+        case SyntaxKind::PackageImportDeclaration:
+        case SyntaxKind::ParameterDeclarationStatement:
+        case SyntaxKind::PortDeclaration:
+        case SyntaxKind::ProgramDeclaration:
+        case SyntaxKind::PropertyDeclaration:
+        case SyntaxKind::SequenceDeclaration:
+        case SyntaxKind::TaskDeclaration:
+        case SyntaxKind::TimeUnitsDeclaration:
+        case SyntaxKind::TypedefDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax MemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void MemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MemberSyntax* MemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MemberSyntax>(*this);
+}
+
+bool MinTypMaxExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MinTypMaxExpression;
+}
+
+TokenOrSyntax MinTypMaxExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return min.get();
+        case 1: return colon1;
+        case 2: return typ.get();
+        case 3: return colon2;
+        case 4: return max.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MinTypMaxExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return min.get();
+        case 1: return colon1;
+        case 2: return typ.get();
+        case 3: return colon2;
+        case 4: return max.get();
+        default: return nullptr;
+    }
+}
+
+void MinTypMaxExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: min = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon1 = child.token(); return;
+        case 2: typ = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: colon2 = child.token(); return;
+        case 4: max = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MinTypMaxExpressionSyntax* MinTypMaxExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MinTypMaxExpressionSyntax>(*this);
+}
+
+bool ModportClockingPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportClockingPort;
+}
+
+TokenOrSyntax ModportClockingPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return clocking;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportClockingPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return clocking;
+        case 2: return name;
+        default: return nullptr;
+    }
+}
+
+void ModportClockingPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: clocking = child.token(); return;
+        case 2: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportClockingPortSyntax* ModportClockingPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportClockingPortSyntax>(*this);
+}
+
+bool ModportDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportDeclaration;
+}
+
+TokenOrSyntax ModportDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void ModportDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<ModportItemSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportDeclarationSyntax* ModportDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportDeclarationSyntax>(*this);
+}
+
+bool ModportExplicitPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportExplicitPort;
+}
+
+TokenOrSyntax ModportExplicitPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportExplicitPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ModportExplicitPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportExplicitPortSyntax* ModportExplicitPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportExplicitPortSyntax>(*this);
+}
+
+bool ModportItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportItem;
+}
+
+TokenOrSyntax ModportItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return ports.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return ports.get();
+        default: return nullptr;
+    }
+}
+
+void ModportItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: ports = &child.node()->as<AnsiPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportItemSyntax* ModportItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportItemSyntax>(*this);
+}
+
+bool ModportNamedPortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportNamedPort;
+}
+
+TokenOrSyntax ModportNamedPortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportNamedPortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        default: return nullptr;
+    }
+}
+
+void ModportNamedPortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportNamedPortSyntax* ModportNamedPortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportNamedPortSyntax>(*this);
+}
+
+bool ModportPortSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ModportExplicitPort:
+        case SyntaxKind::ModportNamedPort:
+        case SyntaxKind::ModportSubroutinePort:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ModportSimplePortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSimplePortList;
+}
+
+TokenOrSyntax ModportSimplePortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSimplePortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return direction;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+void ModportSimplePortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: direction = child.token(); return;
+        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSimplePortListSyntax* ModportSimplePortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSimplePortListSyntax>(*this);
+}
+
+bool ModportSubroutinePortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSubroutinePortList;
+}
+
+TokenOrSyntax ModportSubroutinePortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return importExport;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSubroutinePortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return importExport;
+        case 2: return &ports;
+        default: return nullptr;
+    }
+}
+
+void ModportSubroutinePortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: importExport = child.token(); return;
+        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSubroutinePortListSyntax* ModportSubroutinePortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSubroutinePortListSyntax>(*this);
+}
+
+bool ModportSubroutinePortSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ModportSubroutinePort;
+}
+
+TokenOrSyntax ModportSubroutinePortSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return prototype.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModportSubroutinePortSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return prototype.get();
+        default: return nullptr;
+    }
+}
+
+void ModportSubroutinePortSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModportSubroutinePortSyntax* ModportSubroutinePortSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModportSubroutinePortSyntax>(*this);
+}
+
+bool ModuleDeclarationSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterfaceDeclaration:
+        case SyntaxKind::ModuleDeclaration:
+        case SyntaxKind::PackageDeclaration:
+        case SyntaxKind::ProgramDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ModuleDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &members;
+        case 3: return endmodule;
+        case 4: return blockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModuleDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &members;
+        case 3: return endmodule;
+        case 4: return blockName;
+        default: return nullptr;
+    }
+}
+
+void ModuleDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
+        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 3: endmodule = child.token(); return;
+        case 4: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModuleDeclarationSyntax* ModuleDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModuleDeclarationSyntax>(*this);
+}
+
+bool ModuleHeaderSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterfaceHeader:
+        case SyntaxKind::ModuleHeader:
+        case SyntaxKind::PackageHeader:
+        case SyntaxKind::ProgramHeader:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ModuleHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return moduleKeyword;
+        case 1: return lifetime;
+        case 2: return name;
+        case 3: return &imports;
+        case 4: return parameters;
+        case 5: return ports;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ModuleHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return moduleKeyword;
+        case 1: return lifetime;
+        case 2: return name;
+        case 3: return &imports;
+        case 4: return parameters;
+        case 5: return ports;
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void ModuleHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: moduleKeyword = child.token(); return;
+        case 1: lifetime = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: imports = child.node()->as<SyntaxList<PackageImportDeclarationSyntax>>(); return;
+        case 4: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
+        case 5: ports = &child.node()->as<PortListSyntax>(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ModuleHeaderSyntax* ModuleHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ModuleHeaderSyntax>(*this);
+}
+
+bool MultipleConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::MultipleConcatenationExpression;
+}
+
+TokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return expression.get();
+        case 2: return concatenation.get();
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return expression.get();
+        case 2: return concatenation.get();
+        case 3: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void MultipleConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: concatenation = &child.node()->as<ConcatenationExpressionSyntax>(); return;
+        case 3: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+MultipleConcatenationExpressionSyntax* MultipleConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<MultipleConcatenationExpressionSyntax>(*this);
+}
+
+bool NameSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ArrayAndMethod:
+        case SyntaxKind::ArrayOrMethod:
+        case SyntaxKind::ArrayUniqueMethod:
+        case SyntaxKind::ArrayXorMethod:
+        case SyntaxKind::ClassName:
+        case SyntaxKind::ClassScope:
+        case SyntaxKind::ConstructorName:
+        case SyntaxKind::EmptyIdentifierName:
+        case SyntaxKind::IdentifierName:
+        case SyntaxKind::IdentifierSelectName:
+        case SyntaxKind::LocalScope:
+        case SyntaxKind::RootScope:
+        case SyntaxKind::ScopedName:
+        case SyntaxKind::SuperHandle:
+        case SyntaxKind::SystemName:
+        case SyntaxKind::ThisHandle:
+        case SyntaxKind::UnitScope:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NameValuePragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NameValuePragmaExpression;
+}
+
+TokenOrSyntax NameValuePragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NameValuePragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return equals;
+        case 2: return value.get();
+        default: return nullptr;
+    }
+}
+
+void NameValuePragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: equals = child.token(); return;
+        case 2: value = &child.node()->as<PragmaExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NameValuePragmaExpressionSyntax* NameValuePragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NameValuePragmaExpressionSyntax>(*this);
+}
+
+bool NamedArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedArgument;
+}
+
+TokenOrSyntax NamedArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return name;
+        case 2: return openParen;
+        case 3: return expr;
+        case 4: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NamedArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: openParen = child.token(); return;
+        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedArgumentSyntax* NamedArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedArgumentSyntax>(*this);
+}
+
+bool NamedBlockClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedBlockClause;
+}
+
+TokenOrSyntax NamedBlockClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return colon;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedBlockClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return colon;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+void NamedBlockClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: colon = child.token(); return;
+        case 1: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedBlockClauseSyntax* NamedBlockClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedBlockClauseSyntax>(*this);
+}
+
+bool NamedLabelSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedLabel;
+}
+
+TokenOrSyntax NamedLabelSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedLabelSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        default: return nullptr;
+    }
+}
+
+void NamedLabelSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: colon = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedLabelSyntax* NamedLabelSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedLabelSyntax>(*this);
+}
+
+bool NamedPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedPortConnection;
+}
+
+TokenOrSyntax NamedPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dot;
+        case 2: return name;
+        case 3: return openParen;
+        case 4: return expr;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dot;
+        case 2: return name;
+        case 3: return openParen;
+        case 4: return expr;
+        case 5: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NamedPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: dot = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedPortConnectionSyntax* NamedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedPortConnectionSyntax>(*this);
+}
+
+bool NamedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedStructurePatternMember;
+}
+
+TokenOrSyntax NamedStructurePatternMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        case 2: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedStructurePatternMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return colon;
+        case 2: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void NamedStructurePatternMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: colon = child.token(); return;
+        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedStructurePatternMemberSyntax* NamedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedStructurePatternMemberSyntax>(*this);
+}
+
+bool NamedTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NamedType;
+}
+
+TokenOrSyntax NamedTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NamedTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name.get();
+        default: return nullptr;
+    }
+}
+
+void NamedTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NamedTypeSyntax* NamedTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NamedTypeSyntax>(*this);
+}
+
+bool NetDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetDeclaration;
+}
+
+TokenOrSyntax NetDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return strength;
+        case 3: return expansionHint;
+        case 4: return type.get();
+        case 5: return delay;
+        case 6: return &declarators;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return netType;
+        case 2: return strength;
+        case 3: return expansionHint;
+        case 4: return type.get();
+        case 5: return delay;
+        case 6: return &declarators;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void NetDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: netType = child.token(); return;
+        case 2: strength = &child.node()->as<NetStrengthSyntax>(); return;
+        case 3: expansionHint = child.token(); return;
+        case 4: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 5: delay = &child.node()->as<TimingControlSyntax>(); return;
+        case 6: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetDeclarationSyntax* NetDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetDeclarationSyntax>(*this);
+}
+
+bool NetPortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetPortHeader;
+}
+
+TokenOrSyntax NetPortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return direction;
+        case 1: return netType;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetPortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return direction;
+        case 1: return netType;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+void NetPortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: direction = child.token(); return;
+        case 1: netType = child.token(); return;
+        case 2: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetPortHeaderSyntax* NetPortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetPortHeaderSyntax>(*this);
+}
+
+bool NetStrengthSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ChargeStrength:
+        case SyntaxKind::DriveStrength:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NetTypeDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NetTypeDeclaration;
+}
+
+TokenOrSyntax NetTypeDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return withFunction;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NetTypeDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return withFunction;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void NetTypeDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = child.token(); return;
+        case 4: withFunction = &child.node()->as<WithFunctionClauseSyntax>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NetTypeDeclarationSyntax* NetTypeDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NetTypeDeclarationSyntax>(*this);
+}
+
+bool NewArrayExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NewArrayExpression;
+}
+
+TokenOrSyntax NewArrayExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return newKeyword;
+        case 1: return openBracket;
+        case 2: return sizeExpr.get();
+        case 3: return closeBracket;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NewArrayExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return newKeyword;
+        case 1: return openBracket;
+        case 2: return sizeExpr.get();
+        case 3: return closeBracket;
+        case 4: return initializer;
+        default: return nullptr;
+    }
+}
+
+void NewArrayExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: newKeyword = child.token(); return;
+        case 1: openBracket = child.token(); return;
+        case 2: sizeExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeBracket = child.token(); return;
+        case 4: initializer = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NewArrayExpressionSyntax* NewArrayExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NewArrayExpressionSyntax>(*this);
+}
+
+bool NewClassExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NewClassExpression;
+}
+
+TokenOrSyntax NewClassExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return classScope;
+        case 1: return newKeyword;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NewClassExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return classScope;
+        case 1: return newKeyword;
+        case 2: return arguments;
+        default: return nullptr;
+    }
+}
+
+void NewClassExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: classScope = &child.node()->as<ClassScopeSyntax>(); return;
+        case 1: newKeyword = child.token(); return;
+        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NewClassExpressionSyntax* NewClassExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NewClassExpressionSyntax>(*this);
+}
+
+bool NewExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NewExpression;
+}
+
+TokenOrSyntax NewExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return newKeyword;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NewExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return newKeyword;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void NewExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: newKeyword = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NewExpressionSyntax* NewExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NewExpressionSyntax>(*this);
+}
+
+bool NonAnsiPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NonAnsiPortList;
+}
+
+TokenOrSyntax NonAnsiPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NonAnsiPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ports;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void NonAnsiPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ports = child.node()->as<SeparatedSyntaxList<NonAnsiPortSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NonAnsiPortListSyntax* NonAnsiPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NonAnsiPortListSyntax>(*this);
+}
+
+bool NonAnsiPortSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ExplicitNonAnsiPort:
+        case SyntaxKind::ImplicitNonAnsiPort:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool NumberPragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::NumberPragmaExpression;
+}
+
+TokenOrSyntax NumberPragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax NumberPragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return size;
+        case 1: return base;
+        case 2: return value;
+        default: return nullptr;
+    }
+}
+
+void NumberPragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: size = child.token(); return;
+        case 1: base = child.token(); return;
+        case 2: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+NumberPragmaExpressionSyntax* NumberPragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<NumberPragmaExpressionSyntax>(*this);
+}
+
+bool OpenRangeExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OpenRangeExpression;
+}
+
+TokenOrSyntax OpenRangeExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return left.get();
+        case 2: return colon;
+        case 3: return right.get();
+        case 4: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OpenRangeExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return left.get();
+        case 2: return colon;
+        case 3: return right.get();
+        case 4: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void OpenRangeExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: colon = child.token(); return;
+        case 3: right = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OpenRangeExpressionSyntax* OpenRangeExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OpenRangeExpressionSyntax>(*this);
+}
+
+bool OpenRangeListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OpenRangeList;
+}
+
+TokenOrSyntax OpenRangeListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &valueRanges;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OpenRangeListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &valueRanges;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void OpenRangeListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: valueRanges = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OpenRangeListSyntax* OpenRangeListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OpenRangeListSyntax>(*this);
+}
+
+bool OrderedArgumentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedArgument;
+}
+
+TokenOrSyntax OrderedArgumentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedArgumentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void OrderedArgumentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedArgumentSyntax* OrderedArgumentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedArgumentSyntax>(*this);
+}
+
+bool OrderedPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedPortConnection;
+}
+
+TokenOrSyntax OrderedPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return expr;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return expr;
+        default: return nullptr;
+    }
+}
+
+void OrderedPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedPortConnectionSyntax* OrderedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedPortConnectionSyntax>(*this);
+}
+
+bool OrderedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::OrderedStructurePatternMember;
+}
+
+TokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return pattern.get();
+        default: return nullptr;
+    }
+}
+
+void OrderedStructurePatternMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+OrderedStructurePatternMemberSyntax* OrderedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<OrderedStructurePatternMemberSyntax>(*this);
+}
+
+bool PackageImportDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PackageImportDeclaration;
+}
+
+TokenOrSyntax PackageImportDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PackageImportDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return &items;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void PackageImportDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: items = child.node()->as<SeparatedSyntaxList<PackageImportItemSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PackageImportDeclarationSyntax* PackageImportDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PackageImportDeclarationSyntax>(*this);
+}
+
+bool PackageImportItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PackageImportItem;
+}
+
+TokenOrSyntax PackageImportItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return package;
+        case 1: return doubleColon;
+        case 2: return item;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PackageImportItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return package;
+        case 1: return doubleColon;
+        case 2: return item;
+        default: return nullptr;
+    }
+}
+
+void PackageImportItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: package = child.token(); return;
+        case 1: doubleColon = child.token(); return;
+        case 2: item = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PackageImportItemSyntax* PackageImportItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PackageImportItemSyntax>(*this);
+}
+
+bool ParameterDeclarationBaseSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ParameterDeclaration:
+        case SyntaxKind::TypeParameterDeclaration:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ParameterDeclarationBaseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationBaseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationBaseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationBaseSyntax* ParameterDeclarationBaseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationBaseSyntax>(*this);
+}
+
+bool ParameterDeclarationStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterDeclarationStatement;
+}
+
+TokenOrSyntax ParameterDeclarationStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return parameter.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return parameter.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: parameter = &child.node()->as<ParameterDeclarationBaseSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationStatementSyntax* ParameterDeclarationStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationStatementSyntax>(*this);
+}
+
+bool ParameterDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterDeclaration;
+}
+
+TokenOrSyntax ParameterDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return type.get();
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return type.get();
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+void ParameterDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterDeclarationSyntax* ParameterDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterDeclarationSyntax>(*this);
+}
+
+bool ParameterPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterPortList;
+}
+
+TokenOrSyntax ParameterPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return &declarations;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return openParen;
+        case 2: return &declarations;
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParameterPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: declarations = child.node()->as<SeparatedSyntaxList<ParameterDeclarationBaseSyntax>>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterPortListSyntax* ParameterPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterPortListSyntax>(*this);
+}
+
+bool ParameterValueAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParameterValueAssignment;
+}
+
+TokenOrSyntax ParameterValueAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return hash;
+        case 1: return assignments.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParameterValueAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return hash;
+        case 1: return assignments.get();
+        default: return nullptr;
+    }
+}
+
+void ParameterValueAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: hash = child.token(); return;
+        case 1: assignments = &child.node()->as<ArgumentListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParameterValueAssignmentSyntax* ParameterValueAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParameterValueAssignmentSyntax>(*this);
+}
+
+bool ParenExpressionListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenExpressionList;
+}
+
+TokenOrSyntax ParenExpressionListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &expressions;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenExpressionListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &expressions;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenExpressionListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenExpressionListSyntax* ParenExpressionListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenExpressionListSyntax>(*this);
+}
+
+bool ParenPragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenPragmaExpression;
+}
+
+TokenOrSyntax ParenPragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &values;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenPragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &values;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenPragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: values = child.node()->as<SeparatedSyntaxList<PragmaExpressionSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenPragmaExpressionSyntax* ParenPragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenPragmaExpressionSyntax>(*this);
+}
+
+bool ParenthesizedEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenthesizedEventExpression;
+}
+
+TokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expr.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expr.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenthesizedEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenthesizedEventExpressionSyntax* ParenthesizedEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenthesizedEventExpressionSyntax>(*this);
+}
+
+bool ParenthesizedExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ParenthesizedExpression;
+}
+
+TokenOrSyntax ParenthesizedExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expression.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ParenthesizedExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return expression.get();
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void ParenthesizedExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ParenthesizedExpressionSyntax* ParenthesizedExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ParenthesizedExpressionSyntax>(*this);
+}
+
+bool PatternCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PatternCaseItem;
+}
+
+TokenOrSyntax PatternCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return pattern.get();
+        case 1: return tripleAnd;
+        case 2: return expr;
+        case 3: return colon;
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PatternCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return pattern.get();
+        case 1: return tripleAnd;
+        case 2: return expr;
+        case 3: return colon;
+        case 4: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void PatternCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
+        case 1: tripleAnd = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: colon = child.token(); return;
+        case 4: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PatternCaseItemSyntax* PatternCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PatternCaseItemSyntax>(*this);
+}
+
+bool PatternSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ExpressionPattern:
+        case SyntaxKind::StructurePattern:
+        case SyntaxKind::TaggedPattern:
+        case SyntaxKind::VariablePattern:
+        case SyntaxKind::WildcardPattern:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortConcatenationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortConcatenation;
+}
+
+TokenOrSyntax PortConcatenationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &references;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortConcatenationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &references;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void PortConcatenationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: references = child.node()->as<SeparatedSyntaxList<PortReferenceSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortConcatenationSyntax* PortConcatenationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortConcatenationSyntax>(*this);
+}
+
+bool PortConnectionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::NamedPortConnection:
+        case SyntaxKind::OrderedPortConnection:
+        case SyntaxKind::WildcardPortConnection:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void PortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortConnectionSyntax* PortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortConnectionSyntax>(*this);
+}
+
+bool PortDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortDeclaration;
+}
+
+TokenOrSyntax PortDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &declarators;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return header.get();
+        case 2: return &declarators;
+        case 3: return semi;
+        default: return nullptr;
+    }
+}
+
+void PortDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 3: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortDeclarationSyntax* PortDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortDeclarationSyntax>(*this);
+}
+
+bool PortExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::PortConcatenation:
+        case SyntaxKind::PortReference:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortHeaderSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::InterconnectPortHeader:
+        case SyntaxKind::InterfacePortHeader:
+        case SyntaxKind::NetPortHeader:
+        case SyntaxKind::VariablePortHeader:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortListSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AnsiPortList:
+        case SyntaxKind::NonAnsiPortList:
+        case SyntaxKind::WildcardPortList:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PortReferenceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PortReference;
+}
+
+TokenOrSyntax PortReferenceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return select;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PortReferenceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return select;
+        default: return nullptr;
+    }
+}
+
+void PortReferenceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: select = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PortReferenceSyntax* PortReferenceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PortReferenceSyntax>(*this);
+}
+
+bool PostfixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::PostdecrementExpression:
+        case SyntaxKind::PostincrementExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PostfixUnaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return operand.get();
+        case 1: return &attributes;
+        case 2: return operatorToken;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PostfixUnaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return operand.get();
+        case 1: return &attributes;
+        case 2: return operatorToken;
+        default: return nullptr;
+    }
+}
+
+void PostfixUnaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: operand = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: operatorToken = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PostfixUnaryExpressionSyntax* PostfixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PostfixUnaryExpressionSyntax>(*this);
+}
+
+bool PragmaDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PragmaDirective;
+}
+
+TokenOrSyntax PragmaDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &args;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PragmaDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        case 2: return &args;
+        default: return nullptr;
+    }
+}
+
+void PragmaDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        case 2: args = child.node()->as<SeparatedSyntaxList<PragmaExpressionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PragmaDirectiveSyntax* PragmaDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PragmaDirectiveSyntax>(*this);
+}
+
+bool PragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::NameValuePragmaExpression:
+        case SyntaxKind::NumberPragmaExpression:
+        case SyntaxKind::ParenPragmaExpression:
+        case SyntaxKind::SimplePragmaExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool PrefixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression:
+        case SyntaxKind::AlwaysPropertyExpression:
+        case SyntaxKind::EventuallyPropertyExpression:
+        case SyntaxKind::NextTimePropertyExpression:
+        case SyntaxKind::RejectOnPropertyExpression:
+        case SyntaxKind::SAlwaysPropertyExpression:
+        case SyntaxKind::SEventuallyPropertyExpression:
+        case SyntaxKind::SNextTimePropertyExpression:
+        case SyntaxKind::SyncAcceptOnPropertyExpression:
+        case SyntaxKind::SyncRejectOnPropertyExpression:
+        case SyntaxKind::UnaryBitwiseAndExpression:
+        case SyntaxKind::UnaryBitwiseNandExpression:
+        case SyntaxKind::UnaryBitwiseNorExpression:
+        case SyntaxKind::UnaryBitwiseNotExpression:
+        case SyntaxKind::UnaryBitwiseOrExpression:
+        case SyntaxKind::UnaryBitwiseXnorExpression:
+        case SyntaxKind::UnaryBitwiseXorExpression:
+        case SyntaxKind::UnaryLogicalNotExpression:
+        case SyntaxKind::UnaryMinusExpression:
+        case SyntaxKind::UnaryNotPropertyExpression:
+        case SyntaxKind::UnaryPlusExpression:
+        case SyntaxKind::UnaryPredecrementExpression:
+        case SyntaxKind::UnaryPreincrementExpression:
+        case SyntaxKind::UnarySequenceDelayExpression:
+        case SyntaxKind::UnarySequenceEventExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax PrefixUnaryExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return operatorToken;
+        case 1: return &attributes;
+        case 2: return operand.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PrefixUnaryExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return operatorToken;
+        case 1: return &attributes;
+        case 2: return operand.get();
+        default: return nullptr;
+    }
+}
+
+void PrefixUnaryExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: operatorToken = child.token(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: operand = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PrefixUnaryExpressionSyntax* PrefixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PrefixUnaryExpressionSyntax>(*this);
+}
+
+bool PrimaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PrimaryBlockEventExpression;
+}
+
+TokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+void PrimaryBlockEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PrimaryBlockEventExpressionSyntax* PrimaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PrimaryBlockEventExpressionSyntax>(*this);
+}
+
+bool PrimaryExpressionSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssignmentPatternExpression:
+        case SyntaxKind::ConcatenationExpression:
+        case SyntaxKind::DefaultPatternKeyExpression:
+        case SyntaxKind::EmptyQueueExpression:
+        case SyntaxKind::IntegerLiteralExpression:
+        case SyntaxKind::IntegerVectorExpression:
+        case SyntaxKind::MultipleConcatenationExpression:
+        case SyntaxKind::NullLiteralExpression:
+        case SyntaxKind::OneStepLiteralExpression:
+        case SyntaxKind::ParenthesizedExpression:
+        case SyntaxKind::RealLiteralExpression:
+        case SyntaxKind::StreamingConcatenationExpression:
+        case SyntaxKind::StringLiteralExpression:
+        case SyntaxKind::TimeLiteralExpression:
+        case SyntaxKind::UnbasedUnsizedLiteralExpression:
+        case SyntaxKind::WildcardLiteralExpression:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool ProceduralAssignStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ProceduralAssignStatement:
+        case SyntaxKind::ProceduralForceStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralAssignStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return lvalue.get();
+        case 4: return equals;
+        case 5: return value.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralAssignStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return lvalue.get();
+        case 4: return equals;
+        case 5: return value.get();
+        case 6: return semi;
+        default: return nullptr;
+    }
+}
+
+void ProceduralAssignStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: lvalue = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: equals = child.token(); return;
+        case 5: value = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralAssignStatementSyntax* ProceduralAssignStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralAssignStatementSyntax>(*this);
+}
+
+bool ProceduralBlockSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AlwaysBlock:
+        case SyntaxKind::AlwaysCombBlock:
+        case SyntaxKind::AlwaysFFBlock:
+        case SyntaxKind::AlwaysLatchBlock:
+        case SyntaxKind::FinalBlock:
+        case SyntaxKind::InitialBlock:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralBlockSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralBlockSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void ProceduralBlockSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralBlockSyntax* ProceduralBlockSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralBlockSyntax>(*this);
+}
+
+bool ProceduralDeassignStatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ProceduralDeassignStatement:
+        case SyntaxKind::ProceduralReleaseStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax ProceduralDeassignStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return variable.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ProceduralDeassignStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return keyword;
+        case 3: return variable.get();
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ProceduralDeassignStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: keyword = child.token(); return;
+        case 3: variable = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ProceduralDeassignStatementSyntax* ProceduralDeassignStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ProceduralDeassignStatementSyntax>(*this);
+}
+
+bool PropertyDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PropertyDeclaration;
+}
+
+TokenOrSyntax PropertyDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return propertySpec.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PropertyDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return propertySpec.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void PropertyDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: semi = child.token(); return;
+        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 6: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
+        case 7: optionalSemi = child.token(); return;
+        case 8: end = child.token(); return;
+        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PropertyDeclarationSyntax* PropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PropertyDeclarationSyntax>(*this);
+}
+
+bool PropertySpecSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::PropertySpec;
+}
+
+TokenOrSyntax PropertySpecSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return clocking;
+        case 1: return disable;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax PropertySpecSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return clocking;
+        case 1: return disable;
+        case 2: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void PropertySpecSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: clocking = &child.node()->as<TimingControlSyntax>(); return;
+        case 1: disable = &child.node()->as<DisableIffSyntax>(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+PropertySpecSyntax* PropertySpecSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<PropertySpecSyntax>(*this);
+}
+
+bool QueueDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::QueueDimensionSpecifier;
+}
+
+TokenOrSyntax QueueDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dollar;
+        case 1: return maxSizeClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax QueueDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dollar;
+        case 1: return maxSizeClause;
+        default: return nullptr;
+    }
+}
+
+void QueueDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dollar = child.token(); return;
+        case 1: maxSizeClause = &child.node()->as<ColonExpressionClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+QueueDimensionSpecifierSyntax* QueueDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<QueueDimensionSpecifierSyntax>(*this);
+}
+
+bool RandCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RandCaseItem;
+}
+
+TokenOrSyntax RandCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return colon;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RandCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expr.get();
+        case 1: return colon;
+        case 2: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void RandCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: colon = child.token(); return;
+        case 2: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RandCaseItemSyntax* RandCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RandCaseItemSyntax>(*this);
+}
+
+bool RandCaseStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RandCaseStatement;
+}
+
+TokenOrSyntax RandCaseStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return randCase;
+        case 3: return &items;
+        case 4: return endCase;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RandCaseStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return randCase;
+        case 3: return &items;
+        case 4: return endCase;
+        default: return nullptr;
+    }
+}
+
+void RandCaseStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: randCase = child.token(); return;
+        case 3: items = child.node()->as<SyntaxList<RandCaseItemSyntax>>(); return;
+        case 4: endCase = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RandCaseStatementSyntax* RandCaseStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RandCaseStatementSyntax>(*this);
+}
+
+bool RangeCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RangeCoverageBinInitializer;
+}
+
+TokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return ranges.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return ranges.get();
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void RangeCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeCoverageBinInitializerSyntax* RangeCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeCoverageBinInitializerSyntax>(*this);
+}
+
+bool RangeDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RangeDimensionSpecifier;
+}
+
+TokenOrSyntax RangeDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return selector.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return selector.get();
+        default: return nullptr;
+    }
+}
+
+void RangeDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: selector = &child.node()->as<SelectorSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeDimensionSpecifierSyntax* RangeDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeDimensionSpecifierSyntax>(*this);
+}
+
+bool RangeSelectSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AscendingRangeSelect:
+        case SyntaxKind::DescendingRangeSelect:
+        case SyntaxKind::SimpleRangeSelect:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax RangeSelectSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return range;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RangeSelectSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return range;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void RangeSelectSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: range = child.token(); return;
+        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RangeSelectSyntax* RangeSelectSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RangeSelectSyntax>(*this);
+}
+
+bool RepeatedEventControlSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::RepeatedEventControl;
+}
+
+TokenOrSyntax RepeatedEventControlSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return repeat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        case 4: return eventControl;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax RepeatedEventControlSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return repeat;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        case 4: return eventControl;
+        default: return nullptr;
+    }
+}
+
+void RepeatedEventControlSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: repeat = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        case 4: eventControl = &child.node()->as<TimingControlSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+RepeatedEventControlSyntax* RepeatedEventControlSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<RepeatedEventControlSyntax>(*this);
+}
+
+bool ReplicatedAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ReplicatedAssignmentPattern;
+}
+
+TokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return countExpr.get();
+        case 2: return innerOpenBrace;
+        case 3: return &items;
+        case 4: return innerCloseBrace;
+        case 5: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return countExpr.get();
+        case 2: return innerOpenBrace;
+        case 3: return &items;
+        case 4: return innerCloseBrace;
+        case 5: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void ReplicatedAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: countExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 2: innerOpenBrace = child.token(); return;
+        case 3: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 4: innerCloseBrace = child.token(); return;
+        case 5: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ReplicatedAssignmentPatternSyntax* ReplicatedAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ReplicatedAssignmentPatternSyntax>(*this);
+}
+
+bool ReturnStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ReturnStatement;
+}
+
+TokenOrSyntax ReturnStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return returnKeyword;
+        case 3: return returnValue;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ReturnStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return returnKeyword;
+        case 3: return returnValue;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void ReturnStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: returnKeyword = child.token(); return;
+        case 3: returnValue = &child.node()->as<ExpressionSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ReturnStatementSyntax* ReturnStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ReturnStatementSyntax>(*this);
+}
+
+bool ScopedNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ScopedName;
+}
+
+TokenOrSyntax ScopedNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ScopedNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return separator;
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void ScopedNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<NameSyntax>(); return;
+        case 1: separator = child.token(); return;
+        case 2: right = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ScopedNameSyntax* ScopedNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ScopedNameSyntax>(*this);
+}
+
+bool SelectorSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AscendingRangeSelect:
+        case SyntaxKind::BitSelect:
+        case SyntaxKind::DescendingRangeSelect:
+        case SyntaxKind::SimpleRangeSelect:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool SequenceDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SequenceDeclaration;
+}
+
+TokenOrSyntax SequenceDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return seqExpr.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SequenceDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return name;
+        case 3: return portList;
+        case 4: return semi;
+        case 5: return &assertionVariables;
+        case 6: return seqExpr.get();
+        case 7: return optionalSemi;
+        case 8: return end;
+        case 9: return endBlockName;
+        default: return nullptr;
+    }
+}
+
+void SequenceDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
+        case 4: semi = child.token(); return;
+        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
+        case 6: seqExpr = &child.node()->as<ExpressionSyntax>(); return;
+        case 7: optionalSemi = child.token(); return;
+        case 8: end = child.token(); return;
+        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SequenceDeclarationSyntax* SequenceDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SequenceDeclarationSyntax>(*this);
+}
+
+bool ShortcutCycleDelayRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::ShortcutCycleDelayRange;
+}
+
+TokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return doubleHash;
+        case 1: return openBracket;
+        case 2: return op;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return doubleHash;
+        case 1: return openBracket;
+        case 2: return op;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void ShortcutCycleDelayRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: doubleHash = child.token(); return;
+        case 1: openBracket = child.token(); return;
+        case 2: op = child.token(); return;
+        case 3: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+ShortcutCycleDelayRangeSyntax* ShortcutCycleDelayRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<ShortcutCycleDelayRangeSyntax>(*this);
+}
+
+bool SignalEventExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SignalEventExpression;
+}
+
+TokenOrSyntax SignalEventExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return edge;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SignalEventExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return edge;
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void SignalEventExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: edge = child.token(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SignalEventExpressionSyntax* SignalEventExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SignalEventExpressionSyntax>(*this);
+}
+
+bool SignedCastExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SignedCastExpression;
+}
+
+TokenOrSyntax SignedCastExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return signing;
+        case 1: return apostrophe;
+        case 2: return inner.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SignedCastExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return signing;
+        case 1: return apostrophe;
+        case 2: return inner.get();
+        default: return nullptr;
+    }
+}
+
+void SignedCastExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: signing = child.token(); return;
+        case 1: apostrophe = child.token(); return;
+        case 2: inner = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SignedCastExpressionSyntax* SignedCastExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SignedCastExpressionSyntax>(*this);
+}
+
+bool SimpleAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SimpleAssignmentPattern;
+}
+
+TokenOrSyntax SimpleAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimpleAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void SimpleAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimpleAssignmentPatternSyntax* SimpleAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimpleAssignmentPatternSyntax>(*this);
+}
+
+bool SimpleDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CellDefineDirective:
+        case SyntaxKind::EndCellDefineDirective:
+        case SyntaxKind::EndKeywordsDirective:
+        case SyntaxKind::NoUnconnectedDriveDirective:
+        case SyntaxKind::ResetAllDirective:
+        case SyntaxKind::UndefineAllDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax SimpleDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimpleDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        default: return nullptr;
+    }
+}
+
+void SimpleDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimpleDirectiveSyntax* SimpleDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimpleDirectiveSyntax>(*this);
+}
+
+bool SimplePragmaExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SimplePragmaExpression;
+}
+
+TokenOrSyntax SimplePragmaExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return value;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SimplePragmaExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return value;
+        default: return nullptr;
+    }
+}
+
+void SimplePragmaExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: value = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SimplePragmaExpressionSyntax* SimplePragmaExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SimplePragmaExpressionSyntax>(*this);
+}
+
+bool SolveBeforeConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SolveBeforeConstraint;
+}
+
+TokenOrSyntax SolveBeforeConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return solve;
+        case 1: return &beforeExpr;
+        case 2: return before;
+        case 3: return &afterExpr;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SolveBeforeConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return solve;
+        case 1: return &beforeExpr;
+        case 2: return before;
+        case 3: return &afterExpr;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void SolveBeforeConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: solve = child.token(); return;
+        case 1: beforeExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 2: before = child.token(); return;
+        case 3: afterExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SolveBeforeConstraintSyntax* SolveBeforeConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SolveBeforeConstraintSyntax>(*this);
+}
+
+bool StandardCaseItemSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StandardCaseItem;
+}
+
+TokenOrSyntax StandardCaseItemSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &expressions;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StandardCaseItemSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &expressions;
+        case 1: return colon;
+        case 2: return clause.get();
+        default: return nullptr;
+    }
+}
+
+void StandardCaseItemSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 1: colon = child.token(); return;
+        case 2: clause = &child.node()->as<SyntaxNode>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StandardCaseItemSyntax* StandardCaseItemSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StandardCaseItemSyntax>(*this);
+}
+
+bool StatementSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AssertPropertyStatement:
+        case SyntaxKind::AssumePropertyStatement:
+        case SyntaxKind::BlockingEventTriggerStatement:
+        case SyntaxKind::CaseStatement:
+        case SyntaxKind::ConditionalStatement:
+        case SyntaxKind::CoverPropertyStatement:
+        case SyntaxKind::CoverSequenceStatement:
+        case SyntaxKind::DisableForkStatement:
+        case SyntaxKind::DisableStatement:
+        case SyntaxKind::DoWhileStatement:
+        case SyntaxKind::EmptyStatement:
+        case SyntaxKind::ExpectPropertyStatement:
+        case SyntaxKind::ExpressionStatement:
+        case SyntaxKind::ForLoopStatement:
+        case SyntaxKind::ForeachLoopStatement:
+        case SyntaxKind::ForeverStatement:
+        case SyntaxKind::ImmediateAssertStatement:
+        case SyntaxKind::ImmediateAssumeStatement:
+        case SyntaxKind::ImmediateCoverStatement:
+        case SyntaxKind::JumpStatement:
+        case SyntaxKind::LoopStatement:
+        case SyntaxKind::NonblockingEventTriggerStatement:
+        case SyntaxKind::ParallelBlockStatement:
+        case SyntaxKind::ProceduralAssignStatement:
+        case SyntaxKind::ProceduralDeassignStatement:
+        case SyntaxKind::ProceduralForceStatement:
+        case SyntaxKind::ProceduralReleaseStatement:
+        case SyntaxKind::RandCaseStatement:
+        case SyntaxKind::RestrictPropertyStatement:
+        case SyntaxKind::ReturnStatement:
+        case SyntaxKind::SequentialBlockStatement:
+        case SyntaxKind::TimingControlStatement:
+        case SyntaxKind::VoidCastedCallStatement:
+        case SyntaxKind::WaitForkStatement:
+        case SyntaxKind::WaitOrderStatement:
+        case SyntaxKind::WaitStatement:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax StatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        default: return nullptr;
+    }
+}
+
+void StatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StatementSyntax* StatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StatementSyntax>(*this);
+}
+
+bool StreamExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamExpression;
+}
+
+TokenOrSyntax StreamExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return expression.get();
+        case 1: return withRange;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return expression.get();
+        case 1: return withRange;
+        default: return nullptr;
+    }
+}
+
+void StreamExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: expression = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: withRange = &child.node()->as<StreamExpressionWithRangeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamExpressionSyntax* StreamExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamExpressionSyntax>(*this);
+}
+
+bool StreamExpressionWithRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamExpressionWithRange;
+}
+
+TokenOrSyntax StreamExpressionWithRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return withKeyword;
+        case 1: return range.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamExpressionWithRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return withKeyword;
+        case 1: return range.get();
+        default: return nullptr;
+    }
+}
+
+void StreamExpressionWithRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: withKeyword = child.token(); return;
+        case 1: range = &child.node()->as<ElementSelectSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamExpressionWithRangeSyntax* StreamExpressionWithRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamExpressionWithRangeSyntax>(*this);
+}
+
+bool StreamingConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StreamingConcatenationExpression;
+}
+
+TokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return operatorToken;
+        case 2: return sliceSize;
+        case 3: return innerOpenBrace;
+        case 4: return &expressions;
+        case 5: return innerCloseBrace;
+        case 6: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return operatorToken;
+        case 2: return sliceSize;
+        case 3: return innerOpenBrace;
+        case 4: return &expressions;
+        case 5: return innerCloseBrace;
+        case 6: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StreamingConcatenationExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: operatorToken = child.token(); return;
+        case 2: sliceSize = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: innerOpenBrace = child.token(); return;
+        case 4: expressions = child.node()->as<SeparatedSyntaxList<StreamExpressionSyntax>>(); return;
+        case 5: innerCloseBrace = child.token(); return;
+        case 6: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StreamingConcatenationExpressionSyntax* StreamingConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StreamingConcatenationExpressionSyntax>(*this);
+}
+
+bool StructUnionMemberSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructUnionMember;
+}
+
+TokenOrSyntax StructUnionMemberSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return randomQualifier;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructUnionMemberSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return randomQualifier;
+        case 2: return type.get();
+        case 3: return &declarators;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void StructUnionMemberSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: randomQualifier = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: declarators = child.node()->as<SeparatedSyntaxList<DeclaratorSyntax>>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructUnionMemberSyntax* StructUnionMemberSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructUnionMemberSyntax>(*this);
+}
+
+bool StructUnionTypeSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::StructType:
+        case SyntaxKind::UnionType:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax StructUnionTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return tagged;
+        case 2: return packed;
+        case 3: return signing;
+        case 4: return openBrace;
+        case 5: return &members;
+        case 6: return closeBrace;
+        case 7: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructUnionTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return tagged;
+        case 2: return packed;
+        case 3: return signing;
+        case 4: return openBrace;
+        case 5: return &members;
+        case 6: return closeBrace;
+        case 7: return &dimensions;
+        default: return nullptr;
+    }
+}
+
+void StructUnionTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: tagged = child.token(); return;
+        case 2: packed = child.token(); return;
+        case 3: signing = child.token(); return;
+        case 4: openBrace = child.token(); return;
+        case 5: members = child.node()->as<SyntaxList<StructUnionMemberSyntax>>(); return;
+        case 6: closeBrace = child.token(); return;
+        case 7: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructUnionTypeSyntax* StructUnionTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructUnionTypeSyntax>(*this);
+}
+
+bool StructurePatternMemberSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::NamedStructurePatternMember:
+        case SyntaxKind::OrderedStructurePatternMember:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool StructurePatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructurePattern;
+}
+
+TokenOrSyntax StructurePatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &members;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructurePatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &members;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StructurePatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: members = child.node()->as<SeparatedSyntaxList<StructurePatternMemberSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructurePatternSyntax* StructurePatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructurePatternSyntax>(*this);
+}
+
+bool StructuredAssignmentPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::StructuredAssignmentPattern;
+}
+
+TokenOrSyntax StructuredAssignmentPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax StructuredAssignmentPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBrace;
+        case 1: return &items;
+        case 2: return closeBrace;
+        default: return nullptr;
+    }
+}
+
+void StructuredAssignmentPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBrace = child.token(); return;
+        case 1: items = child.node()->as<SeparatedSyntaxList<AssignmentPatternItemSyntax>>(); return;
+        case 2: closeBrace = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+StructuredAssignmentPatternSyntax* StructuredAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<StructuredAssignmentPatternSyntax>(*this);
+}
+
+bool SystemNameSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::SystemName;
+}
+
+TokenOrSyntax SystemNameSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return systemIdentifier;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax SystemNameSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return systemIdentifier;
+        default: return nullptr;
+    }
+}
+
+void SystemNameSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: systemIdentifier = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+SystemNameSyntax* SystemNameSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<SystemNameSyntax>(*this);
+}
+
+bool TaggedPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TaggedPattern;
+}
+
+TokenOrSyntax TaggedPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return memberName;
+        case 2: return pattern;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TaggedPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return memberName;
+        case 2: return pattern;
+        default: return nullptr;
+    }
+}
+
+void TaggedPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tagged = child.token(); return;
+        case 1: memberName = child.token(); return;
+        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TaggedPatternSyntax* TaggedPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TaggedPatternSyntax>(*this);
+}
+
+bool TaggedUnionExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TaggedUnionExpression;
+}
+
+TokenOrSyntax TaggedUnionExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return member;
+        case 2: return expr;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TaggedUnionExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return tagged;
+        case 1: return member;
+        case 2: return expr;
+        default: return nullptr;
+    }
+}
+
+void TaggedUnionExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: tagged = child.token(); return;
+        case 1: member = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TaggedUnionExpressionSyntax* TaggedUnionExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TaggedUnionExpressionSyntax>(*this);
+}
+
+bool TimeScaleDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimeScaleDirective;
+}
+
+TokenOrSyntax TimeScaleDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return timeUnit;
+        case 2: return slash;
+        case 3: return timePrecision;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimeScaleDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return timeUnit;
+        case 2: return slash;
+        case 3: return timePrecision;
+        default: return nullptr;
+    }
+}
+
+void TimeScaleDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: timeUnit = child.token(); return;
+        case 2: slash = child.token(); return;
+        case 3: timePrecision = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimeScaleDirectiveSyntax* TimeScaleDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimeScaleDirectiveSyntax>(*this);
+}
+
+bool TimeUnitsDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimeUnitsDeclaration;
+}
+
+TokenOrSyntax TimeUnitsDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return time;
+        case 3: return divider;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimeUnitsDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return keyword;
+        case 2: return time;
+        case 3: return divider;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void TimeUnitsDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: keyword = child.token(); return;
+        case 2: time = child.token(); return;
+        case 3: divider = &child.node()->as<DividerClauseSyntax>(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimeUnitsDeclarationSyntax* TimeUnitsDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimeUnitsDeclarationSyntax>(*this);
+}
+
+bool TimingControlExpressionConcatenationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlExpressionConcatenation;
+}
+
+TokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return timing.get();
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return left.get();
+        case 1: return timing.get();
+        case 2: return right.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlExpressionConcatenationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
+        case 1: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlExpressionConcatenationSyntax* TimingControlExpressionConcatenationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlExpressionConcatenationSyntax>(*this);
+}
+
+bool TimingControlExpressionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlExpression;
+}
+
+TokenOrSyntax TimingControlExpressionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return timing.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlExpressionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return timing.get();
+        case 1: return expr.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlExpressionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: timing = &child.node()->as<TimingControlSyntax>(); return;
+        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlExpressionSyntax* TimingControlExpressionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlExpressionSyntax>(*this);
+}
+
+bool TimingControlStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TimingControlStatement;
+}
+
+TokenOrSyntax TimingControlStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return timingControl.get();
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TimingControlStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return timingControl.get();
+        case 3: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void TimingControlStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: timingControl = &child.node()->as<TimingControlSyntax>(); return;
+        case 3: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TimingControlStatementSyntax* TimingControlStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TimingControlStatementSyntax>(*this);
+}
+
+bool TimingControlSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::CycleDelay:
+        case SyntaxKind::Delay3:
+        case SyntaxKind::DelayControl:
+        case SyntaxKind::EventControl:
+        case SyntaxKind::EventControlWithExpression:
+        case SyntaxKind::ImplicitEventControl:
+        case SyntaxKind::RepeatedEventControl:
+        case SyntaxKind::ShortcutCycleDelayRange:
+            return true;
+        default:
+            return false;
+    }
+}
+
+bool TransListCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransListCoverageBinInitializer;
+}
+
+TokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &sets;
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &sets;
+        case 1: return withClause;
+        default: return nullptr;
+    }
+}
+
+void TransListCoverageBinInitializerSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: sets = child.node()->as<SeparatedSyntaxList<TransSetSyntax>>(); return;
+        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransListCoverageBinInitializerSyntax* TransListCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransListCoverageBinInitializerSyntax>(*this);
+}
+
+bool TransRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransRange;
+}
+
+TokenOrSyntax TransRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &items;
+        case 1: return repeat;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &items;
+        case 1: return repeat;
+        default: return nullptr;
+    }
+}
+
+void TransRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
+        case 1: repeat = &child.node()->as<TransRepeatRangeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransRangeSyntax* TransRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransRangeSyntax>(*this);
+}
+
+bool TransRepeatRangeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransRepeatRange;
+}
+
+TokenOrSyntax TransRepeatRangeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return selector;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransRepeatRangeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return selector;
+        case 3: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void TransRepeatRangeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: specifier = child.token(); return;
+        case 2: selector = &child.node()->as<SelectorSyntax>(); return;
+        case 3: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransRepeatRangeSyntax* TransRepeatRangeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransRepeatRangeSyntax>(*this);
+}
+
+bool TransSetSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TransSet;
+}
+
+TokenOrSyntax TransSetSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ranges;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TransSetSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return &ranges;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void TransSetSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: ranges = child.node()->as<SeparatedSyntaxList<TransRangeSyntax>>(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TransSetSyntax* TransSetSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TransSetSyntax>(*this);
+}
+
+bool TypeAssignmentSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeAssignment;
+}
+
+TokenOrSyntax TypeAssignmentSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return name;
+        case 1: return assignment;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeAssignmentSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return name;
+        case 1: return assignment;
+        default: return nullptr;
+    }
+}
+
+void TypeAssignmentSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: name = child.token(); return;
+        case 1: assignment = &child.node()->as<EqualsTypeClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeAssignmentSyntax* TypeAssignmentSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeAssignmentSyntax>(*this);
+}
+
+bool TypeParameterDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeParameterDeclaration;
+}
+
+TokenOrSyntax TypeParameterDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return typeKeyword;
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeParameterDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return keyword;
+        case 1: return typeKeyword;
+        case 2: return &declarators;
+        default: return nullptr;
+    }
+}
+
+void TypeParameterDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: keyword = child.token(); return;
+        case 1: typeKeyword = child.token(); return;
+        case 2: declarators = child.node()->as<SeparatedSyntaxList<TypeAssignmentSyntax>>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeParameterDeclarationSyntax* TypeParameterDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeParameterDeclarationSyntax>(*this);
+}
+
+bool TypeReferenceSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypeReference;
+}
+
+TokenOrSyntax TypeReferenceSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return typeKeyword;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypeReferenceSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return typeKeyword;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void TypeReferenceSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: typeKeyword = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypeReferenceSyntax* TypeReferenceSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypeReferenceSyntax>(*this);
+}
+
+bool TypedefDeclarationSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::TypedefDeclaration;
+}
+
+TokenOrSyntax TypedefDeclarationSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return &dimensions;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax TypedefDeclarationSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return typedefKeyword;
+        case 2: return type.get();
+        case 3: return name;
+        case 4: return &dimensions;
+        case 5: return semi;
+        default: return nullptr;
+    }
+}
+
+void TypedefDeclarationSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: typedefKeyword = child.token(); return;
+        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
+        case 3: name = child.token(); return;
+        case 4: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
+        case 5: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+TypedefDeclarationSyntax* TypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<TypedefDeclarationSyntax>(*this);
+}
+
+bool UnconditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::ElseDirective:
+        case SyntaxKind::EndIfDirective:
+            return true;
+        default:
+            return false;
+    }
+}
+
+TokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return &disabledTokens;
+        default: return nullptr;
+    }
+}
+
+void UnconditionalBranchDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: disabledTokens = child.node()->as<TokenList>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UnconditionalBranchDirectiveSyntax* UnconditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UnconditionalBranchDirectiveSyntax>(*this);
+}
+
+bool UnconnectedDriveDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UnconnectedDriveDirective;
+}
+
+TokenOrSyntax UnconnectedDriveDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return strength;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UnconnectedDriveDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return strength;
+        default: return nullptr;
+    }
+}
+
+void UnconnectedDriveDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: strength = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UnconnectedDriveDirectiveSyntax* UnconnectedDriveDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UnconnectedDriveDirectiveSyntax>(*this);
+}
+
+bool UndefDirectiveSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UndefDirective;
+}
+
+TokenOrSyntax UndefDirectiveSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UndefDirectiveSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return directive;
+        case 1: return name;
+        default: return nullptr;
+    }
+}
+
+void UndefDirectiveSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: directive = child.token(); return;
+        case 1: name = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UndefDirectiveSyntax* UndefDirectiveSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UndefDirectiveSyntax>(*this);
+}
+
+bool UniquenessConstraintSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::UniquenessConstraint;
+}
+
+TokenOrSyntax UniquenessConstraintSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return unique;
+        case 1: return ranges.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax UniquenessConstraintSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return unique;
+        case 1: return ranges.get();
+        case 2: return semi;
+        default: return nullptr;
+    }
+}
+
+void UniquenessConstraintSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: unique = child.token(); return;
+        case 1: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
+        case 2: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+UniquenessConstraintSyntax* UniquenessConstraintSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<UniquenessConstraintSyntax>(*this);
+}
+
+bool VariableDimensionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariableDimension;
+}
+
+TokenOrSyntax VariableDimensionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariableDimensionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openBracket;
+        case 1: return specifier;
+        case 2: return closeBracket;
+        default: return nullptr;
+    }
+}
+
+void VariableDimensionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openBracket = child.token(); return;
+        case 1: specifier = &child.node()->as<DimensionSpecifierSyntax>(); return;
+        case 2: closeBracket = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariableDimensionSyntax* VariableDimensionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariableDimensionSyntax>(*this);
+}
+
+bool VariablePatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariablePattern;
+}
+
+TokenOrSyntax VariablePatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dot;
+        case 1: return variableName;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariablePatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dot;
+        case 1: return variableName;
+        default: return nullptr;
+    }
+}
+
+void VariablePatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dot = child.token(); return;
+        case 1: variableName = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariablePatternSyntax* VariablePatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariablePatternSyntax>(*this);
+}
+
+bool VariablePortHeaderSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VariablePortHeader;
+}
+
+TokenOrSyntax VariablePortHeaderSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return direction;
+        case 1: return varKeyword;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VariablePortHeaderSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return direction;
+        case 1: return varKeyword;
+        case 2: return dataType.get();
+        default: return nullptr;
+    }
+}
+
+void VariablePortHeaderSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: direction = child.token(); return;
+        case 1: varKeyword = child.token(); return;
+        case 2: dataType = &child.node()->as<DataTypeSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VariablePortHeaderSyntax* VariablePortHeaderSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VariablePortHeaderSyntax>(*this);
+}
+
+bool VirtualInterfaceTypeSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VirtualInterfaceType;
+}
+
+TokenOrSyntax VirtualInterfaceTypeSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return virtualKeyword;
+        case 1: return interfaceKeyword;
+        case 2: return name;
+        case 3: return parameters;
+        case 4: return modport;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VirtualInterfaceTypeSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return virtualKeyword;
+        case 1: return interfaceKeyword;
+        case 2: return name;
+        case 3: return parameters;
+        case 4: return modport;
+        default: return nullptr;
+    }
+}
+
+void VirtualInterfaceTypeSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: virtualKeyword = child.token(); return;
+        case 1: interfaceKeyword = child.token(); return;
+        case 2: name = child.token(); return;
+        case 3: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
+        case 4: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VirtualInterfaceTypeSyntax* VirtualInterfaceTypeSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VirtualInterfaceTypeSyntax>(*this);
+}
+
+bool VoidCastedCallStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::VoidCastedCallStatement;
+}
+
+TokenOrSyntax VoidCastedCallStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return voidKeyword;
+        case 3: return apostrophe;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax VoidCastedCallStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return voidKeyword;
+        case 3: return apostrophe;
+        case 4: return openParen;
+        case 5: return expr.get();
+        case 6: return closeParen;
+        case 7: return semi;
+        default: return nullptr;
+    }
+}
+
+void VoidCastedCallStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: voidKeyword = child.token(); return;
+        case 3: apostrophe = child.token(); return;
+        case 4: openParen = child.token(); return;
+        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 6: closeParen = child.token(); return;
+        case 7: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+VoidCastedCallStatementSyntax* VoidCastedCallStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<VoidCastedCallStatementSyntax>(*this);
+}
+
+bool WaitForkStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitForkStatement;
+}
+
+TokenOrSyntax WaitForkStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitForkStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return fork;
+        case 4: return semi;
+        default: return nullptr;
+    }
+}
+
+void WaitForkStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait = child.token(); return;
+        case 3: fork = child.token(); return;
+        case 4: semi = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitForkStatementSyntax* WaitForkStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitForkStatementSyntax>(*this);
+}
+
+bool WaitOrderStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitOrderStatement;
+}
+
+TokenOrSyntax WaitOrderStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait_order;
+        case 3: return openParen;
+        case 4: return &names;
+        case 5: return closeParen;
+        case 6: return action.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitOrderStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait_order;
+        case 3: return openParen;
+        case 4: return &names;
+        case 5: return closeParen;
+        case 6: return action.get();
+        default: return nullptr;
+    }
+}
+
+void WaitOrderStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait_order = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: names = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: action = &child.node()->as<ActionBlockSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitOrderStatementSyntax* WaitOrderStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitOrderStatementSyntax>(*this);
+}
+
+bool WaitStatementSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WaitStatement;
+}
+
+TokenOrSyntax WaitStatementSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WaitStatementSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return label;
+        case 1: return &attributes;
+        case 2: return wait;
+        case 3: return openParen;
+        case 4: return expr.get();
+        case 5: return closeParen;
+        case 6: return statement.get();
+        default: return nullptr;
+    }
+}
+
+void WaitStatementSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
+        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 2: wait = child.token(); return;
+        case 3: openParen = child.token(); return;
+        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 5: closeParen = child.token(); return;
+        case 6: statement = &child.node()->as<StatementSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WaitStatementSyntax* WaitStatementSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WaitStatementSyntax>(*this);
+}
+
+bool WildcardDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardDimensionSpecifier;
+}
+
+TokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return star;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return star;
+        default: return nullptr;
+    }
+}
+
+void WildcardDimensionSpecifierSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: star = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardDimensionSpecifierSyntax* WildcardDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardDimensionSpecifierSyntax>(*this);
+}
+
+bool WildcardPatternSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPattern;
+}
+
+TokenOrSyntax WildcardPatternSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return dotStar;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPatternSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return dotStar;
+        default: return nullptr;
+    }
+}
+
+void WildcardPatternSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: dotStar = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPatternSyntax* WildcardPatternSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPatternSyntax>(*this);
+}
+
+bool WildcardPortConnectionSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPortConnection;
+}
+
+TokenOrSyntax WildcardPortConnectionSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dotStar;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPortConnectionSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return &attributes;
+        case 1: return dotStar;
+        default: return nullptr;
+    }
+}
+
+void WildcardPortConnectionSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
+        case 1: dotStar = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPortConnectionSyntax* WildcardPortConnectionSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPortConnectionSyntax>(*this);
+}
+
+bool WildcardPortListSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WildcardPortList;
+}
+
+TokenOrSyntax WildcardPortListSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WildcardPortListSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return openParen;
+        case 1: return dotStar;
+        case 2: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void WildcardPortListSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: openParen = child.token(); return;
+        case 1: dotStar = child.token(); return;
+        case 2: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WildcardPortListSyntax* WildcardPortListSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WildcardPortListSyntax>(*this);
+}
+
+bool WithClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithClause;
+}
+
+TokenOrSyntax WithClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return openParen;
+        case 2: return expr.get();
+        case 3: return closeParen;
+        default: return nullptr;
+    }
+}
+
+void WithClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: openParen = child.token(); return;
+        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
+        case 3: closeParen = child.token(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithClauseSyntax* WithClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithClauseSyntax>(*this);
+}
+
+bool WithFunctionClauseSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithFunctionClause;
+}
+
+TokenOrSyntax WithFunctionClauseSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithFunctionClauseSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return name.get();
+        default: return nullptr;
+    }
+}
+
+void WithFunctionClauseSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: name = &child.node()->as<NameSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithFunctionClauseSyntax* WithFunctionClauseSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithFunctionClauseSyntax>(*this);
+}
+
+bool WithFunctionSampleSyntax::isKind(SyntaxKind kind) {
+    return kind == SyntaxKind::WithFunctionSample;
+}
+
+TokenOrSyntax WithFunctionSampleSyntax::getChild(size_t index) {
+    switch (index) {
+        case 0: return with;
+        case 1: return function;
+        case 2: return sample;
+        case 3: return portList.get();
+        default: return nullptr;
+    }
+}
+
+ConstTokenOrSyntax WithFunctionSampleSyntax::getChild(size_t index) const {
+    switch (index) {
+        case 0: return with;
+        case 1: return function;
+        case 2: return sample;
+        case 3: return portList.get();
+        default: return nullptr;
+    }
+}
+
+void WithFunctionSampleSyntax::setChild(size_t index, TokenOrSyntax child) {
+    switch (index) {
+        case 0: with = child.token(); return;
+        case 1: function = child.token(); return;
+        case 2: sample = child.token(); return;
+        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
+        default: THROW_UNREACHABLE;
+    }
+}
+
+WithFunctionSampleSyntax* WithFunctionSampleSyntax::clone(BumpAllocator& alloc) const {
+    return alloc.emplace<WithFunctionSampleSyntax>(*this);
+}
+
+ActionBlockSyntax& SyntaxFactory::actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<ActionBlockSyntax>(statement, elseClause);
+}
+
+AnsiPortListSyntax& SyntaxFactory::ansiPortList(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<AnsiPortListSyntax>(openParen, ports, closeParen);
+}
+
+ArgumentListSyntax& SyntaxFactory::argumentList(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen) {
+    return *alloc.emplace<ArgumentListSyntax>(openParen, parameters, closeParen);
+}
+
+ArrayOrRandomizeMethodExpressionSyntax& SyntaxFactory::arrayOrRandomizeMethodExpression(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints) {
+    return *alloc.emplace<ArrayOrRandomizeMethodExpressionSyntax>(method, with, args, constraints);
+}
+
+AssertionItemPortListSyntax& SyntaxFactory::assertionItemPortList(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<AssertionItemPortListSyntax>(openParen, ports, closeParen);
+}
+
+AssertionItemPortSyntax& SyntaxFactory::assertionItemPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<AssertionItemPortSyntax>(attributes, local, direction, type, declarator);
+}
+
+AssignmentPatternExpressionSyntax& SyntaxFactory::assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) {
+    return *alloc.emplace<AssignmentPatternExpressionSyntax>(type, pattern);
+}
+
+AssignmentPatternItemSyntax& SyntaxFactory::assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) {
+    return *alloc.emplace<AssignmentPatternItemSyntax>(key, colon, expr);
+}
+
+AttributeInstanceSyntax& SyntaxFactory::attributeInstance(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen) {
+    return *alloc.emplace<AttributeInstanceSyntax>(openParen, specs, closeParen);
+}
+
+AttributeSpecSyntax& SyntaxFactory::attributeSpec(Token name, EqualsValueClauseSyntax* value) {
+    return *alloc.emplace<AttributeSpecSyntax>(name, value);
+}
+
+BadExpressionSyntax& SyntaxFactory::badExpression(ExpressionSyntax& expr) {
+    return *alloc.emplace<BadExpressionSyntax>(expr);
+}
+
+BeginKeywordsDirectiveSyntax& SyntaxFactory::beginKeywordsDirective(Token directive, Token versionSpecifier) {
+    return *alloc.emplace<BeginKeywordsDirectiveSyntax>(directive, versionSpecifier);
+}
+
+BinaryBlockEventExpressionSyntax& SyntaxFactory::binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) {
+    return *alloc.emplace<BinaryBlockEventExpressionSyntax>(left, orKeyword, right);
+}
+
+BinaryEventExpressionSyntax& SyntaxFactory::binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) {
+    return *alloc.emplace<BinaryEventExpressionSyntax>(left, operatorToken, right);
+}
+
+BinaryExpressionSyntax& SyntaxFactory::binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right) {
+    return *alloc.emplace<BinaryExpressionSyntax>(kind, left, operatorToken, attributes, right);
+}
+
+BitSelectSyntax& SyntaxFactory::bitSelect(ExpressionSyntax& expr) {
+    return *alloc.emplace<BitSelectSyntax>(expr);
+}
+
+BlockCoverageEventSyntax& SyntaxFactory::blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<BlockCoverageEventSyntax>(atat, openParen, expr, closeParen);
+}
+
+BlockStatementSyntax& SyntaxFactory::blockStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<BlockStatementSyntax>(kind, label, attributes, begin, blockName, items, end, endBlockName);
+}
+
+CaseGenerateSyntax& SyntaxFactory::caseGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase) {
+    return *alloc.emplace<CaseGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, items, endCase);
+}
+
+CaseStatementSyntax& SyntaxFactory::caseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase) {
+    return *alloc.emplace<CaseStatementSyntax>(label, attributes, uniqueOrPriority, caseKeyword, openParen, expr, closeParen, matchesOrInside, items, endcase);
+}
+
+CastExpressionSyntax& SyntaxFactory::castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) {
+    return *alloc.emplace<CastExpressionSyntax>(left, apostrophe, right);
+}
+
+ChargeStrengthSyntax& SyntaxFactory::chargeStrength(Token openParen, Token strength, Token closeParen) {
+    return *alloc.emplace<ChargeStrengthSyntax>(openParen, strength, closeParen);
+}
+
+ClassDeclarationSyntax& SyntaxFactory::classDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<ClassDeclarationSyntax>(attributes, virtualOrInterface, classKeyword, lifetime, name, parameters, extendsClause, implementsClause, semi, items, endClass, endBlockName);
+}
+
+ClassMethodDeclarationSyntax& SyntaxFactory::classMethodDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration) {
+    return *alloc.emplace<ClassMethodDeclarationSyntax>(attributes, qualifiers, declaration);
+}
+
+ClassMethodPrototypeSyntax& SyntaxFactory::classMethodPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi) {
+    return *alloc.emplace<ClassMethodPrototypeSyntax>(attributes, qualifiers, prototype, semi);
+}
+
+ClassNameSyntax& SyntaxFactory::className(Token identifier, ParameterValueAssignmentSyntax& parameters) {
+    return *alloc.emplace<ClassNameSyntax>(identifier, parameters);
+}
+
+ClassPropertyDeclarationSyntax& SyntaxFactory::classPropertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration) {
+    return *alloc.emplace<ClassPropertyDeclarationSyntax>(attributes, qualifiers, declaration);
+}
+
+ClassScopeSyntax& SyntaxFactory::classScope(NameSyntax& left, Token separator) {
+    return *alloc.emplace<ClassScopeSyntax>(left, separator);
+}
+
+ClockingDeclarationSyntax& SyntaxFactory::clockingDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, const SyntaxList<ClockingItemSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<ClockingDeclarationSyntax>(attributes, globalOrDefault, clocking, blockName, at, event, eventIdentifier, semi, items, endClocking, endBlockName);
+}
+
+ClockingDirectionSyntax& SyntaxFactory::clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) {
+    return *alloc.emplace<ClockingDirectionSyntax>(input, inputSkew, output, ouputSkew, inout);
+}
+
+ClockingItemSyntax& SyntaxFactory::clockingItem(Token defaultKeyword, ClockingDirectionSyntax* direction, const SeparatedSyntaxList<AttributeSpecSyntax>& assignments, Token semi, MemberSyntax* declaration) {
+    return *alloc.emplace<ClockingItemSyntax>(defaultKeyword, direction, assignments, semi, declaration);
+}
+
+ClockingSkewSyntax& SyntaxFactory::clockingSkew(Token edge, Token hash, ExpressionSyntax* value) {
+    return *alloc.emplace<ClockingSkewSyntax>(edge, hash, value);
+}
+
+ColonExpressionClauseSyntax& SyntaxFactory::colonExpressionClause(Token colon, ExpressionSyntax& expr) {
+    return *alloc.emplace<ColonExpressionClauseSyntax>(colon, expr);
+}
+
+CompilationUnitSyntax& SyntaxFactory::compilationUnit(const SyntaxList<MemberSyntax>& members, Token endOfFile) {
+    return *alloc.emplace<CompilationUnitSyntax>(members, endOfFile);
+}
+
+ConcatenationExpressionSyntax& SyntaxFactory::concatenationExpression(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace) {
+    return *alloc.emplace<ConcatenationExpressionSyntax>(openBrace, expressions, closeBrace);
+}
+
+ConcurrentAssertionMemberSyntax& SyntaxFactory::concurrentAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement) {
+    return *alloc.emplace<ConcurrentAssertionMemberSyntax>(attributes, statement);
+}
+
+ConcurrentAssertionStatementSyntax& SyntaxFactory::concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) {
+    return *alloc.emplace<ConcurrentAssertionStatementSyntax>(kind, label, attributes, keyword, propertyOrSequence, openParen, propertySpec, closeParen, action);
+}
+
+ConditionalBranchDirectiveSyntax& SyntaxFactory::conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens) {
+    return *alloc.emplace<ConditionalBranchDirectiveSyntax>(kind, directive, name, disabledTokens);
+}
+
+ConditionalConstraintSyntax& SyntaxFactory::conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) {
+    return *alloc.emplace<ConditionalConstraintSyntax>(ifKeyword, openParen, condition, closeParen, constraints, elseClause);
+}
+
+ConditionalExpressionSyntax& SyntaxFactory::conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) {
+    return *alloc.emplace<ConditionalExpressionSyntax>(predicate, question, attributes, left, colon, right);
+}
+
+ConditionalPatternSyntax& SyntaxFactory::conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) {
+    return *alloc.emplace<ConditionalPatternSyntax>(expr, matchesClause);
+}
+
+ConditionalPredicateSyntax& SyntaxFactory::conditionalPredicate(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions) {
+    return *alloc.emplace<ConditionalPredicateSyntax>(conditions);
+}
+
+ConditionalStatementSyntax& SyntaxFactory::conditionalStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<ConditionalStatementSyntax>(label, attributes, uniqueOrPriority, ifKeyword, openParen, predicate, closeParen, statement, elseClause);
+}
+
+ConstraintBlockSyntax& SyntaxFactory::constraintBlock(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<ConstraintBlockSyntax>(openBrace, items, closeBrace);
+}
+
+ConstraintDeclarationSyntax& SyntaxFactory::constraintDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) {
+    return *alloc.emplace<ConstraintDeclarationSyntax>(attributes, qualifiers, keyword, name, block);
+}
+
+ConstraintPrototypeSyntax& SyntaxFactory::constraintPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, Token semi) {
+    return *alloc.emplace<ConstraintPrototypeSyntax>(attributes, qualifiers, keyword, name, semi);
+}
+
+ContinuousAssignSyntax& SyntaxFactory::continuousAssign(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi) {
+    return *alloc.emplace<ContinuousAssignSyntax>(attributes, assign, strength, delay, assignments, semi);
+}
+
+CoverageBinsSyntax& SyntaxFactory::coverageBins(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) {
+    return *alloc.emplace<CoverageBinsSyntax>(attributes, wildcard, keyword, name, selector, equals, initializer, iff, semi);
+}
+
+CoverageOptionSyntax& SyntaxFactory::coverageOption(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<CoverageOptionSyntax>(attributes, option, dot, name, equals, expr, semi);
+}
+
+CovergroupDeclarationSyntax& SyntaxFactory::covergroupDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<CovergroupDeclarationSyntax>(attributes, covergroup, name, portList, event, semi, members, endgroup, endBlockName);
+}
+
+CoverpointSyntax& SyntaxFactory::coverpoint(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) {
+    return *alloc.emplace<CoverpointSyntax>(attributes, type, label, coverpoint, expr, openBrace, members, closeBrace, emptySemi);
+}
+
+DPIImportExportSyntax& SyntaxFactory::dPIImportExport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token stringLiteral, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi) {
+    return *alloc.emplace<DPIImportExportSyntax>(attributes, keyword, stringLiteral, property, c_identifier, equals, method, semi);
+}
+
+DataDeclarationSyntax& SyntaxFactory::dataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<DataDeclarationSyntax>(attributes, modifiers, type, declarators, semi);
+}
+
+DeclaratorSyntax& SyntaxFactory::declarator(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer) {
+    return *alloc.emplace<DeclaratorSyntax>(name, dimensions, initializer);
+}
+
+DefParamAssignmentSyntax& SyntaxFactory::defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax* setter) {
+    return *alloc.emplace<DefParamAssignmentSyntax>(name, setter);
+}
+
+DefParamSyntax& SyntaxFactory::defParam(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi) {
+    return *alloc.emplace<DefParamSyntax>(attributes, defparam, assignments, semi);
+}
+
+DefaultCaseItemSyntax& SyntaxFactory::defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause) {
+    return *alloc.emplace<DefaultCaseItemSyntax>(defaultKeyword, colon, clause);
+}
+
+DefaultCoverageBinInitializerSyntax& SyntaxFactory::defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword) {
+    return *alloc.emplace<DefaultCoverageBinInitializerSyntax>(defaultKeyword, sequenceKeyword);
+}
+
+DefaultNetTypeDirectiveSyntax& SyntaxFactory::defaultNetTypeDirective(Token directive, Token netType) {
+    return *alloc.emplace<DefaultNetTypeDirectiveSyntax>(directive, netType);
+}
+
+DeferredAssertionSyntax& SyntaxFactory::deferredAssertion(Token hash, Token zero, Token finalKeyword) {
+    return *alloc.emplace<DeferredAssertionSyntax>(hash, zero, finalKeyword);
+}
+
+DefineDirectiveSyntax& SyntaxFactory::defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body) {
+    return *alloc.emplace<DefineDirectiveSyntax>(directive, name, formalArguments, body);
+}
+
+Delay3Syntax& SyntaxFactory::delay3(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen) {
+    return *alloc.emplace<Delay3Syntax>(hash, openParen, delay1, comma1, delay2, comma2, delay3, closeParen);
+}
+
+DelaySyntax& SyntaxFactory::delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) {
+    return *alloc.emplace<DelaySyntax>(kind, hash, delayValue);
+}
+
+DisableConstraintSyntax& SyntaxFactory::disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi) {
+    return *alloc.emplace<DisableConstraintSyntax>(disable, soft, name, semi);
+}
+
+DisableForkStatementSyntax& SyntaxFactory::disableForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi) {
+    return *alloc.emplace<DisableForkStatementSyntax>(label, attributes, disable, fork, semi);
+}
+
+DisableIffSyntax& SyntaxFactory::disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<DisableIffSyntax>(disable, iff, openParen, expr, closeParen);
+}
+
+DisableStatementSyntax& SyntaxFactory::disableStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi) {
+    return *alloc.emplace<DisableStatementSyntax>(label, attributes, disable, name, semi);
+}
+
+DistConstraintListSyntax& SyntaxFactory::distConstraintList(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<DistConstraintListSyntax>(dist, openBrace, items, closeBrace);
+}
+
+DistItemSyntax& SyntaxFactory::distItem(ExpressionSyntax& range, DistWeightSyntax* weight) {
+    return *alloc.emplace<DistItemSyntax>(range, weight);
+}
+
+DistWeightSyntax& SyntaxFactory::distWeight(Token op, ExpressionSyntax& expr) {
+    return *alloc.emplace<DistWeightSyntax>(op, expr);
+}
+
+DividerClauseSyntax& SyntaxFactory::dividerClause(Token divide, Token value) {
+    return *alloc.emplace<DividerClauseSyntax>(divide, value);
+}
+
+DoWhileStatementSyntax& SyntaxFactory::doWhileStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) {
+    return *alloc.emplace<DoWhileStatementSyntax>(label, attributes, doKeyword, statement, whileKeyword, openParen, expr, closeParen, semi);
+}
+
+DotMemberClauseSyntax& SyntaxFactory::dotMemberClause(Token dot, Token member) {
+    return *alloc.emplace<DotMemberClauseSyntax>(dot, member);
+}
+
+DriveStrengthSyntax& SyntaxFactory::driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) {
+    return *alloc.emplace<DriveStrengthSyntax>(openParen, strength0, comma, strength1, closeParen);
+}
+
+ElementSelectExpressionSyntax& SyntaxFactory::elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select) {
+    return *alloc.emplace<ElementSelectExpressionSyntax>(left, select);
+}
+
+ElementSelectSyntax& SyntaxFactory::elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket) {
+    return *alloc.emplace<ElementSelectSyntax>(openBracket, selector, closeBracket);
+}
+
+ElseClauseSyntax& SyntaxFactory::elseClause(Token elseKeyword, SyntaxNode& clause) {
+    return *alloc.emplace<ElseClauseSyntax>(elseKeyword, clause);
+}
+
+ElseConstraintClauseSyntax& SyntaxFactory::elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<ElseConstraintClauseSyntax>(elseKeyword, constraints);
+}
+
+EmptyArgumentSyntax& SyntaxFactory::emptyArgument(Token placeholder) {
+    return *alloc.emplace<EmptyArgumentSyntax>(placeholder);
+}
+
+EmptyIdentifierNameSyntax& SyntaxFactory::emptyIdentifierName(Token placeholder) {
+    return *alloc.emplace<EmptyIdentifierNameSyntax>(placeholder);
+}
+
+EmptyMemberSyntax& SyntaxFactory::emptyMember(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi) {
+    return *alloc.emplace<EmptyMemberSyntax>(attributes, qualifiers, semi);
+}
+
+EmptyQueueExpressionSyntax& SyntaxFactory::emptyQueueExpression(Token openBrace, Token closeBrace) {
+    return *alloc.emplace<EmptyQueueExpressionSyntax>(openBrace, closeBrace);
+}
+
+EmptyStatementSyntax& SyntaxFactory::emptyStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon) {
+    return *alloc.emplace<EmptyStatementSyntax>(label, attributes, semicolon);
+}
+
+EnumTypeSyntax& SyntaxFactory::enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<EnumTypeSyntax>(keyword, baseType, openBrace, members, closeBrace, dimensions);
+}
+
+EqualsTypeClauseSyntax& SyntaxFactory::equalsTypeClause(Token equals, DataTypeSyntax& type) {
+    return *alloc.emplace<EqualsTypeClauseSyntax>(equals, type);
+}
+
+EqualsValueClauseSyntax& SyntaxFactory::equalsValueClause(Token equals, ExpressionSyntax& expr) {
+    return *alloc.emplace<EqualsValueClauseSyntax>(equals, expr);
+}
+
+EventControlSyntax& SyntaxFactory::eventControl(Token at, NameSyntax& eventName) {
+    return *alloc.emplace<EventControlSyntax>(at, eventName);
+}
+
+EventControlWithExpressionSyntax& SyntaxFactory::eventControlWithExpression(Token at, EventExpressionSyntax& expr) {
+    return *alloc.emplace<EventControlWithExpressionSyntax>(at, expr);
+}
+
+EventTriggerStatementSyntax& SyntaxFactory::eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) {
+    return *alloc.emplace<EventTriggerStatementSyntax>(kind, label, attributes, trigger, timing, name);
+}
+
+ExplicitAnsiPortSyntax& SyntaxFactory::explicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ExplicitAnsiPortSyntax>(attributes, direction, dot, name, openParen, expr, closeParen);
+}
+
+ExplicitNonAnsiPortSyntax& SyntaxFactory::explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ExplicitNonAnsiPortSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+ExpressionConstraintSyntax& SyntaxFactory::expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<ExpressionConstraintSyntax>(soft, expr, semi);
+}
+
+ExpressionCoverageBinInitializerSyntax& SyntaxFactory::expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause) {
+    return *alloc.emplace<ExpressionCoverageBinInitializerSyntax>(expr, withClause);
+}
+
+ExpressionOrDistSyntax& SyntaxFactory::expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) {
+    return *alloc.emplace<ExpressionOrDistSyntax>(expr, distribution);
+}
+
+ExpressionPatternSyntax& SyntaxFactory::expressionPattern(ExpressionSyntax& expr) {
+    return *alloc.emplace<ExpressionPatternSyntax>(expr);
+}
+
+ExpressionStatementSyntax& SyntaxFactory::expressionStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) {
+    return *alloc.emplace<ExpressionStatementSyntax>(label, attributes, expr, semi);
+}
+
+ExtendsClauseSyntax& SyntaxFactory::extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) {
+    return *alloc.emplace<ExtendsClauseSyntax>(keyword, baseName, arguments);
+}
+
+ExternModuleSyntax& SyntaxFactory::externModule(Token externKeyword, ModuleHeaderSyntax& header) {
+    return *alloc.emplace<ExternModuleSyntax>(externKeyword, header);
+}
+
+ForLoopStatementSyntax& SyntaxFactory::forLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<ForLoopStatementSyntax>(label, attributes, forKeyword, openParen, initializers, semi1, stopExpr, semi2, steps, closeParen, statement);
+}
+
+ForVariableDeclarationSyntax& SyntaxFactory::forVariableDeclaration(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<ForVariableDeclarationSyntax>(varKeyword, type, declarator);
+}
+
+ForeachLoopListSyntax& SyntaxFactory::foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen) {
+    return *alloc.emplace<ForeachLoopListSyntax>(openParen, arrayName, openBracket, loopVariables, closeBracket, closeParen);
+}
+
+ForeachLoopStatementSyntax& SyntaxFactory::foreachLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) {
+    return *alloc.emplace<ForeachLoopStatementSyntax>(label, attributes, keyword, loopList, statement);
+}
+
+ForeverStatementSyntax& SyntaxFactory::foreverStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement) {
+    return *alloc.emplace<ForeverStatementSyntax>(label, attributes, foreverKeyword, statement);
+}
+
+ForwardInterfaceClassTypedefDeclarationSyntax& SyntaxFactory::forwardInterfaceClassTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) {
+    return *alloc.emplace<ForwardInterfaceClassTypedefDeclarationSyntax>(attributes, typedefKeyword, interfaceKeyword, classKeyword, name, semi);
+}
+
+ForwardTypedefDeclarationSyntax& SyntaxFactory::forwardTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi) {
+    return *alloc.emplace<ForwardTypedefDeclarationSyntax>(attributes, typedefKeyword, keyword, name, semi);
+}
+
+FunctionDeclarationSyntax& SyntaxFactory::functionDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<FunctionDeclarationSyntax>(kind, attributes, prototype, semi, items, end, endBlockName);
+}
+
+FunctionPortListSyntax& SyntaxFactory::functionPortList(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<FunctionPortListSyntax>(openParen, ports, closeParen);
+}
+
+FunctionPortSyntax& SyntaxFactory::functionPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<FunctionPortSyntax>(attributes, constKeyword, direction, varKeyword, dataType, declarator);
+}
+
+FunctionPrototypeSyntax& SyntaxFactory::functionPrototype(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList) {
+    return *alloc.emplace<FunctionPrototypeSyntax>(keyword, lifetime, returnType, name, portList);
+}
+
+GateInstanceNameSyntax& SyntaxFactory::gateInstanceName(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<GateInstanceNameSyntax>(name, dimensions);
+}
+
+GateInstanceSyntax& SyntaxFactory::gateInstance(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen) {
+    return *alloc.emplace<GateInstanceSyntax>(decl, openParen, connections, closeParen);
+}
+
+GateInstantiationSyntax& SyntaxFactory::gateInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi) {
+    return *alloc.emplace<GateInstantiationSyntax>(attributes, gateType, strength, delay, instances, semi);
+}
+
+GenerateBlockSyntax& SyntaxFactory::generateBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName) {
+    return *alloc.emplace<GenerateBlockSyntax>(attributes, label, begin, beginName, members, end, endName);
+}
+
+GenerateRegionSyntax& SyntaxFactory::generateRegion(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate) {
+    return *alloc.emplace<GenerateRegionSyntax>(attributes, keyword, members, endgenerate);
+}
+
+GenvarDeclarationSyntax& SyntaxFactory::genvarDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi) {
+    return *alloc.emplace<GenvarDeclarationSyntax>(attributes, keyword, identifiers, semi);
+}
+
+HierarchicalInstanceSyntax& SyntaxFactory::hierarchicalInstance(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen) {
+    return *alloc.emplace<HierarchicalInstanceSyntax>(name, dimensions, openParen, connections, closeParen);
+}
+
+HierarchyInstantiationSyntax& SyntaxFactory::hierarchyInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) {
+    return *alloc.emplace<HierarchyInstantiationSyntax>(attributes, type, parameters, instances, semi);
+}
+
+IdentifierNameSyntax& SyntaxFactory::identifierName(Token identifier) {
+    return *alloc.emplace<IdentifierNameSyntax>(identifier);
+}
+
+IdentifierSelectNameSyntax& SyntaxFactory::identifierSelectName(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors) {
+    return *alloc.emplace<IdentifierSelectNameSyntax>(identifier, selectors);
+}
+
+IfGenerateSyntax& SyntaxFactory::ifGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) {
+    return *alloc.emplace<IfGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, block, elseClause);
+}
+
+IffClauseSyntax& SyntaxFactory::iffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<IffClauseSyntax>(iff, openParen, expr, closeParen);
+}
+
+ImmediateAssertionMemberSyntax& SyntaxFactory::immediateAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement) {
+    return *alloc.emplace<ImmediateAssertionMemberSyntax>(attributes, statement);
+}
+
+ImmediateAssertionStatementSyntax& SyntaxFactory::immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) {
+    return *alloc.emplace<ImmediateAssertionStatementSyntax>(kind, label, attributes, keyword, delay, expr, action);
+}
+
+ImplementsClauseSyntax& SyntaxFactory::implementsClause(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces) {
+    return *alloc.emplace<ImplementsClauseSyntax>(keyword, interfaces);
+}
+
+ImplicationConstraintSyntax& SyntaxFactory::implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<ImplicationConstraintSyntax>(left, arrow, constraints);
+}
+
+ImplicitAnsiPortSyntax& SyntaxFactory::implicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator) {
+    return *alloc.emplace<ImplicitAnsiPortSyntax>(attributes, header, declarator);
+}
+
+ImplicitEventControlSyntax& SyntaxFactory::implicitEventControl(Token at, Token openParen, Token star, Token closeParen) {
+    return *alloc.emplace<ImplicitEventControlSyntax>(at, openParen, star, closeParen);
+}
+
+ImplicitNonAnsiPortSyntax& SyntaxFactory::implicitNonAnsiPort(PortExpressionSyntax* expr) {
+    return *alloc.emplace<ImplicitNonAnsiPortSyntax>(expr);
+}
+
+ImplicitTypeSyntax& SyntaxFactory::implicitType(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<ImplicitTypeSyntax>(signing, dimensions);
+}
+
+IncludeDirectiveSyntax& SyntaxFactory::includeDirective(Token directive, Token fileName) {
+    return *alloc.emplace<IncludeDirectiveSyntax>(directive, fileName);
+}
+
+InsideExpressionSyntax& SyntaxFactory::insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) {
+    return *alloc.emplace<InsideExpressionSyntax>(expr, inside, ranges);
+}
+
+IntegerTypeSyntax& SyntaxFactory::integerType(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<IntegerTypeSyntax>(kind, keyword, signing, dimensions);
+}
+
+IntegerVectorExpressionSyntax& SyntaxFactory::integerVectorExpression(Token size, Token base, Token value) {
+    return *alloc.emplace<IntegerVectorExpressionSyntax>(size, base, value);
+}
+
+InterconnectPortHeaderSyntax& SyntaxFactory::interconnectPortHeader(Token direction, Token interconnect, ImplicitTypeSyntax& type) {
+    return *alloc.emplace<InterconnectPortHeaderSyntax>(direction, interconnect, type);
+}
+
+InterfacePortHeaderSyntax& SyntaxFactory::interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport) {
+    return *alloc.emplace<InterfacePortHeaderSyntax>(nameOrKeyword, modport);
+}
+
+InvocationExpressionSyntax& SyntaxFactory::invocationExpression(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments) {
+    return *alloc.emplace<InvocationExpressionSyntax>(left, attributes, arguments);
+}
+
+JumpStatementSyntax& SyntaxFactory::jumpStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi) {
+    return *alloc.emplace<JumpStatementSyntax>(label, attributes, breakOrContinue, semi);
+}
+
+KeywordNameSyntax& SyntaxFactory::keywordName(SyntaxKind kind, Token keyword) {
+    return *alloc.emplace<KeywordNameSyntax>(kind, keyword);
+}
+
+KeywordTypeSyntax& SyntaxFactory::keywordType(SyntaxKind kind, Token keyword) {
+    return *alloc.emplace<KeywordTypeSyntax>(kind, keyword);
+}
+
+LetDeclarationSyntax& SyntaxFactory::letDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) {
+    return *alloc.emplace<LetDeclarationSyntax>(attributes, let, identifier, portList, initializer, semi);
+}
+
+LineDirectiveSyntax& SyntaxFactory::lineDirective(Token directive, Token lineNumber, Token fileName, Token level) {
+    return *alloc.emplace<LineDirectiveSyntax>(directive, lineNumber, fileName, level);
+}
+
+LiteralExpressionSyntax& SyntaxFactory::literalExpression(SyntaxKind kind, Token literal) {
+    return *alloc.emplace<LiteralExpressionSyntax>(kind, literal);
+}
+
+LoopConstraintSyntax& SyntaxFactory::loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) {
+    return *alloc.emplace<LoopConstraintSyntax>(foreachKeyword, loopList, constraints);
+}
+
+LoopGenerateSyntax& SyntaxFactory::loopGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) {
+    return *alloc.emplace<LoopGenerateSyntax>(attributes, keyword, openParen, genvar, identifier, equals, initialExpr, semi1, stopExpr, semi2, iterationExpr, closeParen, block);
+}
+
+LoopStatementSyntax& SyntaxFactory::loopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<LoopStatementSyntax>(label, attributes, repeatOrWhile, openParen, expr, closeParen, statement);
+}
+
+MacroActualArgumentListSyntax& SyntaxFactory::macroActualArgumentList(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen) {
+    return *alloc.emplace<MacroActualArgumentListSyntax>(openParen, args, closeParen);
+}
+
+MacroActualArgumentSyntax& SyntaxFactory::macroActualArgument(const TokenList& tokens) {
+    return *alloc.emplace<MacroActualArgumentSyntax>(tokens);
+}
+
+MacroArgumentDefaultSyntax& SyntaxFactory::macroArgumentDefault(Token equals, const TokenList& tokens) {
+    return *alloc.emplace<MacroArgumentDefaultSyntax>(equals, tokens);
+}
+
+MacroFormalArgumentListSyntax& SyntaxFactory::macroFormalArgumentList(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen) {
+    return *alloc.emplace<MacroFormalArgumentListSyntax>(openParen, args, closeParen);
+}
+
+MacroFormalArgumentSyntax& SyntaxFactory::macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue) {
+    return *alloc.emplace<MacroFormalArgumentSyntax>(name, defaultValue);
+}
+
+MacroUsageSyntax& SyntaxFactory::macroUsage(Token directive, MacroActualArgumentListSyntax* args) {
+    return *alloc.emplace<MacroUsageSyntax>(directive, args);
+}
+
+MatchesClauseSyntax& SyntaxFactory::matchesClause(Token matchesKeyword, PatternSyntax& pattern) {
+    return *alloc.emplace<MatchesClauseSyntax>(matchesKeyword, pattern);
+}
+
+MemberAccessExpressionSyntax& SyntaxFactory::memberAccessExpression(ExpressionSyntax& left, Token dot, Token name) {
+    return *alloc.emplace<MemberAccessExpressionSyntax>(left, dot, name);
+}
+
+MinTypMaxExpressionSyntax& SyntaxFactory::minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) {
+    return *alloc.emplace<MinTypMaxExpressionSyntax>(min, colon1, typ, colon2, max);
+}
+
+ModportClockingPortSyntax& SyntaxFactory::modportClockingPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name) {
+    return *alloc.emplace<ModportClockingPortSyntax>(attributes, clocking, name);
+}
+
+ModportDeclarationSyntax& SyntaxFactory::modportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi) {
+    return *alloc.emplace<ModportDeclarationSyntax>(attributes, keyword, items, semi);
+}
+
+ModportExplicitPortSyntax& SyntaxFactory::modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<ModportExplicitPortSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+ModportItemSyntax& SyntaxFactory::modportItem(Token name, AnsiPortListSyntax& ports) {
+    return *alloc.emplace<ModportItemSyntax>(name, ports);
+}
+
+ModportNamedPortSyntax& SyntaxFactory::modportNamedPort(Token name) {
+    return *alloc.emplace<ModportNamedPortSyntax>(name);
+}
+
+ModportSimplePortListSyntax& SyntaxFactory::modportSimplePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports) {
+    return *alloc.emplace<ModportSimplePortListSyntax>(attributes, direction, ports);
+}
+
+ModportSubroutinePortListSyntax& SyntaxFactory::modportSubroutinePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports) {
+    return *alloc.emplace<ModportSubroutinePortListSyntax>(attributes, importExport, ports);
+}
+
+ModportSubroutinePortSyntax& SyntaxFactory::modportSubroutinePort(FunctionPrototypeSyntax& prototype) {
+    return *alloc.emplace<ModportSubroutinePortSyntax>(prototype);
+}
+
+ModuleDeclarationSyntax& SyntaxFactory::moduleDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName) {
+    return *alloc.emplace<ModuleDeclarationSyntax>(kind, attributes, header, members, endmodule, blockName);
+}
+
+ModuleHeaderSyntax& SyntaxFactory::moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) {
+    return *alloc.emplace<ModuleHeaderSyntax>(kind, moduleKeyword, lifetime, name, imports, parameters, ports, semi);
+}
+
+MultipleConcatenationExpressionSyntax& SyntaxFactory::multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) {
+    return *alloc.emplace<MultipleConcatenationExpressionSyntax>(openBrace, expression, concatenation, closeBrace);
+}
+
+NameValuePragmaExpressionSyntax& SyntaxFactory::nameValuePragmaExpression(Token name, Token equals, PragmaExpressionSyntax& value) {
+    return *alloc.emplace<NameValuePragmaExpressionSyntax>(name, equals, value);
+}
+
+NamedArgumentSyntax& SyntaxFactory::namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<NamedArgumentSyntax>(dot, name, openParen, expr, closeParen);
+}
+
+NamedBlockClauseSyntax& SyntaxFactory::namedBlockClause(Token colon, Token name) {
+    return *alloc.emplace<NamedBlockClauseSyntax>(colon, name);
+}
+
+NamedLabelSyntax& SyntaxFactory::namedLabel(Token name, Token colon) {
+    return *alloc.emplace<NamedLabelSyntax>(name, colon);
+}
+
+NamedPortConnectionSyntax& SyntaxFactory::namedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
+    return *alloc.emplace<NamedPortConnectionSyntax>(attributes, dot, name, openParen, expr, closeParen);
+}
+
+NamedStructurePatternMemberSyntax& SyntaxFactory::namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern) {
+    return *alloc.emplace<NamedStructurePatternMemberSyntax>(name, colon, pattern);
+}
+
+NamedTypeSyntax& SyntaxFactory::namedType(NameSyntax& name) {
+    return *alloc.emplace<NamedTypeSyntax>(name);
+}
+
+NetDeclarationSyntax& SyntaxFactory::netDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<NetDeclarationSyntax>(attributes, netType, strength, expansionHint, type, delay, declarators, semi);
+}
+
+NetPortHeaderSyntax& SyntaxFactory::netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType) {
+    return *alloc.emplace<NetPortHeaderSyntax>(direction, netType, dataType);
+}
+
+NetTypeDeclarationSyntax& SyntaxFactory::netTypeDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi) {
+    return *alloc.emplace<NetTypeDeclarationSyntax>(attributes, keyword, type, name, withFunction, semi);
+}
+
+NewArrayExpressionSyntax& SyntaxFactory::newArrayExpression(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) {
+    return *alloc.emplace<NewArrayExpressionSyntax>(newKeyword, openBracket, sizeExpr, closeBracket, initializer);
+}
+
+NewClassExpressionSyntax& SyntaxFactory::newClassExpression(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) {
+    return *alloc.emplace<NewClassExpressionSyntax>(classScope, newKeyword, arguments);
+}
+
+NewExpressionSyntax& SyntaxFactory::newExpression(Token newKeyword, ExpressionSyntax& expr) {
+    return *alloc.emplace<NewExpressionSyntax>(newKeyword, expr);
+}
+
+NonAnsiPortListSyntax& SyntaxFactory::nonAnsiPortList(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen) {
+    return *alloc.emplace<NonAnsiPortListSyntax>(openParen, ports, closeParen);
+}
+
+NumberPragmaExpressionSyntax& SyntaxFactory::numberPragmaExpression(Token size, Token base, Token value) {
+    return *alloc.emplace<NumberPragmaExpressionSyntax>(size, base, value);
+}
+
+OpenRangeExpressionSyntax& SyntaxFactory::openRangeExpression(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket) {
+    return *alloc.emplace<OpenRangeExpressionSyntax>(openBracket, left, colon, right, closeBracket);
+}
+
+OpenRangeListSyntax& SyntaxFactory::openRangeList(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace) {
+    return *alloc.emplace<OpenRangeListSyntax>(openBrace, valueRanges, closeBrace);
+}
+
+OrderedArgumentSyntax& SyntaxFactory::orderedArgument(ExpressionSyntax& expr) {
+    return *alloc.emplace<OrderedArgumentSyntax>(expr);
+}
+
+OrderedPortConnectionSyntax& SyntaxFactory::orderedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax* expr) {
+    return *alloc.emplace<OrderedPortConnectionSyntax>(attributes, expr);
+}
+
+OrderedStructurePatternMemberSyntax& SyntaxFactory::orderedStructurePatternMember(PatternSyntax& pattern) {
+    return *alloc.emplace<OrderedStructurePatternMemberSyntax>(pattern);
+}
+
+PackageImportDeclarationSyntax& SyntaxFactory::packageImportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) {
+    return *alloc.emplace<PackageImportDeclarationSyntax>(attributes, keyword, items, semi);
+}
+
+PackageImportItemSyntax& SyntaxFactory::packageImportItem(Token package, Token doubleColon, Token item) {
+    return *alloc.emplace<PackageImportItemSyntax>(package, doubleColon, item);
+}
+
+ParameterDeclarationStatementSyntax& SyntaxFactory::parameterDeclarationStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi) {
+    return *alloc.emplace<ParameterDeclarationStatementSyntax>(attributes, parameter, semi);
+}
+
+ParameterDeclarationSyntax& SyntaxFactory::parameterDeclaration(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators) {
+    return *alloc.emplace<ParameterDeclarationSyntax>(keyword, type, declarators);
+}
+
+ParameterPortListSyntax& SyntaxFactory::parameterPortList(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen) {
+    return *alloc.emplace<ParameterPortListSyntax>(hash, openParen, declarations, closeParen);
+}
+
+ParameterValueAssignmentSyntax& SyntaxFactory::parameterValueAssignment(Token hash, ArgumentListSyntax& assignments) {
+    return *alloc.emplace<ParameterValueAssignmentSyntax>(hash, assignments);
+}
+
+ParenExpressionListSyntax& SyntaxFactory::parenExpressionList(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen) {
+    return *alloc.emplace<ParenExpressionListSyntax>(openParen, expressions, closeParen);
+}
+
+ParenPragmaExpressionSyntax& SyntaxFactory::parenPragmaExpression(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen) {
+    return *alloc.emplace<ParenPragmaExpressionSyntax>(openParen, values, closeParen);
+}
+
+ParenthesizedEventExpressionSyntax& SyntaxFactory::parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<ParenthesizedEventExpressionSyntax>(openParen, expr, closeParen);
+}
+
+ParenthesizedExpressionSyntax& SyntaxFactory::parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen) {
+    return *alloc.emplace<ParenthesizedExpressionSyntax>(openParen, expression, closeParen);
+}
+
+PatternCaseItemSyntax& SyntaxFactory::patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) {
+    return *alloc.emplace<PatternCaseItemSyntax>(pattern, tripleAnd, expr, colon, statement);
+}
+
+PortConcatenationSyntax& SyntaxFactory::portConcatenation(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace) {
+    return *alloc.emplace<PortConcatenationSyntax>(openBrace, references, closeBrace);
+}
+
+PortDeclarationSyntax& SyntaxFactory::portDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<PortDeclarationSyntax>(attributes, header, declarators, semi);
+}
+
+PortReferenceSyntax& SyntaxFactory::portReference(Token name, ElementSelectSyntax* select) {
+    return *alloc.emplace<PortReferenceSyntax>(name, select);
+}
+
+PostfixUnaryExpressionSyntax& SyntaxFactory::postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken) {
+    return *alloc.emplace<PostfixUnaryExpressionSyntax>(kind, operand, attributes, operatorToken);
+}
+
+PragmaDirectiveSyntax& SyntaxFactory::pragmaDirective(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args) {
+    return *alloc.emplace<PragmaDirectiveSyntax>(directive, name, args);
+}
+
+PrefixUnaryExpressionSyntax& SyntaxFactory::prefixUnaryExpression(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand) {
+    return *alloc.emplace<PrefixUnaryExpressionSyntax>(kind, operatorToken, attributes, operand);
+}
+
+PrimaryBlockEventExpressionSyntax& SyntaxFactory::primaryBlockEventExpression(Token keyword, NameSyntax& name) {
+    return *alloc.emplace<PrimaryBlockEventExpressionSyntax>(keyword, name);
+}
+
+ProceduralAssignStatementSyntax& SyntaxFactory::proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) {
+    return *alloc.emplace<ProceduralAssignStatementSyntax>(kind, label, attributes, keyword, lvalue, equals, value, semi);
+}
+
+ProceduralBlockSyntax& SyntaxFactory::proceduralBlock(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement) {
+    return *alloc.emplace<ProceduralBlockSyntax>(kind, attributes, keyword, statement);
+}
+
+ProceduralDeassignStatementSyntax& SyntaxFactory::proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi) {
+    return *alloc.emplace<ProceduralDeassignStatementSyntax>(kind, label, attributes, keyword, variable, semi);
+}
+
+PropertyDeclarationSyntax& SyntaxFactory::propertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<PropertyDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, propertySpec, optionalSemi, end, endBlockName);
+}
+
+PropertySpecSyntax& SyntaxFactory::propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) {
+    return *alloc.emplace<PropertySpecSyntax>(clocking, disable, expr);
+}
+
+QueueDimensionSpecifierSyntax& SyntaxFactory::queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) {
+    return *alloc.emplace<QueueDimensionSpecifierSyntax>(dollar, maxSizeClause);
+}
+
+RandCaseItemSyntax& SyntaxFactory::randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) {
+    return *alloc.emplace<RandCaseItemSyntax>(expr, colon, statement);
+}
+
+RandCaseStatementSyntax& SyntaxFactory::randCaseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase) {
+    return *alloc.emplace<RandCaseStatementSyntax>(label, attributes, randCase, items, endCase);
+}
+
+RangeCoverageBinInitializerSyntax& SyntaxFactory::rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) {
+    return *alloc.emplace<RangeCoverageBinInitializerSyntax>(ranges, withClause);
+}
+
+RangeDimensionSpecifierSyntax& SyntaxFactory::rangeDimensionSpecifier(SelectorSyntax& selector) {
+    return *alloc.emplace<RangeDimensionSpecifierSyntax>(selector);
+}
+
+RangeSelectSyntax& SyntaxFactory::rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) {
+    return *alloc.emplace<RangeSelectSyntax>(kind, left, range, right);
+}
+
+RepeatedEventControlSyntax& SyntaxFactory::repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) {
+    return *alloc.emplace<RepeatedEventControlSyntax>(repeat, openParen, expr, closeParen, eventControl);
+}
+
+ReplicatedAssignmentPatternSyntax& SyntaxFactory::replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace) {
+    return *alloc.emplace<ReplicatedAssignmentPatternSyntax>(openBrace, countExpr, innerOpenBrace, items, innerCloseBrace, closeBrace);
+}
+
+ReturnStatementSyntax& SyntaxFactory::returnStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) {
+    return *alloc.emplace<ReturnStatementSyntax>(label, attributes, returnKeyword, returnValue, semi);
+}
+
+ScopedNameSyntax& SyntaxFactory::scopedName(NameSyntax& left, Token separator, NameSyntax& right) {
+    return *alloc.emplace<ScopedNameSyntax>(left, separator, right);
+}
+
+SequenceDeclarationSyntax& SyntaxFactory::sequenceDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
+    return *alloc.emplace<SequenceDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, seqExpr, optionalSemi, end, endBlockName);
+}
+
+ShortcutCycleDelayRangeSyntax& SyntaxFactory::shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket) {
+    return *alloc.emplace<ShortcutCycleDelayRangeSyntax>(doubleHash, openBracket, op, closeBracket);
+}
+
+SignalEventExpressionSyntax& SyntaxFactory::signalEventExpression(Token edge, ExpressionSyntax& expr) {
+    return *alloc.emplace<SignalEventExpressionSyntax>(edge, expr);
+}
+
+SignedCastExpressionSyntax& SyntaxFactory::signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) {
+    return *alloc.emplace<SignedCastExpressionSyntax>(signing, apostrophe, inner);
+}
+
+SimpleAssignmentPatternSyntax& SyntaxFactory::simpleAssignmentPattern(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<SimpleAssignmentPatternSyntax>(openBrace, items, closeBrace);
+}
+
+SimpleDirectiveSyntax& SyntaxFactory::simpleDirective(SyntaxKind kind, Token directive) {
+    return *alloc.emplace<SimpleDirectiveSyntax>(kind, directive);
+}
+
+SimplePragmaExpressionSyntax& SyntaxFactory::simplePragmaExpression(Token value) {
+    return *alloc.emplace<SimplePragmaExpressionSyntax>(value);
+}
+
+SolveBeforeConstraintSyntax& SyntaxFactory::solveBeforeConstraint(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi) {
+    return *alloc.emplace<SolveBeforeConstraintSyntax>(solve, beforeExpr, before, afterExpr, semi);
+}
+
+StandardCaseItemSyntax& SyntaxFactory::standardCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause) {
+    return *alloc.emplace<StandardCaseItemSyntax>(expressions, colon, clause);
+}
+
+StreamExpressionSyntax& SyntaxFactory::streamExpression(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange) {
+    return *alloc.emplace<StreamExpressionSyntax>(expression, withRange);
+}
+
+StreamExpressionWithRangeSyntax& SyntaxFactory::streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) {
+    return *alloc.emplace<StreamExpressionWithRangeSyntax>(withKeyword, range);
+}
+
+StreamingConcatenationExpressionSyntax& SyntaxFactory::streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace) {
+    return *alloc.emplace<StreamingConcatenationExpressionSyntax>(openBrace, operatorToken, sliceSize, innerOpenBrace, expressions, innerCloseBrace, closeBrace);
+}
+
+StructUnionMemberSyntax& SyntaxFactory::structUnionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) {
+    return *alloc.emplace<StructUnionMemberSyntax>(attributes, randomQualifier, type, declarators, semi);
+}
+
+StructUnionTypeSyntax& SyntaxFactory::structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) {
+    return *alloc.emplace<StructUnionTypeSyntax>(kind, keyword, tagged, packed, signing, openBrace, members, closeBrace, dimensions);
+}
+
+StructurePatternSyntax& SyntaxFactory::structurePattern(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace) {
+    return *alloc.emplace<StructurePatternSyntax>(openBrace, members, closeBrace);
+}
+
+StructuredAssignmentPatternSyntax& SyntaxFactory::structuredAssignmentPattern(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace) {
+    return *alloc.emplace<StructuredAssignmentPatternSyntax>(openBrace, items, closeBrace);
+}
+
+SystemNameSyntax& SyntaxFactory::systemName(Token systemIdentifier) {
+    return *alloc.emplace<SystemNameSyntax>(systemIdentifier);
+}
+
+TaggedPatternSyntax& SyntaxFactory::taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern) {
+    return *alloc.emplace<TaggedPatternSyntax>(tagged, memberName, pattern);
+}
+
+TaggedUnionExpressionSyntax& SyntaxFactory::taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr) {
+    return *alloc.emplace<TaggedUnionExpressionSyntax>(tagged, member, expr);
+}
+
+TimeScaleDirectiveSyntax& SyntaxFactory::timeScaleDirective(Token directive, Token timeUnit, Token slash, Token timePrecision) {
+    return *alloc.emplace<TimeScaleDirectiveSyntax>(directive, timeUnit, slash, timePrecision);
+}
+
+TimeUnitsDeclarationSyntax& SyntaxFactory::timeUnitsDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) {
+    return *alloc.emplace<TimeUnitsDeclarationSyntax>(attributes, keyword, time, divider, semi);
+}
+
+TimingControlExpressionConcatenationSyntax& SyntaxFactory::timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) {
+    return *alloc.emplace<TimingControlExpressionConcatenationSyntax>(left, timing, right);
+}
+
+TimingControlExpressionSyntax& SyntaxFactory::timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr) {
+    return *alloc.emplace<TimingControlExpressionSyntax>(timing, expr);
+}
+
+TimingControlStatementSyntax& SyntaxFactory::timingControlStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) {
+    return *alloc.emplace<TimingControlStatementSyntax>(label, attributes, timingControl, statement);
+}
+
+TransListCoverageBinInitializerSyntax& SyntaxFactory::transListCoverageBinInitializer(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause) {
+    return *alloc.emplace<TransListCoverageBinInitializerSyntax>(sets, withClause);
+}
+
+TransRangeSyntax& SyntaxFactory::transRange(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat) {
+    return *alloc.emplace<TransRangeSyntax>(items, repeat);
+}
+
+TransRepeatRangeSyntax& SyntaxFactory::transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) {
+    return *alloc.emplace<TransRepeatRangeSyntax>(openBracket, specifier, selector, closeBracket);
+}
+
+TransSetSyntax& SyntaxFactory::transSet(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen) {
+    return *alloc.emplace<TransSetSyntax>(openParen, ranges, closeParen);
+}
+
+TypeAssignmentSyntax& SyntaxFactory::typeAssignment(Token name, EqualsTypeClauseSyntax* assignment) {
+    return *alloc.emplace<TypeAssignmentSyntax>(name, assignment);
+}
+
+TypeParameterDeclarationSyntax& SyntaxFactory::typeParameterDeclaration(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators) {
+    return *alloc.emplace<TypeParameterDeclarationSyntax>(keyword, typeKeyword, declarators);
+}
+
+TypeReferenceSyntax& SyntaxFactory::typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<TypeReferenceSyntax>(typeKeyword, openParen, expr, closeParen);
+}
+
+TypedefDeclarationSyntax& SyntaxFactory::typedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi) {
+    return *alloc.emplace<TypedefDeclarationSyntax>(attributes, typedefKeyword, type, name, dimensions, semi);
+}
+
+UnconditionalBranchDirectiveSyntax& SyntaxFactory::unconditionalBranchDirective(SyntaxKind kind, Token directive, const TokenList& disabledTokens) {
+    return *alloc.emplace<UnconditionalBranchDirectiveSyntax>(kind, directive, disabledTokens);
+}
+
+UnconnectedDriveDirectiveSyntax& SyntaxFactory::unconnectedDriveDirective(Token directive, Token strength) {
+    return *alloc.emplace<UnconnectedDriveDirectiveSyntax>(directive, strength);
+}
+
+UndefDirectiveSyntax& SyntaxFactory::undefDirective(Token directive, Token name) {
+    return *alloc.emplace<UndefDirectiveSyntax>(directive, name);
+}
+
+UniquenessConstraintSyntax& SyntaxFactory::uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi) {
+    return *alloc.emplace<UniquenessConstraintSyntax>(unique, ranges, semi);
+}
+
+VariableDimensionSyntax& SyntaxFactory::variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) {
+    return *alloc.emplace<VariableDimensionSyntax>(openBracket, specifier, closeBracket);
+}
+
+VariablePatternSyntax& SyntaxFactory::variablePattern(Token dot, Token variableName) {
+    return *alloc.emplace<VariablePatternSyntax>(dot, variableName);
+}
+
+VariablePortHeaderSyntax& SyntaxFactory::variablePortHeader(Token direction, Token varKeyword, DataTypeSyntax& dataType) {
+    return *alloc.emplace<VariablePortHeaderSyntax>(direction, varKeyword, dataType);
+}
+
+VirtualInterfaceTypeSyntax& SyntaxFactory::virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) {
+    return *alloc.emplace<VirtualInterfaceTypeSyntax>(virtualKeyword, interfaceKeyword, name, parameters, modport);
+}
+
+VoidCastedCallStatementSyntax& SyntaxFactory::voidCastedCallStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) {
+    return *alloc.emplace<VoidCastedCallStatementSyntax>(label, attributes, voidKeyword, apostrophe, openParen, expr, closeParen, semi);
+}
+
+WaitForkStatementSyntax& SyntaxFactory::waitForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi) {
+    return *alloc.emplace<WaitForkStatementSyntax>(label, attributes, wait, fork, semi);
+}
+
+WaitOrderStatementSyntax& SyntaxFactory::waitOrderStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action) {
+    return *alloc.emplace<WaitOrderStatementSyntax>(label, attributes, wait_order, openParen, names, closeParen, action);
+}
+
+WaitStatementSyntax& SyntaxFactory::waitStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
+    return *alloc.emplace<WaitStatementSyntax>(label, attributes, wait, openParen, expr, closeParen, statement);
+}
+
+WildcardDimensionSpecifierSyntax& SyntaxFactory::wildcardDimensionSpecifier(Token star) {
+    return *alloc.emplace<WildcardDimensionSpecifierSyntax>(star);
+}
+
+WildcardPatternSyntax& SyntaxFactory::wildcardPattern(Token dotStar) {
+    return *alloc.emplace<WildcardPatternSyntax>(dotStar);
+}
+
+WildcardPortConnectionSyntax& SyntaxFactory::wildcardPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar) {
+    return *alloc.emplace<WildcardPortConnectionSyntax>(attributes, dotStar);
+}
+
+WildcardPortListSyntax& SyntaxFactory::wildcardPortList(Token openParen, Token dotStar, Token closeParen) {
+    return *alloc.emplace<WildcardPortListSyntax>(openParen, dotStar, closeParen);
+}
+
+WithClauseSyntax& SyntaxFactory::withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) {
+    return *alloc.emplace<WithClauseSyntax>(with, openParen, expr, closeParen);
+}
+
+WithFunctionClauseSyntax& SyntaxFactory::withFunctionClause(Token with, NameSyntax& name) {
+    return *alloc.emplace<WithFunctionClauseSyntax>(with, name);
+}
+
+WithFunctionSampleSyntax& SyntaxFactory::withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList) {
+    return *alloc.emplace<WithFunctionSampleSyntax>(with, function, sample, portList);
+}
+
+
+std::ostream& operator<<(std::ostream& os, SyntaxKind kind) {
+    os << toString(kind);
+    return os;
+}
+
+string_view toString(SyntaxKind kind) {
+    switch (kind) {
+        case SyntaxKind::AcceptOnPropertyExpression: return "AcceptOnPropertyExpression";
+        case SyntaxKind::ActionBlock: return "ActionBlock";
+        case SyntaxKind::AddAssignmentExpression: return "AddAssignmentExpression";
+        case SyntaxKind::AddExpression: return "AddExpression";
+        case SyntaxKind::AlwaysBlock: return "AlwaysBlock";
+        case SyntaxKind::AlwaysCombBlock: return "AlwaysCombBlock";
+        case SyntaxKind::AlwaysFFBlock: return "AlwaysFFBlock";
+        case SyntaxKind::AlwaysLatchBlock: return "AlwaysLatchBlock";
+        case SyntaxKind::AlwaysPropertyExpression: return "AlwaysPropertyExpression";
+        case SyntaxKind::AndAssignmentExpression: return "AndAssignmentExpression";
+        case SyntaxKind::AndSequenceExpression: return "AndSequenceExpression";
+        case SyntaxKind::AnsiPortList: return "AnsiPortList";
+        case SyntaxKind::ArgumentList: return "ArgumentList";
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return "ArithmeticLeftShiftAssignmentExpression";
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return "ArithmeticRightShiftAssignmentExpression";
+        case SyntaxKind::ArithmeticShiftLeftExpression: return "ArithmeticShiftLeftExpression";
+        case SyntaxKind::ArithmeticShiftRightExpression: return "ArithmeticShiftRightExpression";
+        case SyntaxKind::ArrayAndMethod: return "ArrayAndMethod";
+        case SyntaxKind::ArrayOrMethod: return "ArrayOrMethod";
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return "ArrayOrRandomizeMethodExpression";
+        case SyntaxKind::ArrayUniqueMethod: return "ArrayUniqueMethod";
+        case SyntaxKind::ArrayXorMethod: return "ArrayXorMethod";
+        case SyntaxKind::AscendingRangeSelect: return "AscendingRangeSelect";
+        case SyntaxKind::AssertPropertyStatement: return "AssertPropertyStatement";
+        case SyntaxKind::AssertionItemPort: return "AssertionItemPort";
+        case SyntaxKind::AssertionItemPortList: return "AssertionItemPortList";
+        case SyntaxKind::AssignmentExpression: return "AssignmentExpression";
+        case SyntaxKind::AssignmentPatternExpression: return "AssignmentPatternExpression";
+        case SyntaxKind::AssignmentPatternItem: return "AssignmentPatternItem";
+        case SyntaxKind::AssumePropertyStatement: return "AssumePropertyStatement";
+        case SyntaxKind::AttributeInstance: return "AttributeInstance";
+        case SyntaxKind::AttributeSpec: return "AttributeSpec";
+        case SyntaxKind::BadExpression: return "BadExpression";
+        case SyntaxKind::BeginKeywordsDirective: return "BeginKeywordsDirective";
+        case SyntaxKind::BinaryAndExpression: return "BinaryAndExpression";
+        case SyntaxKind::BinaryBlockEventExpression: return "BinaryBlockEventExpression";
+        case SyntaxKind::BinaryEventExpression: return "BinaryEventExpression";
+        case SyntaxKind::BinaryOrExpression: return "BinaryOrExpression";
+        case SyntaxKind::BinarySequenceDelayExpression: return "BinarySequenceDelayExpression";
+        case SyntaxKind::BinaryXnorExpression: return "BinaryXnorExpression";
+        case SyntaxKind::BinaryXorExpression: return "BinaryXorExpression";
+        case SyntaxKind::BitSelect: return "BitSelect";
+        case SyntaxKind::BitType: return "BitType";
+        case SyntaxKind::BlockCoverageEvent: return "BlockCoverageEvent";
+        case SyntaxKind::BlockingEventTriggerStatement: return "BlockingEventTriggerStatement";
+        case SyntaxKind::ByteType: return "ByteType";
+        case SyntaxKind::CHandleType: return "CHandleType";
+        case SyntaxKind::CaseEqualityExpression: return "CaseEqualityExpression";
+        case SyntaxKind::CaseGenerate: return "CaseGenerate";
+        case SyntaxKind::CaseInequalityExpression: return "CaseInequalityExpression";
+        case SyntaxKind::CaseStatement: return "CaseStatement";
+        case SyntaxKind::CastExpression: return "CastExpression";
+        case SyntaxKind::CellDefineDirective: return "CellDefineDirective";
+        case SyntaxKind::ChargeStrength: return "ChargeStrength";
+        case SyntaxKind::ClassDeclaration: return "ClassDeclaration";
+        case SyntaxKind::ClassMethodDeclaration: return "ClassMethodDeclaration";
+        case SyntaxKind::ClassMethodPrototype: return "ClassMethodPrototype";
+        case SyntaxKind::ClassName: return "ClassName";
+        case SyntaxKind::ClassPropertyDeclaration: return "ClassPropertyDeclaration";
+        case SyntaxKind::ClassScope: return "ClassScope";
+        case SyntaxKind::ClockingDeclaration: return "ClockingDeclaration";
+        case SyntaxKind::ClockingDirection: return "ClockingDirection";
+        case SyntaxKind::ClockingItem: return "ClockingItem";
+        case SyntaxKind::ClockingSkew: return "ClockingSkew";
+        case SyntaxKind::ColonExpressionClause: return "ColonExpressionClause";
+        case SyntaxKind::CompilationUnit: return "CompilationUnit";
+        case SyntaxKind::ConcatenationExpression: return "ConcatenationExpression";
+        case SyntaxKind::ConcurrentAssertionMember: return "ConcurrentAssertionMember";
+        case SyntaxKind::ConditionalConstraint: return "ConditionalConstraint";
+        case SyntaxKind::ConditionalExpression: return "ConditionalExpression";
+        case SyntaxKind::ConditionalPattern: return "ConditionalPattern";
+        case SyntaxKind::ConditionalPredicate: return "ConditionalPredicate";
+        case SyntaxKind::ConditionalStatement: return "ConditionalStatement";
+        case SyntaxKind::ConstraintBlock: return "ConstraintBlock";
+        case SyntaxKind::ConstraintDeclaration: return "ConstraintDeclaration";
+        case SyntaxKind::ConstraintPrototype: return "ConstraintPrototype";
+        case SyntaxKind::ConstructorName: return "ConstructorName";
+        case SyntaxKind::ContinuousAssign: return "ContinuousAssign";
+        case SyntaxKind::CoverPropertyStatement: return "CoverPropertyStatement";
+        case SyntaxKind::CoverSequenceStatement: return "CoverSequenceStatement";
+        case SyntaxKind::CoverageBins: return "CoverageBins";
+        case SyntaxKind::CoverageOption: return "CoverageOption";
+        case SyntaxKind::CovergroupDeclaration: return "CovergroupDeclaration";
+        case SyntaxKind::Coverpoint: return "Coverpoint";
+        case SyntaxKind::CycleDelay: return "CycleDelay";
+        case SyntaxKind::DPIImportExport: return "DPIImportExport";
+        case SyntaxKind::DataDeclaration: return "DataDeclaration";
+        case SyntaxKind::Declarator: return "Declarator";
+        case SyntaxKind::DefParam: return "DefParam";
+        case SyntaxKind::DefParamAssignment: return "DefParamAssignment";
+        case SyntaxKind::DefaultCaseItem: return "DefaultCaseItem";
+        case SyntaxKind::DefaultCoverageBinInitializer: return "DefaultCoverageBinInitializer";
+        case SyntaxKind::DefaultNetTypeDirective: return "DefaultNetTypeDirective";
+        case SyntaxKind::DefaultPatternKeyExpression: return "DefaultPatternKeyExpression";
+        case SyntaxKind::DeferredAssertion: return "DeferredAssertion";
+        case SyntaxKind::DefineDirective: return "DefineDirective";
+        case SyntaxKind::Delay3: return "Delay3";
+        case SyntaxKind::DelayControl: return "DelayControl";
+        case SyntaxKind::DescendingRangeSelect: return "DescendingRangeSelect";
+        case SyntaxKind::DisableConstraint: return "DisableConstraint";
+        case SyntaxKind::DisableForkStatement: return "DisableForkStatement";
+        case SyntaxKind::DisableIff: return "DisableIff";
+        case SyntaxKind::DisableStatement: return "DisableStatement";
+        case SyntaxKind::DistConstraintList: return "DistConstraintList";
+        case SyntaxKind::DistItem: return "DistItem";
+        case SyntaxKind::DistWeight: return "DistWeight";
+        case SyntaxKind::DivideAssignmentExpression: return "DivideAssignmentExpression";
+        case SyntaxKind::DivideExpression: return "DivideExpression";
+        case SyntaxKind::DividerClause: return "DividerClause";
+        case SyntaxKind::DoWhileStatement: return "DoWhileStatement";
+        case SyntaxKind::DotMemberClause: return "DotMemberClause";
+        case SyntaxKind::DriveStrength: return "DriveStrength";
+        case SyntaxKind::ElementSelect: return "ElementSelect";
+        case SyntaxKind::ElementSelectExpression: return "ElementSelectExpression";
+        case SyntaxKind::ElsIfDirective: return "ElsIfDirective";
+        case SyntaxKind::ElseClause: return "ElseClause";
+        case SyntaxKind::ElseConstraintClause: return "ElseConstraintClause";
+        case SyntaxKind::ElseDirective: return "ElseDirective";
+        case SyntaxKind::EmptyArgument: return "EmptyArgument";
+        case SyntaxKind::EmptyIdentifierName: return "EmptyIdentifierName";
+        case SyntaxKind::EmptyMember: return "EmptyMember";
+        case SyntaxKind::EmptyQueueExpression: return "EmptyQueueExpression";
+        case SyntaxKind::EmptyStatement: return "EmptyStatement";
+        case SyntaxKind::EndCellDefineDirective: return "EndCellDefineDirective";
+        case SyntaxKind::EndIfDirective: return "EndIfDirective";
+        case SyntaxKind::EndKeywordsDirective: return "EndKeywordsDirective";
+        case SyntaxKind::EnumType: return "EnumType";
+        case SyntaxKind::EqualityExpression: return "EqualityExpression";
+        case SyntaxKind::EqualsTypeClause: return "EqualsTypeClause";
+        case SyntaxKind::EqualsValueClause: return "EqualsValueClause";
+        case SyntaxKind::EventControl: return "EventControl";
+        case SyntaxKind::EventControlWithExpression: return "EventControlWithExpression";
+        case SyntaxKind::EventType: return "EventType";
+        case SyntaxKind::EventuallyPropertyExpression: return "EventuallyPropertyExpression";
+        case SyntaxKind::ExpectPropertyStatement: return "ExpectPropertyStatement";
+        case SyntaxKind::ExplicitAnsiPort: return "ExplicitAnsiPort";
+        case SyntaxKind::ExplicitNonAnsiPort: return "ExplicitNonAnsiPort";
+        case SyntaxKind::ExpressionConstraint: return "ExpressionConstraint";
+        case SyntaxKind::ExpressionCoverageBinInitializer: return "ExpressionCoverageBinInitializer";
+        case SyntaxKind::ExpressionOrDist: return "ExpressionOrDist";
+        case SyntaxKind::ExpressionPattern: return "ExpressionPattern";
+        case SyntaxKind::ExpressionStatement: return "ExpressionStatement";
+        case SyntaxKind::ExtendsClause: return "ExtendsClause";
+        case SyntaxKind::ExternModule: return "ExternModule";
+        case SyntaxKind::FinalBlock: return "FinalBlock";
+        case SyntaxKind::ForLoopStatement: return "ForLoopStatement";
+        case SyntaxKind::ForVariableDeclaration: return "ForVariableDeclaration";
+        case SyntaxKind::ForeachLoopList: return "ForeachLoopList";
+        case SyntaxKind::ForeachLoopStatement: return "ForeachLoopStatement";
+        case SyntaxKind::ForeverStatement: return "ForeverStatement";
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return "ForwardInterfaceClassTypedefDeclaration";
+        case SyntaxKind::ForwardTypedefDeclaration: return "ForwardTypedefDeclaration";
+        case SyntaxKind::FunctionDeclaration: return "FunctionDeclaration";
+        case SyntaxKind::FunctionPort: return "FunctionPort";
+        case SyntaxKind::FunctionPortList: return "FunctionPortList";
+        case SyntaxKind::FunctionPrototype: return "FunctionPrototype";
+        case SyntaxKind::GateInstance: return "GateInstance";
+        case SyntaxKind::GateInstanceName: return "GateInstanceName";
+        case SyntaxKind::GateInstantiation: return "GateInstantiation";
+        case SyntaxKind::GenerateBlock: return "GenerateBlock";
+        case SyntaxKind::GenerateRegion: return "GenerateRegion";
+        case SyntaxKind::GenvarDeclaration: return "GenvarDeclaration";
+        case SyntaxKind::GreaterThanEqualExpression: return "GreaterThanEqualExpression";
+        case SyntaxKind::GreaterThanExpression: return "GreaterThanExpression";
+        case SyntaxKind::HierarchicalInstance: return "HierarchicalInstance";
+        case SyntaxKind::HierarchyInstantiation: return "HierarchyInstantiation";
+        case SyntaxKind::IdentifierName: return "IdentifierName";
+        case SyntaxKind::IdentifierSelectName: return "IdentifierSelectName";
+        case SyntaxKind::IfDefDirective: return "IfDefDirective";
+        case SyntaxKind::IfGenerate: return "IfGenerate";
+        case SyntaxKind::IfNDefDirective: return "IfNDefDirective";
+        case SyntaxKind::IffClause: return "IffClause";
+        case SyntaxKind::IffPropertyExpression: return "IffPropertyExpression";
+        case SyntaxKind::ImmediateAssertStatement: return "ImmediateAssertStatement";
+        case SyntaxKind::ImmediateAssertionMember: return "ImmediateAssertionMember";
+        case SyntaxKind::ImmediateAssumeStatement: return "ImmediateAssumeStatement";
+        case SyntaxKind::ImmediateCoverStatement: return "ImmediateCoverStatement";
+        case SyntaxKind::ImplementsClause: return "ImplementsClause";
+        case SyntaxKind::ImplicationConstraint: return "ImplicationConstraint";
+        case SyntaxKind::ImplicitAnsiPort: return "ImplicitAnsiPort";
+        case SyntaxKind::ImplicitEventControl: return "ImplicitEventControl";
+        case SyntaxKind::ImplicitNonAnsiPort: return "ImplicitNonAnsiPort";
+        case SyntaxKind::ImplicitType: return "ImplicitType";
+        case SyntaxKind::ImpliesPropertyExpression: return "ImpliesPropertyExpression";
+        case SyntaxKind::IncludeDirective: return "IncludeDirective";
+        case SyntaxKind::InequalityExpression: return "InequalityExpression";
+        case SyntaxKind::InitialBlock: return "InitialBlock";
+        case SyntaxKind::InsideExpression: return "InsideExpression";
+        case SyntaxKind::IntType: return "IntType";
+        case SyntaxKind::IntegerLiteralExpression: return "IntegerLiteralExpression";
+        case SyntaxKind::IntegerType: return "IntegerType";
+        case SyntaxKind::IntegerVectorExpression: return "IntegerVectorExpression";
+        case SyntaxKind::InterconnectPortHeader: return "InterconnectPortHeader";
+        case SyntaxKind::InterfaceDeclaration: return "InterfaceDeclaration";
+        case SyntaxKind::InterfaceHeader: return "InterfaceHeader";
+        case SyntaxKind::InterfacePortHeader: return "InterfacePortHeader";
+        case SyntaxKind::IntersectSequenceExpression: return "IntersectSequenceExpression";
+        case SyntaxKind::InvocationExpression: return "InvocationExpression";
+        case SyntaxKind::JumpStatement: return "JumpStatement";
+        case SyntaxKind::LessThanEqualExpression: return "LessThanEqualExpression";
+        case SyntaxKind::LessThanExpression: return "LessThanExpression";
+        case SyntaxKind::LetDeclaration: return "LetDeclaration";
+        case SyntaxKind::LineDirective: return "LineDirective";
+        case SyntaxKind::LocalScope: return "LocalScope";
+        case SyntaxKind::LogicType: return "LogicType";
+        case SyntaxKind::LogicalAndExpression: return "LogicalAndExpression";
+        case SyntaxKind::LogicalEquivalenceExpression: return "LogicalEquivalenceExpression";
+        case SyntaxKind::LogicalImplicationExpression: return "LogicalImplicationExpression";
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return "LogicalLeftShiftAssignmentExpression";
+        case SyntaxKind::LogicalOrExpression: return "LogicalOrExpression";
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return "LogicalRightShiftAssignmentExpression";
+        case SyntaxKind::LogicalShiftLeftExpression: return "LogicalShiftLeftExpression";
+        case SyntaxKind::LogicalShiftRightExpression: return "LogicalShiftRightExpression";
+        case SyntaxKind::LongIntType: return "LongIntType";
+        case SyntaxKind::LoopConstraint: return "LoopConstraint";
+        case SyntaxKind::LoopGenerate: return "LoopGenerate";
+        case SyntaxKind::LoopStatement: return "LoopStatement";
+        case SyntaxKind::MacroActualArgument: return "MacroActualArgument";
+        case SyntaxKind::MacroActualArgumentList: return "MacroActualArgumentList";
+        case SyntaxKind::MacroArgumentDefault: return "MacroArgumentDefault";
+        case SyntaxKind::MacroFormalArgument: return "MacroFormalArgument";
+        case SyntaxKind::MacroFormalArgumentList: return "MacroFormalArgumentList";
+        case SyntaxKind::MacroUsage: return "MacroUsage";
+        case SyntaxKind::MatchesClause: return "MatchesClause";
+        case SyntaxKind::MemberAccessExpression: return "MemberAccessExpression";
+        case SyntaxKind::MinTypMaxExpression: return "MinTypMaxExpression";
+        case SyntaxKind::ModAssignmentExpression: return "ModAssignmentExpression";
+        case SyntaxKind::ModExpression: return "ModExpression";
+        case SyntaxKind::ModportClockingPort: return "ModportClockingPort";
+        case SyntaxKind::ModportDeclaration: return "ModportDeclaration";
+        case SyntaxKind::ModportExplicitPort: return "ModportExplicitPort";
+        case SyntaxKind::ModportItem: return "ModportItem";
+        case SyntaxKind::ModportNamedPort: return "ModportNamedPort";
+        case SyntaxKind::ModportSimplePortList: return "ModportSimplePortList";
+        case SyntaxKind::ModportSubroutinePort: return "ModportSubroutinePort";
+        case SyntaxKind::ModportSubroutinePortList: return "ModportSubroutinePortList";
+        case SyntaxKind::ModuleDeclaration: return "ModuleDeclaration";
+        case SyntaxKind::ModuleHeader: return "ModuleHeader";
+        case SyntaxKind::MultipleConcatenationExpression: return "MultipleConcatenationExpression";
+        case SyntaxKind::MultiplyAssignmentExpression: return "MultiplyAssignmentExpression";
+        case SyntaxKind::MultiplyExpression: return "MultiplyExpression";
+        case SyntaxKind::NameValuePragmaExpression: return "NameValuePragmaExpression";
+        case SyntaxKind::NamedArgument: return "NamedArgument";
+        case SyntaxKind::NamedBlockClause: return "NamedBlockClause";
+        case SyntaxKind::NamedLabel: return "NamedLabel";
+        case SyntaxKind::NamedPortConnection: return "NamedPortConnection";
+        case SyntaxKind::NamedStructurePatternMember: return "NamedStructurePatternMember";
+        case SyntaxKind::NamedType: return "NamedType";
+        case SyntaxKind::NetDeclaration: return "NetDeclaration";
+        case SyntaxKind::NetPortHeader: return "NetPortHeader";
+        case SyntaxKind::NetTypeDeclaration: return "NetTypeDeclaration";
+        case SyntaxKind::NewArrayExpression: return "NewArrayExpression";
+        case SyntaxKind::NewClassExpression: return "NewClassExpression";
+        case SyntaxKind::NewExpression: return "NewExpression";
+        case SyntaxKind::NextTimePropertyExpression: return "NextTimePropertyExpression";
+        case SyntaxKind::NoUnconnectedDriveDirective: return "NoUnconnectedDriveDirective";
+        case SyntaxKind::NonAnsiPortList: return "NonAnsiPortList";
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return "NonOverlappedFollowedByPropertyExpression";
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return "NonOverlappedImplicationPropertyExpression";
+        case SyntaxKind::NonblockingAssignmentExpression: return "NonblockingAssignmentExpression";
+        case SyntaxKind::NonblockingEventTriggerStatement: return "NonblockingEventTriggerStatement";
+        case SyntaxKind::NullLiteralExpression: return "NullLiteralExpression";
+        case SyntaxKind::NumberPragmaExpression: return "NumberPragmaExpression";
+        case SyntaxKind::OneStepLiteralExpression: return "OneStepLiteralExpression";
+        case SyntaxKind::OpenRangeExpression: return "OpenRangeExpression";
+        case SyntaxKind::OpenRangeList: return "OpenRangeList";
+        case SyntaxKind::OrAssignmentExpression: return "OrAssignmentExpression";
+        case SyntaxKind::OrSequenceExpression: return "OrSequenceExpression";
+        case SyntaxKind::OrderedArgument: return "OrderedArgument";
+        case SyntaxKind::OrderedPortConnection: return "OrderedPortConnection";
+        case SyntaxKind::OrderedStructurePatternMember: return "OrderedStructurePatternMember";
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return "OverlappedFollowedByPropertyExpression";
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return "OverlappedImplicationPropertyExpression";
+        case SyntaxKind::PackageDeclaration: return "PackageDeclaration";
+        case SyntaxKind::PackageHeader: return "PackageHeader";
+        case SyntaxKind::PackageImportDeclaration: return "PackageImportDeclaration";
+        case SyntaxKind::PackageImportItem: return "PackageImportItem";
+        case SyntaxKind::ParallelBlockStatement: return "ParallelBlockStatement";
+        case SyntaxKind::ParameterDeclaration: return "ParameterDeclaration";
+        case SyntaxKind::ParameterDeclarationStatement: return "ParameterDeclarationStatement";
+        case SyntaxKind::ParameterPortList: return "ParameterPortList";
+        case SyntaxKind::ParameterValueAssignment: return "ParameterValueAssignment";
+        case SyntaxKind::ParenExpressionList: return "ParenExpressionList";
+        case SyntaxKind::ParenPragmaExpression: return "ParenPragmaExpression";
+        case SyntaxKind::ParenthesizedEventExpression: return "ParenthesizedEventExpression";
+        case SyntaxKind::ParenthesizedExpression: return "ParenthesizedExpression";
+        case SyntaxKind::PatternCaseItem: return "PatternCaseItem";
+        case SyntaxKind::PortConcatenation: return "PortConcatenation";
+        case SyntaxKind::PortDeclaration: return "PortDeclaration";
+        case SyntaxKind::PortReference: return "PortReference";
+        case SyntaxKind::PostdecrementExpression: return "PostdecrementExpression";
+        case SyntaxKind::PostincrementExpression: return "PostincrementExpression";
+        case SyntaxKind::PowerExpression: return "PowerExpression";
+        case SyntaxKind::PragmaDirective: return "PragmaDirective";
+        case SyntaxKind::PrimaryBlockEventExpression: return "PrimaryBlockEventExpression";
+        case SyntaxKind::ProceduralAssignStatement: return "ProceduralAssignStatement";
+        case SyntaxKind::ProceduralDeassignStatement: return "ProceduralDeassignStatement";
+        case SyntaxKind::ProceduralForceStatement: return "ProceduralForceStatement";
+        case SyntaxKind::ProceduralReleaseStatement: return "ProceduralReleaseStatement";
+        case SyntaxKind::ProgramDeclaration: return "ProgramDeclaration";
+        case SyntaxKind::ProgramHeader: return "ProgramHeader";
+        case SyntaxKind::PropertyDeclaration: return "PropertyDeclaration";
+        case SyntaxKind::PropertySpec: return "PropertySpec";
+        case SyntaxKind::PropertyType: return "PropertyType";
+        case SyntaxKind::QueueDimensionSpecifier: return "QueueDimensionSpecifier";
+        case SyntaxKind::RandCaseItem: return "RandCaseItem";
+        case SyntaxKind::RandCaseStatement: return "RandCaseStatement";
+        case SyntaxKind::RangeCoverageBinInitializer: return "RangeCoverageBinInitializer";
+        case SyntaxKind::RangeDimensionSpecifier: return "RangeDimensionSpecifier";
+        case SyntaxKind::RealLiteralExpression: return "RealLiteralExpression";
+        case SyntaxKind::RealTimeType: return "RealTimeType";
+        case SyntaxKind::RealType: return "RealType";
+        case SyntaxKind::RegType: return "RegType";
+        case SyntaxKind::RejectOnPropertyExpression: return "RejectOnPropertyExpression";
+        case SyntaxKind::RepeatedEventControl: return "RepeatedEventControl";
+        case SyntaxKind::ReplicatedAssignmentPattern: return "ReplicatedAssignmentPattern";
+        case SyntaxKind::ResetAllDirective: return "ResetAllDirective";
+        case SyntaxKind::RestrictPropertyStatement: return "RestrictPropertyStatement";
+        case SyntaxKind::ReturnStatement: return "ReturnStatement";
+        case SyntaxKind::RootScope: return "RootScope";
+        case SyntaxKind::SAlwaysPropertyExpression: return "SAlwaysPropertyExpression";
+        case SyntaxKind::SEventuallyPropertyExpression: return "SEventuallyPropertyExpression";
+        case SyntaxKind::SNextTimePropertyExpression: return "SNextTimePropertyExpression";
+        case SyntaxKind::SUntilPropertyExpression: return "SUntilPropertyExpression";
+        case SyntaxKind::SUntilWithPropertyExpression: return "SUntilWithPropertyExpression";
+        case SyntaxKind::ScopedName: return "ScopedName";
+        case SyntaxKind::SequenceDeclaration: return "SequenceDeclaration";
+        case SyntaxKind::SequenceType: return "SequenceType";
+        case SyntaxKind::SequentialBlockStatement: return "SequentialBlockStatement";
+        case SyntaxKind::ShortIntType: return "ShortIntType";
+        case SyntaxKind::ShortRealType: return "ShortRealType";
+        case SyntaxKind::ShortcutCycleDelayRange: return "ShortcutCycleDelayRange";
+        case SyntaxKind::SignalEventExpression: return "SignalEventExpression";
+        case SyntaxKind::SignedCastExpression: return "SignedCastExpression";
+        case SyntaxKind::SimpleAssignmentPattern: return "SimpleAssignmentPattern";
+        case SyntaxKind::SimplePragmaExpression: return "SimplePragmaExpression";
+        case SyntaxKind::SimpleRangeSelect: return "SimpleRangeSelect";
+        case SyntaxKind::SolveBeforeConstraint: return "SolveBeforeConstraint";
+        case SyntaxKind::StandardCaseItem: return "StandardCaseItem";
+        case SyntaxKind::StreamExpression: return "StreamExpression";
+        case SyntaxKind::StreamExpressionWithRange: return "StreamExpressionWithRange";
+        case SyntaxKind::StreamingConcatenationExpression: return "StreamingConcatenationExpression";
+        case SyntaxKind::StringLiteralExpression: return "StringLiteralExpression";
+        case SyntaxKind::StringType: return "StringType";
+        case SyntaxKind::StructType: return "StructType";
+        case SyntaxKind::StructUnionMember: return "StructUnionMember";
+        case SyntaxKind::StructurePattern: return "StructurePattern";
+        case SyntaxKind::StructuredAssignmentPattern: return "StructuredAssignmentPattern";
+        case SyntaxKind::SubtractAssignmentExpression: return "SubtractAssignmentExpression";
+        case SyntaxKind::SubtractExpression: return "SubtractExpression";
+        case SyntaxKind::SuperHandle: return "SuperHandle";
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return "SyncAcceptOnPropertyExpression";
+        case SyntaxKind::SyncRejectOnPropertyExpression: return "SyncRejectOnPropertyExpression";
+        case SyntaxKind::SystemName: return "SystemName";
+        case SyntaxKind::TaggedPattern: return "TaggedPattern";
+        case SyntaxKind::TaggedUnionExpression: return "TaggedUnionExpression";
+        case SyntaxKind::TaskDeclaration: return "TaskDeclaration";
+        case SyntaxKind::ThisHandle: return "ThisHandle";
+        case SyntaxKind::ThroughoutSequenceExpression: return "ThroughoutSequenceExpression";
+        case SyntaxKind::TimeLiteralExpression: return "TimeLiteralExpression";
+        case SyntaxKind::TimeScaleDirective: return "TimeScaleDirective";
+        case SyntaxKind::TimeType: return "TimeType";
+        case SyntaxKind::TimeUnitsDeclaration: return "TimeUnitsDeclaration";
+        case SyntaxKind::TimingControlExpression: return "TimingControlExpression";
+        case SyntaxKind::TimingControlExpressionConcatenation: return "TimingControlExpressionConcatenation";
+        case SyntaxKind::TimingControlStatement: return "TimingControlStatement";
+        case SyntaxKind::TransListCoverageBinInitializer: return "TransListCoverageBinInitializer";
+        case SyntaxKind::TransRange: return "TransRange";
+        case SyntaxKind::TransRepeatRange: return "TransRepeatRange";
+        case SyntaxKind::TransSet: return "TransSet";
+        case SyntaxKind::TypeAssignment: return "TypeAssignment";
+        case SyntaxKind::TypeParameterDeclaration: return "TypeParameterDeclaration";
+        case SyntaxKind::TypeReference: return "TypeReference";
+        case SyntaxKind::TypedefDeclaration: return "TypedefDeclaration";
+        case SyntaxKind::UnaryBitwiseAndExpression: return "UnaryBitwiseAndExpression";
+        case SyntaxKind::UnaryBitwiseNandExpression: return "UnaryBitwiseNandExpression";
+        case SyntaxKind::UnaryBitwiseNorExpression: return "UnaryBitwiseNorExpression";
+        case SyntaxKind::UnaryBitwiseNotExpression: return "UnaryBitwiseNotExpression";
+        case SyntaxKind::UnaryBitwiseOrExpression: return "UnaryBitwiseOrExpression";
+        case SyntaxKind::UnaryBitwiseXnorExpression: return "UnaryBitwiseXnorExpression";
+        case SyntaxKind::UnaryBitwiseXorExpression: return "UnaryBitwiseXorExpression";
+        case SyntaxKind::UnaryLogicalNotExpression: return "UnaryLogicalNotExpression";
+        case SyntaxKind::UnaryMinusExpression: return "UnaryMinusExpression";
+        case SyntaxKind::UnaryNotPropertyExpression: return "UnaryNotPropertyExpression";
+        case SyntaxKind::UnaryPlusExpression: return "UnaryPlusExpression";
+        case SyntaxKind::UnaryPredecrementExpression: return "UnaryPredecrementExpression";
+        case SyntaxKind::UnaryPreincrementExpression: return "UnaryPreincrementExpression";
+        case SyntaxKind::UnarySequenceDelayExpression: return "UnarySequenceDelayExpression";
+        case SyntaxKind::UnarySequenceEventExpression: return "UnarySequenceEventExpression";
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return "UnbasedUnsizedLiteralExpression";
+        case SyntaxKind::UnconnectedDriveDirective: return "UnconnectedDriveDirective";
+        case SyntaxKind::UndefDirective: return "UndefDirective";
+        case SyntaxKind::UndefineAllDirective: return "UndefineAllDirective";
+        case SyntaxKind::UnionType: return "UnionType";
+        case SyntaxKind::UniquenessConstraint: return "UniquenessConstraint";
+        case SyntaxKind::UnitScope: return "UnitScope";
+        case SyntaxKind::UntilPropertyExpression: return "UntilPropertyExpression";
+        case SyntaxKind::UntilWithPropertyExpression: return "UntilWithPropertyExpression";
+        case SyntaxKind::Untyped: return "Untyped";
+        case SyntaxKind::VariableDimension: return "VariableDimension";
+        case SyntaxKind::VariablePattern: return "VariablePattern";
+        case SyntaxKind::VariablePortHeader: return "VariablePortHeader";
+        case SyntaxKind::VirtualInterfaceType: return "VirtualInterfaceType";
+        case SyntaxKind::VoidCastedCallStatement: return "VoidCastedCallStatement";
+        case SyntaxKind::VoidType: return "VoidType";
+        case SyntaxKind::WaitForkStatement: return "WaitForkStatement";
+        case SyntaxKind::WaitOrderStatement: return "WaitOrderStatement";
+        case SyntaxKind::WaitStatement: return "WaitStatement";
+        case SyntaxKind::WildcardDimensionSpecifier: return "WildcardDimensionSpecifier";
+        case SyntaxKind::WildcardEqualityExpression: return "WildcardEqualityExpression";
+        case SyntaxKind::WildcardInequalityExpression: return "WildcardInequalityExpression";
+        case SyntaxKind::WildcardLiteralExpression: return "WildcardLiteralExpression";
+        case SyntaxKind::WildcardPattern: return "WildcardPattern";
+        case SyntaxKind::WildcardPortConnection: return "WildcardPortConnection";
+        case SyntaxKind::WildcardPortList: return "WildcardPortList";
+        case SyntaxKind::WithClause: return "WithClause";
+        case SyntaxKind::WithFunctionClause: return "WithFunctionClause";
+        case SyntaxKind::WithFunctionSample: return "WithFunctionSample";
+        case SyntaxKind::WithinSequenceExpression: return "WithinSequenceExpression";
+        case SyntaxKind::XorAssignmentExpression: return "XorAssignmentExpression";
+        default: return "";
+    }
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/cmake_install.cmake ./generated/cmake_install.cmake
--- ./generated/cmake_install.cmake	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/cmake_install.cmake	2020-04-13 10:23:46.700499356 -0700
@@ -0,0 +1,63 @@
+# Install script for directory: /soe/renau/projs/synth/slang/source
+
+# Set the install prefix
+if(NOT DEFINED CMAKE_INSTALL_PREFIX)
+  set(CMAKE_INSTALL_PREFIX "/usr/local")
+endif()
+string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
+
+# Set the install configuration name.
+if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
+  if(BUILD_TYPE)
+    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
+           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
+  else()
+    set(CMAKE_INSTALL_CONFIG_NAME "Release")
+  endif()
+  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
+endif()
+
+# Set the component getting installed.
+if(NOT CMAKE_INSTALL_COMPONENT)
+  if(COMPONENT)
+    message(STATUS "Install component: \"${COMPONENT}\"")
+    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
+  else()
+    set(CMAKE_INSTALL_COMPONENT)
+  endif()
+endif()
+
+# Install shared libraries without execute permission?
+if(NOT DEFINED CMAKE_INSTALL_SO_NO_EXE)
+  set(CMAKE_INSTALL_SO_NO_EXE "1")
+endif()
+
+# Is this installation the result of a crosscompile?
+if(NOT DEFINED CMAKE_CROSSCOMPILING)
+  set(CMAKE_CROSSCOMPILING "FALSE")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/lib" TYPE STATIC_LIBRARY FILES "/soe/renau/projs/synth/slang/build/lib/libslang.a")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include" TYPE DIRECTORY FILES "/soe/renau/projs/synth/slang/source/../include/")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include" TYPE DIRECTORY FILES "/soe/renau/projs/synth/slang/source/../external/")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include/slang/diagnostics" TYPE DIRECTORY FILES "/soe/renau/projs/synth/slang/build/source/slang/diagnostics/")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include/slang/syntax" TYPE FILE FILES "/soe/renau/projs/synth/slang/build/source/slang/syntax/AllSyntax.h")
+endif()
+
+if("x${CMAKE_INSTALL_COMPONENT}x" STREQUAL "xUnspecifiedx" OR NOT CMAKE_INSTALL_COMPONENT)
+  file(INSTALL DESTINATION "${CMAKE_INSTALL_PREFIX}/include/slang/syntax" TYPE FILE FILES "/soe/renau/projs/synth/slang/build/source/slang/syntax/SyntaxKind.h")
+endif()
+
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/DiagCode.cpp ./generated/DiagCode.cpp
--- ./generated/DiagCode.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/DiagCode.cpp	2020-04-13 10:23:52.720371448 -0700
@@ -0,0 +1,438 @@
+//------------------------------------------------------------------------------
+// DiagCode.cpp
+// Generated diagnostic helpers
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#include "slang/diagnostics/AllDiags.h"
+
+#include <flat_hash_map.hpp>
+
+namespace slang {
+
+static const flat_hash_map<DiagCode, std::tuple<string_view, string_view, DiagnosticSeverity, string_view>> data = {
+    {diag::MaxInstanceDepthExceeded, std::make_tuple("MaxInstanceDepthExceeded"sv, "module instantiation exceeded maximum depth of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoteInCallTo, std::make_tuple("NoteInCallTo"sv, "in call to '{}'"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteSkippingFrames, std::make_tuple("NoteSkippingFrames"sv, "(skipping {} calls in backtrace; use --constexpr-backtrace-limit=0 to see all)"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::ConstEvalNonConstVariable, std::make_tuple("ConstEvalNonConstVariable"sv, "reference to non-constant variable '{}' is not allowed in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalArrayIndexInvalid, std::make_tuple("ConstEvalArrayIndexInvalid"sv, "cannot refer to element {} of array of type {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalPartSelectInvalid, std::make_tuple("ConstEvalPartSelectInvalid"sv, "cannot select range of {}:{} from array of type {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalStringIndexInvalid, std::make_tuple("ConstEvalStringIndexInvalid"sv, "cannot select index {} from string of length {} in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalReplicationCountInvalid, std::make_tuple("ConstEvalReplicationCountInvalid"sv, "string replication count {} is invalid in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalHierarchicalNameInCE, std::make_tuple("ConstEvalHierarchicalNameInCE"sv, "reference to '{}' by hierarchical name is not allowed in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionIdentifiersMustBeLocal, std::make_tuple("ConstEvalFunctionIdentifiersMustBeLocal"sv, "all identifiers that are not parameters or enums must be declared locally to a constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalIdUsedInCEBeforeDecl, std::make_tuple("ConstEvalIdUsedInCEBeforeDecl"sv, "identifier '{}' is declared after the invocation of the current constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalNoCaseItemsMatched, std::make_tuple("ConstEvalNoCaseItemsMatched"sv, "no items in {} case statement matched value {} in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalCaseItemsNotUnique, std::make_tuple("ConstEvalCaseItemsNotUnique"sv, "more than one match found in unique case statement for value {} in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalTimedStmtNotConst, std::make_tuple("ConstEvalTimedStmtNotConst"sv, "constant expressions cannot schedule events"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalAssertionFailed, std::make_tuple("ConstEvalAssertionFailed"sv, "assertion failed in constant function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalParallelBlockNotConst, std::make_tuple("ConstEvalParallelBlockNotConst"sv, "parallel blocks are not allowed in constant functions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalExceededMaxCallDepth, std::make_tuple("ConstEvalExceededMaxCallDepth"sv, "constant evaluation exceeded maximum depth of {} calls"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalExceededMaxSteps, std::make_tuple("ConstEvalExceededMaxSteps"sv, "constant evaluation hit maximum step limit; possible infinite loop?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalTaskNotConstant, std::make_tuple("ConstEvalTaskNotConstant"sv, "cannot invoke a task in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalVoidNotConstant, std::make_tuple("ConstEvalVoidNotConstant"sv, "cannot call a void function in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionArgDirection, std::make_tuple("ConstEvalFunctionArgDirection"sv, "cannot call a function with output, inout, or ref arguments in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalFunctionInsideGenerate, std::make_tuple("ConstEvalFunctionInsideGenerate"sv, "cannot call a function declared inside a generate block in a constant expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstEvalStaticSkipped, std::make_tuple("ConstEvalStaticSkipped"sv, "static variable initialization is skipped in constant function calls"sv, DiagnosticSeverity::Warning, "static-skipped"sv)},
+    {diag::LocalParamNoInitializer, std::make_tuple("LocalParamNoInitializer"sv, "local parameter is missing an initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BodyParamNoInitializer, std::make_tuple("BodyParamNoInitializer"sv, "parameter declaration is missing an initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidDimensionRange, std::make_tuple("InvalidDimensionRange"sv, "invalid dimension range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DimensionRequiresConstRange, std::make_tuple("DimensionRequiresConstRange"sv, "dimension requires a constant range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedDimsRequireFullRange, std::make_tuple("PackedDimsRequireFullRange"sv, "packed dimensions require a full range specification"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedParams, std::make_tuple("MixingOrderedAndNamedParams"sv, "mixing ordered and named parameter assignments is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateParamAssignment, std::make_tuple("DuplicateParamAssignment"sv, "duplicate assignment for parameter '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParamHasNoValue, std::make_tuple("ParamHasNoValue"sv, "instance of module '{}' does not provide a value for parameter '{}' and it does not have a default value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyParamAssignments, std::make_tuple("TooManyParamAssignments"sv, "too many parameter assignments given to instantiation of module '{}' ({} given, expected {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignedToLocalPortParam, std::make_tuple("AssignedToLocalPortParam"sv, "can't assign a value to a localparam"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignedToLocalBodyParam, std::make_tuple("AssignedToLocalBodyParam"sv, "can't assign a value to a localparam (parameters in the body of a module are implicitly local when you have a parameter port list)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParameterDoesNotExist, std::make_tuple("ParameterDoesNotExist"sv, "parameter '{}' does not exist in module '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadTypeParamExpr, std::make_tuple("BadTypeParamExpr"sv, "invalid initializer for type parameter '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortTypeNotInterfaceOrData, std::make_tuple("PortTypeNotInterfaceOrData"sv, "port type '{}' is neither an interface nor a data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VarWithInterfacePort, std::make_tuple("VarWithInterfacePort"sv, "'var' keyword may not be used with an interface port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectionWithInterfacePort, std::make_tuple("DirectionWithInterfacePort"sv, "port direction not allowed on an interface port"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InOutPortCannotBeVariable, std::make_tuple("InOutPortCannotBeVariable"sv, "variable port '{}' cannot have direction inout"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RefPortMustBeVariable, std::make_tuple("RefPortMustBeVariable"sv, "ref port '{}' cannot be of net type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingPortIODeclaration, std::make_tuple("MissingPortIODeclaration"sv, "port '{}' has no I/O member declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CantDeclarePortSigned, std::make_tuple("CantDeclarePortSigned"sv, "port '{}' cannot be declared signed because its type {} is not integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDeclDimensionsMismatch, std::make_tuple("PortDeclDimensionsMismatch"sv, "dimensions of port '{}' do not match its declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDeclInANSIModule, std::make_tuple("PortDeclInANSIModule"sv, "can't use port declaration in module with ANSI style port list"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownPackage, std::make_tuple("UnknownPackage"sv, "unknown package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownModule, std::make_tuple("UnknownModule"sv, "unknown module '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownInterface, std::make_tuple("UnknownInterface"sv, "unknown interface '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedPorts, std::make_tuple("MixingOrderedAndNamedPorts"sv, "mixing ordered and named port connections is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateWildcardPortConnection, std::make_tuple("DuplicateWildcardPortConnection"sv, "duplicate wildcard port connection"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicatePortConnection, std::make_tuple("DuplicatePortConnection"sv, "duplicate connection for port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyPortConnections, std::make_tuple("TooManyPortConnections"sv, "too many port connections given to instantiation of module '{}' ({} given, expected {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortDoesNotExist, std::make_tuple("PortDoesNotExist"sv, "port '{}' does not exist in module '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortConnDimensionsMismatch, std::make_tuple("PortConnDimensionsMismatch"sv, "dimensions of connection for port '{}' do not match its declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortNotConnected, std::make_tuple("InterfacePortNotConnected"sv, "interface port '{}' not connected"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortInvalidExpression, std::make_tuple("InterfacePortInvalidExpression"sv, "invalid expression for interface port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InterfacePortTypeMismatch, std::make_tuple("InterfacePortTypeMismatch"sv, "cannot connect instance of interface '{}' to port of interface '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MismatchedTimeScales, std::make_tuple("MismatchedTimeScales"sv, "duplicate time scale declaration must match previous value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TimeScaleFirstInScope, std::make_tuple("TimeScaleFirstInScope"sv, "time scale declaration must come before all other items in scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GenvarDuplicate, std::make_tuple("GenvarDuplicate"sv, "loop generation value {} repeats more than once"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::GenvarUnknownBits, std::make_tuple("GenvarUnknownBits"sv, "value of {} is invalid for loop generation value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNamedPortNotFound, std::make_tuple("ImplicitNamedPortNotFound"sv, "could not find connection for implicit named port '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNamedPortTypeMismatch, std::make_tuple("ImplicitNamedPortTypeMismatch"sv, "implicit named port '{}' of type {} connects to value of inequivalent type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MaxGenerateStepsExceeded, std::make_tuple("MaxGenerateStepsExceeded"sv, "generate loop hit maximum step limit; possible infinite loop?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingSubroutinePortKinds, std::make_tuple("MixingSubroutinePortKinds"sv, "port declarations not allowed when subroutine defines a formal argument list"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnpackedArrayParamType, std::make_tuple("UnpackedArrayParamType"sv, "unpacked array parameter requires explicit data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutomaticNotAllowed, std::make_tuple("AutomaticNotAllowed"sv, "automatic variables can only be declared in procedural contexts"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::StaticInitializerMustBeExplicit, std::make_tuple("StaticInitializerMustBeExplicit"sv, "initializing a static variable in a procedural context requires an explicit 'static' keyword"sv, DiagnosticSeverity::Warning, "explicit-static"sv)},
+    {diag::CaseGenerateDup, std::make_tuple("CaseGenerateDup"sv, "more than one case generate block matches the value {}"sv, DiagnosticSeverity::Warning, "case-gen-dup"sv)},
+    {diag::CaseGenerateNoBlock, std::make_tuple("CaseGenerateNoBlock"sv, "no case generate expression matches the value {}"sv, DiagnosticSeverity::Warning, "case-gen-none"sv)},
+    {diag::UnconnectedNamedPort, std::make_tuple("UnconnectedNamedPort"sv, "port '{}' has no connection"sv, DiagnosticSeverity::Warning, "unconnected-port"sv)},
+    {diag::UnconnectedUnnamedPort, std::make_tuple("UnconnectedUnnamedPort"sv, "instance does not provide a connection for an unnamed port"sv, DiagnosticSeverity::Warning, "unconnected-unnamed-port"sv)},
+    {diag::ImplicitNetPortNoDefault, std::make_tuple("ImplicitNetPortNoDefault"sv, "implicit net port disallowed because `default_nettype is set to 'none'"sv, DiagnosticSeverity::Warning, "implicit-net-port"sv)},
+    {diag::DuplicateAttribute, std::make_tuple("DuplicateAttribute"sv, "duplicate attribute definition '{}'; taking last value"sv, DiagnosticSeverity::Warning, "dup-attr"sv)},
+    {diag::EmptyMember, std::make_tuple("EmptyMember"sv, "empty member has no effect"sv, DiagnosticSeverity::Warning, "empty-member"sv)},
+    {diag::BadUnaryExpression, std::make_tuple("BadUnaryExpression"sv, "invalid operand type {} to unary expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadBinaryExpression, std::make_tuple("BadBinaryExpression"sv, "invalid operands to binary expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConditionalExpression, std::make_tuple("BadConditionalExpression"sv, "invalid operands to conditional expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadIndexExpression, std::make_tuple("BadIndexExpression"sv, "value of type {} cannot be indexed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConcatExpression, std::make_tuple("BadConcatExpression"sv, "invalid operand type {} in concatenation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadReplicationExpression, std::make_tuple("BadReplicationExpression"sv, "invalid operands to replication expression ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadOpenRange, std::make_tuple("BadOpenRange"sv, "invalid bounds in open range ({} and {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadCastType, std::make_tuple("BadCastType"sv, "invalid casting type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadSetMembershipType, std::make_tuple("BadSetMembershipType"sv, "invalid type {} for {} expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConcatWithStringInt, std::make_tuple("ConcatWithStringInt"sv, "cannot mix strings and integers in a concatenation (use a cast if this is desired)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadRangeExpression, std::make_tuple("BadRangeExpression"sv, "cannot select range of {}:{} from array of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RangeWidthTooLarge, std::make_tuple("RangeWidthTooLarge"sv, "cannot select range of {} elements from array of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CannotIndexScalar, std::make_tuple("CannotIndexScalar"sv, "scalar type cannot be indexed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExprMustBeIntegral, std::make_tuple("ExprMustBeIntegral"sv, "expression must be integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IndexValueInvalid, std::make_tuple("IndexValueInvalid"sv, "cannot refer to element {} of array of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SelectEndianMismatch, std::make_tuple("SelectEndianMismatch"sv, "endianness of selection must match declared range (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadAssignment, std::make_tuple("BadAssignment"sv, "value of type {} cannot be assigned to type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadConversion, std::make_tuple("BadConversion"sv, "value of type {} cannot be converted to type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadIntegerCast, std::make_tuple("BadIntegerCast"sv, "cannot change width or signedness of non-integral expression (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoImplicitConversion, std::make_tuple("NoImplicitConversion"sv, "no implicit conversion from {} to {}; explicit conversion exists, are you missing a cast?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyArguments, std::make_tuple("TooManyArguments"sv, "too many arguments to subroutine call; expected {} but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooFewArguments, std::make_tuple("TooFewArguments"sv, "too few arguments to subroutine call; expected {} but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpressionNotAssignable, std::make_tuple("ExpressionNotAssignable"sv, "expression is not assignable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ReplicationZeroOutsideConcat, std::make_tuple("ReplicationZeroOutsideConcat"sv, "replication constant can only be zero inside of a concatenation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMemberAccess, std::make_tuple("InvalidMemberAccess"sv, "invalid member access for type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpressionNotCallable, std::make_tuple("ExpressionNotCallable"sv, "expression is not callable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotBooleanConvertible, std::make_tuple("NotBooleanConvertible"sv, "value of type {} is not convertible to a boolean predicate"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueSizeMismatch, std::make_tuple("EnumValueSizeMismatch"sv, "expression width of {} does not exactly match declared enum type width of {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueUnknownBits, std::make_tuple("EnumValueUnknownBits"sv, "value of {} is invalid for enum with base type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoCommonComparisonType, std::make_tuple("NoCommonComparisonType"sv, "{} expression of type {} is not comparable to common type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNoContext, std::make_tuple("AssignmentPatternNoContext"sv, "assignment pattern target type cannot be deduced in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadAssignmentPatternType, std::make_tuple("BadAssignmentPatternType"sv, "invalid target type {} for assignment pattern"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WrongNumberAssignmentPatterns, std::make_tuple("WrongNumberAssignmentPatterns"sv, "assignment pattern for type {} requires {} elements but {} were provided"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyExpr, std::make_tuple("AssignmentPatternKeyExpr"sv, "expression is not a valid assignment pattern member name or type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupDefault, std::make_tuple("AssignmentPatternKeyDupDefault"sv, "assignment pattern has multiple default keys"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupValue, std::make_tuple("AssignmentPatternKeyDupValue"sv, "assignment pattern has multiple keys for value {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternKeyDupName, std::make_tuple("AssignmentPatternKeyDupName"sv, "assignment pattern has multiple keys for member '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNoMember, std::make_tuple("AssignmentPatternNoMember"sv, "member '{}' is not covered by any assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternNestedNoMember, std::make_tuple("AssignmentPatternNestedNoMember"sv, "member '{}' has nested elements that are not covered by any assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentPatternMissingElements, std::make_tuple("AssignmentPatternMissingElements"sv, "not all elements of array are covered by an assignment pattern key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EmptyArgNotAllowed, std::make_tuple("EmptyArgNotAllowed"sv, "empty argument not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NamedArgNotAllowed, std::make_tuple("NamedArgNotAllowed"sv, "named argument not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateArgAssignment, std::make_tuple("DuplicateArgAssignment"sv, "duplicate assignment for argument '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MixingOrderedAndNamedArgs, std::make_tuple("MixingOrderedAndNamedArgs"sv, "ordered arguments are not allowed after named arguments"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArgDoesNotExist, std::make_tuple("ArgDoesNotExist"sv, "argument '{}' does not exist in subroutine '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArgCannotBeEmpty, std::make_tuple("ArgCannotBeEmpty"sv, "argument '{}' cannot be empty because it does not have a default value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnconnectedArg, std::make_tuple("UnconnectedArg"sv, "argument '{}' is missing a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingReturnValue, std::make_tuple("MissingReturnValue"sv, "must provide a return value for non-void function"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentNotAllowed, std::make_tuple("AssignmentNotAllowed"sv, "assignment expressions are not allowed in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IncDecNotAllowed, std::make_tuple("IncDecNotAllowed"sv, "increment and decrement expressions are not allowed in this context"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentRequiresParens, std::make_tuple("AssignmentRequiresParens"sv, "assignment expressions must be parenthesized"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PortConnArrayMismatch, std::make_tuple("PortConnArrayMismatch"sv, "cannot connect {} to each port of type {} in '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutoFromStaticInit, std::make_tuple("AutoFromStaticInit"sv, "cannot refer to automatic variable '{}' from static initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonblockingAssignmentToAuto, std::make_tuple("NonblockingAssignmentToAuto"sv, "nonblocking assignment to automatic variable '{}' is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AssignmentToConst, std::make_tuple("AssignmentToConst"sv, "cannot assign to read-only variable '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotYetSupported, std::make_tuple("NotYetSupported"sv, "language feature not yet supported"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedExpression, std::make_tuple("ExpectedExpression"sv, "expected expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotePreviousDefinition, std::make_tuple("NotePreviousDefinition"sv, "previous definition here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NotePreviousUsage, std::make_tuple("NotePreviousUsage"sv, "previous usage here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteDeclarationHere, std::make_tuple("NoteDeclarationHere"sv, "declared here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NotePreviousMatch, std::make_tuple("NotePreviousMatch"sv, "previous match here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::AttributesNotAllowed, std::make_tuple("AttributesNotAllowed"sv, "attributes are not allowed here"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::WarnNotYetSupported, std::make_tuple("WarnNotYetSupported"sv, "language feature not yet supported"sv, DiagnosticSeverity::Warning, "not-supported"sv)},
+    {diag::NonPrintableChar, std::make_tuple("NonPrintableChar"sv, "non-printable character in source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UTF8Char, std::make_tuple("UTF8Char"sv, "UTF-8 sequence in source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnicodeBOM, std::make_tuple("UnicodeBOM"sv, "Unicode BOM at start of source text; SystemVerilog only supports ASCII text"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EmbeddedNull, std::make_tuple("EmbeddedNull"sv, "embedded NUL in source text; are you sure this is source code?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MisplacedDirectiveChar, std::make_tuple("MisplacedDirectiveChar"sv, "expected directive name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EscapedWhitespace, std::make_tuple("EscapedWhitespace"sv, "unexpected whitespace after escape character"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClosingQuote, std::make_tuple("ExpectedClosingQuote"sv, "missing closing quote"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnterminatedBlockComment, std::make_tuple("UnterminatedBlockComment"sv, "block comment unclosed at end of file"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NestedBlockComment, std::make_tuple("NestedBlockComment"sv, "nested block comments are disallowed by SystemVerilog"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIntegerBaseAfterSigned, std::make_tuple("ExpectedIntegerBaseAfterSigned"sv, "expected integer base specifier after signed specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingFractionalDigits, std::make_tuple("MissingFractionalDigits"sv, "expected fractional digits after decimal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::OctalEscapeCodeTooBig, std::make_tuple("OctalEscapeCodeTooBig"sv, "octal escape code is too large to be an ASCII character"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidHexEscapeCode, std::make_tuple("InvalidHexEscapeCode"sv, "invalid hexadecimal number"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownEscapeCode, std::make_tuple("UnknownEscapeCode"sv, "unknown character escape sequence"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingExponentDigits, std::make_tuple("MissingExponentDigits"sv, "expected exponent digits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DigitsLeadingUnderscore, std::make_tuple("DigitsLeadingUnderscore"sv, "numeric literals must not start with a leading underscore"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DecimalDigitMultipleUnknown, std::make_tuple("DecimalDigitMultipleUnknown"sv, "decimal literals cannot have multiple digits if at least one of them is X or Z"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadBinaryDigit, std::make_tuple("BadBinaryDigit"sv, "expected binary digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadOctalDigit, std::make_tuple("BadOctalDigit"sv, "expected octal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadDecimalDigit, std::make_tuple("BadDecimalDigit"sv, "expected decimal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadHexDigit, std::make_tuple("BadHexDigit"sv, "expected hexadecimal digit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyLexerErrors, std::make_tuple("TooManyLexerErrors"sv, "lexer has encountered too many errors (input is a binary file?)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::Redefinition, std::make_tuple("Redefinition"sv, "redefinition of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RedefinitionDifferentType, std::make_tuple("RedefinitionDifferentType"sv, "redefinition of '{}' with a different type: {} vs {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RedefinitionDifferentSymbolKind, std::make_tuple("RedefinitionDifferentSymbolKind"sv, "redefinition of '{}' as different kind of symbol"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AmbiguousWildcardImport, std::make_tuple("AmbiguousWildcardImport"sv, "multiple imports found for identifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoteImportedFrom, std::make_tuple("NoteImportedFrom"sv, "imported from here"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::NoteHierarchicalNameInCE, std::make_tuple("NoteHierarchicalNameInCE"sv, "reference to '{}' by hierarchical name is not allowed in a constant expression"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::ImportNameCollision, std::make_tuple("ImportNameCollision"sv, "import of '{}' collides with an existing declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UndeclaredIdentifier, std::make_tuple("UndeclaredIdentifier"sv, "use of undeclared identifier '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TypoIdentifier, std::make_tuple("TypoIdentifier"sv, "use of undeclared identifier '{}'; did you mean '{}'?"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownSystemName, std::make_tuple("UnknownSystemName"sv, "unknown system name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownClassOrPackage, std::make_tuple("UnknownClassOrPackage"sv, "unknown class or package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UsedBeforeDeclared, std::make_tuple("UsedBeforeDeclared"sv, "identifier '{}' used before its declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAType, std::make_tuple("NotAType"sv, "'{}' is not a type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAValue, std::make_tuple("NotAValue"sv, "'{}' does not refer to a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAHierarchicalScope, std::make_tuple("NotAHierarchicalScope"sv, "cannot use dot operator on '{}'; it is not a variable or hierarchical scope"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAModport, std::make_tuple("NotAModport"sv, "'{}' is not a modport of '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAnInterface, std::make_tuple("NotAnInterface"sv, "'{}' is not an interface instance or array of instances"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAGenvar, std::make_tuple("NotAGenvar"sv, "'{}' is not a genvar"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DotOnType, std::make_tuple("DotOnType"sv, "cannot use dot operator on a type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::HierarchicalNotAllowedInConstant, std::make_tuple("HierarchicalNotAllowedInConstant"sv, "hierarchical names are not allowed in constant expressions"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownMember, std::make_tuple("UnknownMember"sv, "no member named '{}' in {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownPackageMember, std::make_tuple("UnknownPackageMember"sv, "no member named '{}' in package '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownUnitMember, std::make_tuple("UnknownUnitMember"sv, "no member named '{}' in compilation unit"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RecursiveDefinition, std::make_tuple("RecursiveDefinition"sv, "'{}' recursively depends on its own definition"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownSystemMethod, std::make_tuple("UnknownSystemMethod"sv, "unknown built-in method '{}' on type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopeNotIndexable, std::make_tuple("ScopeNotIndexable"sv, "hierarchical scope '{}' is not indexable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidScopeIndexExpression, std::make_tuple("InvalidScopeIndexExpression"sv, "invalid hierarchical index expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ScopeIndexOutOfRange, std::make_tuple("ScopeIndexOutOfRange"sv, "hierarchical index {} is out of scope's declared range"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CouldNotResolveHierarchicalPath, std::make_tuple("CouldNotResolveHierarchicalPath"sv, "could not resolve hierarchical path name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnresolvedForwardTypedef, std::make_tuple("UnresolvedForwardTypedef"sv, "forward typedef '{}' does not resolve to a data type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefinitionUsedAsType, std::make_tuple("DefinitionUsedAsType"sv, "'{}' is {} definition but is used like a type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DefinitionUsedAsValue, std::make_tuple("DefinitionUsedAsValue"sv, "'{}' is {} definition but is used as a value"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::AutoVariableHierarchical, std::make_tuple("AutoVariableHierarchical"sv, "cannot refer to automatic variable via hierarchical reference"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateImport, std::make_tuple("DuplicateImport"sv, "duplicate import declaration is redundant"sv, DiagnosticSeverity::Warning, "dup-import"sv)},
+    {diag::TooManyErrors, std::make_tuple("TooManyErrors"sv, "too many errors emitted, stopping now [--error-limit=]"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownWarningOption, std::make_tuple("UnknownWarningOption"sv, "unknown warning option '{}'"sv, DiagnosticSeverity::Warning, "unknown-warning-option"sv)},
+    {diag::LiteralSizeIsZero, std::make_tuple("LiteralSizeIsZero"sv, "size of vector literal cannot be zero"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LiteralSizeTooLarge, std::make_tuple("LiteralSizeTooLarge"sv, "size of vector literal is too large (> {} bits)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SignedIntegerOverflow, std::make_tuple("SignedIntegerOverflow"sv, "signed integer overflows 32 bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustBeIntegral, std::make_tuple("ValueMustBeIntegral"sv, "value must be integral"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustNotBeUnknown, std::make_tuple("ValueMustNotBeUnknown"sv, "value must not have any unknown bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueMustBePositive, std::make_tuple("ValueMustBePositive"sv, "value must be positive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueExceedsMaxBitWidth, std::make_tuple("ValueExceedsMaxBitWidth"sv, "value exceeds maximum vector width ({} bits)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ValueOutOfRange, std::make_tuple("ValueOutOfRange"sv, "{} is out of allowed range ({} to {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedVectorDigits, std::make_tuple("ExpectedVectorDigits"sv, "expected vector literal digits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RealLiteralUnderflow, std::make_tuple("RealLiteralUnderflow"sv, "value of real literal is too small; minimum is {:.5e}"sv, DiagnosticSeverity::Warning, "real-underflow"sv)},
+    {diag::RealLiteralOverflow, std::make_tuple("RealLiteralOverflow"sv, "value of real literal is too large; maximum is {:.5e}"sv, DiagnosticSeverity::Warning, "real-overflow"sv)},
+    {diag::VectorLiteralOverflow, std::make_tuple("VectorLiteralOverflow"sv, "vector literal too large for the given number of bits"sv, DiagnosticSeverity::Warning, "literal-overflow"sv)},
+    {diag::ExpectedIdentifier, std::make_tuple("ExpectedIdentifier"sv, "expected identifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStringLiteral, std::make_tuple("ExpectedStringLiteral"sv, "expected string literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIntegerLiteral, std::make_tuple("ExpectedIntegerLiteral"sv, "expected integer literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedToken, std::make_tuple("ExpectedToken"sv, "expected '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MisplacedTrailingSeparator, std::make_tuple("MisplacedTrailingSeparator"sv, "misplaced trailing '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ImplicitNotAllowed, std::make_tuple("ImplicitNotAllowed"sv, "expected data type (implicit type name not allowed)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidAccessDotColon, std::make_tuple("InvalidAccessDotColon"sv, "invalid access token; '{}' should be '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMember, std::make_tuple("ExpectedMember"sv, "expected member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStatement, std::make_tuple("ExpectedStatement"sv, "expected statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedParameterPort, std::make_tuple("ExpectedParameterPort"sv, "expected parameter declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNonAnsiPort, std::make_tuple("ExpectedNonAnsiPort"sv, "expected non-ansi port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAnsiPort, std::make_tuple("ExpectedAnsiPort"sv, "expected ansi port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedModportPort, std::make_tuple("ExpectedModportPort"sv, "expected modport item port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedFunctionPort, std::make_tuple("ExpectedFunctionPort"sv, "expected subroutine port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAssertionItemPort, std::make_tuple("ExpectedAssertionItemPort"sv, "expected assertion item construct port declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedForInitializer, std::make_tuple("ExpectedForInitializer"sv, "expected for loop initializer"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedOpenRangeElement, std::make_tuple("ExpectedOpenRangeElement"sv, "expected open range element"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedStreamExpression, std::make_tuple("ExpectedStreamExpression"sv, "expected stream expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedArgument, std::make_tuple("ExpectedArgument"sv, "expected argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDeclarator, std::make_tuple("ExpectedDeclarator"sv, "expected declarator"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedConditionalPattern, std::make_tuple("ExpectedConditionalPattern"sv, "expected conditional pattern"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAttribute, std::make_tuple("ExpectedAttribute"sv, "expected attribute"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPackageImport, std::make_tuple("ExpectedPackageImport"sv, "expected package import"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedHierarchicalInstantiation, std::make_tuple("ExpectedHierarchicalInstantiation"sv, "expected hierarchical instantiation"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedGateInstance, std::make_tuple("ExpectedGateInstance"sv, "expected gate instance"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPortConnection, std::make_tuple("ExpectedPortConnection"sv, "expected port connection"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedVariableAssignment, std::make_tuple("ExpectedVariableAssignment"sv, "expected variable assignment"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedContinuousAssignment, std::make_tuple("ExpectedContinuousAssignment"sv, "expected continuous assignment"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedInterfaceClassName, std::make_tuple("ExpectedInterfaceClassName"sv, "expected interface class name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedAssignmentKey, std::make_tuple("ExpectedAssignmentKey"sv, "expected assignment key"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDistItem, std::make_tuple("ExpectedDistItem"sv, "expected dist item"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIfOrCase, std::make_tuple("ExpectedIfOrCase"sv, "expected 'if' or 'case' after '{}' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClassScope, std::make_tuple("ExpectedClassScope"sv, "expected class scope before new keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNetStrength, std::make_tuple("ExpectedNetStrength"sv, "expected net strength keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedEnumBase, std::make_tuple("ExpectedEnumBase"sv, "expected enum base type"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedCaseItem, std::make_tuple("ExpectedCaseItem"sv, "expected case item"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NoLabelOnSemicolon, std::make_tuple("NoLabelOnSemicolon"sv, "labels are not allowed on empty semicolon"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeferredDelayMustBeZero, std::make_tuple("DeferredDelayMustBeZero"sv, "deferred assertion delay must be zero"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidGenvarIterExpression, std::make_tuple("InvalidGenvarIterExpression"sv, "invalid genvar iteration expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedGenvarIterVar, std::make_tuple("ExpectedGenvarIterVar"sv, "expected genvar iteration variable"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ConstFunctionPortRequiresRef, std::make_tuple("ConstFunctionPortRequiresRef"sv, "'const' in subroutine formal port requires 'ref' direction specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedClockingSkew, std::make_tuple("ExpectedClockingSkew"sv, "expected clocking skew"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDPISpecString, std::make_tuple("ExpectedDPISpecString"sv, "expected DPI spec string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ParseTreeTooDeep, std::make_tuple("ParseTreeTooDeep"sv, "language constructs are too deeply nested"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingModportPortDirection, std::make_tuple("MissingModportPortDirection"sv, "modport port declaration is missing direction specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseStatementEmpty, std::make_tuple("CaseStatementEmpty"sv, "{} statement has no items"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MultipleDefaultCases, std::make_tuple("MultipleDefaultCases"sv, "{} statement has multiple default cases"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectionOnInterfacePort, std::make_tuple("DirectionOnInterfacePort"sv, "direction specifier on interface port is not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedQualifiers, std::make_tuple("UnexpectedQualifiers"sv, "unexpected qualifiers on class member"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedSampleKeyword, std::make_tuple("ExpectedSampleKeyword"sv, "expected 'sample' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MultipleGenerateDefaultCases, std::make_tuple("MultipleGenerateDefaultCases"sv, "case generate has multiple default cases"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseGenerateEmpty, std::make_tuple("CaseGenerateEmpty"sv, "case generate has no items"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LabelAndName, std::make_tuple("LabelAndName"sv, "cannot specify both a label and a name for the same block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EndNameMismatch, std::make_tuple("EndNameMismatch"sv, "'{}' doesn't match previous name '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EndNameNotEmpty, std::make_tuple("EndNameNotEmpty"sv, "trailing name not allowed on previously unnamed block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclarationsAtStart, std::make_tuple("DeclarationsAtStart"sv, "declaration must come before all statements in the block"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VoidNotAllowed, std::make_tuple("VoidNotAllowed"sv, "'void' type not allowed"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DuplicateDeclModifier, std::make_tuple("DuplicateDeclModifier"sv, "duplicate '{}' modifier in declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclModifierOrdering, std::make_tuple("DeclModifierOrdering"sv, "modifier '{}' must come before '{}' in a declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DeclModifierConflict, std::make_tuple("DeclModifierConflict"sv, "modifier '{}' cannot be used together with '{}' in a declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TypeRefDeclVar, std::make_tuple("TypeRefDeclVar"sv, "a type reference cannot be used in a variable declaration without a preceeding 'var' keyword"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NonStandardGenBlock, std::make_tuple("NonStandardGenBlock"sv, "standalone generate block without loop or condition is not allowed in SystemVerilog"sv, DiagnosticSeverity::Warning, "nonstandard-generate"sv)},
+    {diag::NoteToMatchThis, std::make_tuple("NoteToMatchThis"sv, "to match this '{}'"sv, DiagnosticSeverity::Note, ""sv)},
+    {diag::CouldNotOpenIncludeFile, std::make_tuple("CouldNotOpenIncludeFile"sv, "could not find or open include file"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExceededMaxIncludeDepth, std::make_tuple("ExceededMaxIncludeDepth"sv, "exceeded max include depth"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownDirective, std::make_tuple("UnknownDirective"sv, "unknown macro or compiler directive '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnexpectedConditionalDirective, std::make_tuple("UnexpectedConditionalDirective"sv, "unexpected conditional directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingEndIfDirective, std::make_tuple("MissingEndIfDirective"sv, "missing `endif directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnbalancedMacroArgDims, std::make_tuple("UnbalancedMacroArgDims"sv, "unbalanced macro argument delimiters ((), [], or {{}}); didn't see an end '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMacroArgs, std::make_tuple("ExpectedMacroArgs"sv, "expected macro arguments for function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedNetType, std::make_tuple("ExpectedNetType"sv, "expected net type specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedDriveStrength, std::make_tuple("ExpectedDriveStrength"sv, "expected pull1 or pull0 strength"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidMacroName, std::make_tuple("InvalidMacroName"sv, "can't redefine compiler directive as a macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyActualMacroArgs, std::make_tuple("TooManyActualMacroArgs"sv, "too many arguments provided to function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotEnoughMacroArgs, std::make_tuple("NotEnoughMacroArgs"sv, "not enough arguments provided to function-like macro"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidLineDirectiveLevel, std::make_tuple("InvalidLineDirectiveLevel"sv, "invalid level for `line directive, must be 0, 1, or 2"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UndefineBuiltinDirective, std::make_tuple("UndefineBuiltinDirective"sv, "cannot `undef built-in directives"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnrecognizedKeywordVersion, std::make_tuple("UnrecognizedKeywordVersion"sv, "unsupported keyword version specified for `begin_keywords"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MismatchedEndKeywordsDirective, std::make_tuple("MismatchedEndKeywordsDirective"sv, "no opening `begin_keywords directive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidTimeScaleSpecifier, std::make_tuple("InvalidTimeScaleSpecifier"sv, "time scale must have a value of 1, 10, or 100"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidTimeScalePrecision, std::make_tuple("InvalidTimeScalePrecision"sv, "time precision must be at least as precise as the time unit (i.e. it cannot be a longer unit of time)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::RecursiveMacro, std::make_tuple("RecursiveMacro"sv, "expansion of macro '{}' is recursive"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MacroOpsOutsideDefinition, std::make_tuple("MacroOpsOutsideDefinition"sv, "macro operators may only be used within a macro definition"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::SplitBlockCommentInDirective, std::make_tuple("SplitBlockCommentInDirective"sv, "block comments on the same line as a directive must also be terminated on that line"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedIncludeFileName, std::make_tuple("ExpectedIncludeFileName"sv, "expected an include file name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedTimeLiteral, std::make_tuple("ExpectedTimeLiteral"sv, "expected time literal"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedMacroStringifyEnd, std::make_tuple("ExpectedMacroStringifyEnd"sv, "expected closing quote to end macro stringification"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPragmaName, std::make_tuple("ExpectedPragmaName"sv, "expected pragma name"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExpectedPragmaExpression, std::make_tuple("ExpectedPragmaExpression"sv, "expected pragma expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DirectiveInsideDesignElement, std::make_tuple("DirectiveInsideDesignElement"sv, "directive is not allowed inside a design element"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::IgnoredMacroPaste, std::make_tuple("IgnoredMacroPaste"sv, "paste token is pointless because it is adjacent to whitespace"sv, DiagnosticSeverity::Warning, "ignored-macro-paste"sv)},
+    {diag::RedefiningMacro, std::make_tuple("RedefiningMacro"sv, "macro '{}' redefined"sv, DiagnosticSeverity::Warning, "redef-macro"sv)},
+    {diag::UnknownPragma, std::make_tuple("UnknownPragma"sv, "unknown pragma '{}'"sv, DiagnosticSeverity::Warning, "unknown-pragma"sv)},
+    {diag::ExtraPragmaArgs, std::make_tuple("ExtraPragmaArgs"sv, "too many arguments provided for pragma '{}'"sv, DiagnosticSeverity::Warning, "extra-pragma-args"sv)},
+    {diag::ExpectedDiagPragmaArg, std::make_tuple("ExpectedDiagPragmaArg"sv, "expected diagnostic pragma argument"sv, DiagnosticSeverity::Warning, "expected-diag-arg"sv)},
+    {diag::UnknownDiagPragmaArg, std::make_tuple("UnknownDiagPragmaArg"sv, "unknown diagnostic pragma argument '{}'"sv, DiagnosticSeverity::Warning, "unknown-diag-arg"sv)},
+    {diag::ExpectedDiagPragmaLevel, std::make_tuple("ExpectedDiagPragmaLevel"sv, "expected diagnostic severity (ignore,warn,error,fatal)"sv, DiagnosticSeverity::Warning, "pragma-diag-level"sv)},
+    {diag::ReturnNotInSubroutine, std::make_tuple("ReturnNotInSubroutine"sv, "return statement is only valid inside task and function blocks"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::DelayNotNumeric, std::make_tuple("DelayNotNumeric"sv, "delay expression type {} is not numeric"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidEventExpression, std::make_tuple("InvalidEventExpression"sv, "invalid type {} for event expression"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CoverStmtNoFail, std::make_tuple("CoverStmtNoFail"sv, "cover statement cannot have a fail statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::StatementNotInLoop, std::make_tuple("StatementNotInLoop"sv, "statement can only be used inside a loop"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ExprNotStatement, std::make_tuple("ExprNotStatement"sv, "expression is not allowed as a statement"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::VoidCastFuncCall, std::make_tuple("VoidCastFuncCall"sv, "void casting is only allowed for function calls"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::NotAnArray, std::make_tuple("NotAnArray"sv, "name must refer to an array"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::TooManyForeachVars, std::make_tuple("TooManyForeachVars"sv, "too many loop variables for array of type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::LoopVarShadowsArray, std::make_tuple("LoopVarShadowsArray"sv, "loop variable '{}' shadows foreach array target"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::CaseInsideKeyword, std::make_tuple("CaseInsideKeyword"sv, "set membership cannot be used with {} statements"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EventExpressionConstant, std::make_tuple("EventExpressionConstant"sv, "edge expression is constant"sv, DiagnosticSeverity::Warning, "event-const"sv)},
+    {diag::EmptyStatement, std::make_tuple("EmptyStatement"sv, "empty statement has no effect"sv, DiagnosticSeverity::Warning, "empty-stmt"sv)},
+    {diag::PointlessVoidCast, std::make_tuple("PointlessVoidCast"sv, "cast to void for void-returning function '{}' has no effect"sv, DiagnosticSeverity::Warning, "pointless-void-cast"sv)},
+    {diag::UnusedResult, std::make_tuple("UnusedResult"sv, "ignoring return value of '{}', cast to void to suppress"sv, DiagnosticSeverity::Warning, "unused-result"sv)},
+    {diag::BadSystemSubroutineArg, std::make_tuple("BadSystemSubroutineArg"sv, "invalid argument type {} to system {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::UnknownFormatSpecifier, std::make_tuple("UnknownFormatSpecifier"sv, "unknown format specifier '%{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::MissingFormatSpecifier, std::make_tuple("MissingFormatSpecifier"sv, "missing format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierWidthNotAllowed, std::make_tuple("FormatSpecifierWidthNotAllowed"sv, "field width not allowed on '%{}' format specifiers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierInvalidWidth, std::make_tuple("FormatSpecifierInvalidWidth"sv, "field width is invalid"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatSpecifierNotFloat, std::make_tuple("FormatSpecifierNotFloat"sv, "floating point format specifier options used on non-floating point field"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatUnspecifiedType, std::make_tuple("FormatUnspecifiedType"sv, "cannot format values of type {} without a specification string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatMismatchedType, std::make_tuple("FormatMismatchedType"sv, "value of type {} is invalid for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatNoArgument, std::make_tuple("FormatNoArgument"sv, "no argument provided for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatEmptyArg, std::make_tuple("FormatEmptyArg"sv, "empty argument not allowed -- expecting value for '%{}' format specifier"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatTooManyArgs, std::make_tuple("FormatTooManyArgs"sv, "too many arguments provided for format string"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::InvalidStringArg, std::make_tuple("InvalidStringArg"sv, "value of type {} is not a valid string argument"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ArrayReductionIntegral, std::make_tuple("ArrayReductionIntegral"sv, "array reduction methods can only be called on unpacked arrays of integral values"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::BadFinishNum, std::make_tuple("BadFinishNum"sv, "finish argument must have value of 0, 1, or 2"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::FormatRealInt, std::make_tuple("FormatRealInt"sv, "real value provided for integer format specifier '%{}'"sv, DiagnosticSeverity::Warning, "format-real"sv)},
+    {diag::InvalidEnumBase, std::make_tuple("InvalidEnumBase"sv, "invalid enum base type {} (must be a single dimensional integer type)"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueOverflow, std::make_tuple("EnumValueOverflow"sv, "incrementing previous value {} would overflow enum base type {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumIncrementUnknown, std::make_tuple("EnumIncrementUnknown"sv, "cannot increment previous value {} because it has unknown bits"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumValueDuplicate, std::make_tuple("EnumValueDuplicate"sv, "redefinition of enum value {}"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::EnumRangeMultiDimensional, std::make_tuple("EnumRangeMultiDimensional"sv, "enum range cannot be multidimensional"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::ForwardTypedefDoesNotMatch, std::make_tuple("ForwardTypedefDoesNotMatch"sv, "forward typedef basic type '{}' does not match declaration"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedMemberNotIntegral, std::make_tuple("PackedMemberNotIntegral"sv, "packed members must be of integral type (type is {})"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedMemberHasInitializer, std::make_tuple("PackedMemberHasInitializer"sv, "packed members can not have initializers"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedDimsOnPredefinedType, std::make_tuple("PackedDimsOnPredefinedType"sv, "packed dimensions not allowed on predefined integer type '{}'"sv, DiagnosticSeverity::Error, ""sv)},
+    {diag::PackedUnionWidthMismatch, std::make_tuple("PackedUnionWidthMismatch"sv, "all members of a packed union must have the same width"sv, DiagnosticSeverity::Error, ""sv)},
+};
+
+static const flat_hash_map<string_view, DiagCode> optionMap = {
+    {"static-skipped"sv, diag::ConstEvalStaticSkipped},
+    {"explicit-static"sv, diag::StaticInitializerMustBeExplicit},
+    {"case-gen-dup"sv, diag::CaseGenerateDup},
+    {"case-gen-none"sv, diag::CaseGenerateNoBlock},
+    {"unconnected-port"sv, diag::UnconnectedNamedPort},
+    {"unconnected-unnamed-port"sv, diag::UnconnectedUnnamedPort},
+    {"implicit-net-port"sv, diag::ImplicitNetPortNoDefault},
+    {"dup-attr"sv, diag::DuplicateAttribute},
+    {"empty-member"sv, diag::EmptyMember},
+    {"not-supported"sv, diag::WarnNotYetSupported},
+    {"dup-import"sv, diag::DuplicateImport},
+    {"unknown-warning-option"sv, diag::UnknownWarningOption},
+    {"real-underflow"sv, diag::RealLiteralUnderflow},
+    {"real-overflow"sv, diag::RealLiteralOverflow},
+    {"literal-overflow"sv, diag::VectorLiteralOverflow},
+    {"nonstandard-generate"sv, diag::NonStandardGenBlock},
+    {"ignored-macro-paste"sv, diag::IgnoredMacroPaste},
+    {"redef-macro"sv, diag::RedefiningMacro},
+    {"unknown-pragma"sv, diag::UnknownPragma},
+    {"extra-pragma-args"sv, diag::ExtraPragmaArgs},
+    {"expected-diag-arg"sv, diag::ExpectedDiagPragmaArg},
+    {"unknown-diag-arg"sv, diag::UnknownDiagPragmaArg},
+    {"pragma-diag-level"sv, diag::ExpectedDiagPragmaLevel},
+    {"event-const"sv, diag::EventExpressionConstant},
+    {"empty-stmt"sv, diag::EmptyStatement},
+    {"pointless-void-cast"sv, diag::PointlessVoidCast},
+    {"unused-result"sv, diag::UnusedResult},
+    {"format-real"sv, diag::FormatRealInt},
+};
+
+static const flat_hash_map<string_view, DiagGroup> groupMap = {
+    {"default"sv, DiagGroup("default", { diag::RealLiteralUnderflow, diag::RealLiteralOverflow, diag::VectorLiteralOverflow, diag::IgnoredMacroPaste, diag::CaseGenerateDup, diag::CaseGenerateNoBlock, diag::UnconnectedNamedPort, diag::UnconnectedUnnamedPort, diag::DuplicateAttribute, diag::EventExpressionConstant, diag::RedefiningMacro, diag::NonStandardGenBlock, diag::PointlessVoidCast, diag::UnusedResult, diag::WarnNotYetSupported, diag::UnknownPragma, diag::ExtraPragmaArgs, diag::ExpectedDiagPragmaArg, diag::UnknownDiagPragmaArg, diag::ExpectedDiagPragmaLevel, diag::StaticInitializerMustBeExplicit, diag::ConstEvalStaticSkipped })},
+    {"extra"sv, DiagGroup("extra", { diag::EmptyMember, diag::EmptyStatement, diag::DuplicateImport })},
+};
+
+std::ostream& operator<<(std::ostream& os, DiagCode code) {
+    os << toString(code);
+    return os;
+}
+
+string_view toString(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<0>(it->second);
+    return "<user-diag>"sv;
+}
+
+string_view getDefaultMessage(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<1>(it->second);
+    return ""sv;
+}
+
+DiagnosticSeverity getDefaultSeverity(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<2>(it->second);
+    return DiagnosticSeverity::Ignored;
+}
+
+string_view getDefaultOptionName(DiagCode code) {
+    if (auto it = data.find(code); it != data.end())
+        return std::get<3>(it->second);
+    return ""sv;
+}
+
+DiagCode findDiagFromOptionName(string_view name) {
+    if (auto it = optionMap.find(name); it != optionMap.end())
+        return it->second;
+    return DiagCode();
+}
+
+const DiagGroup* findDefaultDiagGroup(string_view name) {
+    if (auto it = groupMap.find(name); it != groupMap.end())
+        return &it->second;
+    return nullptr;
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/Makefile ./generated/Makefile
--- ./generated/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/Makefile	2020-04-13 10:23:46.700499356 -0700
@@ -0,0 +1,2538 @@
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.16
+
+# Default target executed when no arguments are given to make.
+default_target: all
+
+.PHONY : default_target
+
+# Allow only one "make -f Makefile2" at a time, but pass parallelism.
+.NOTPARALLEL:
+
+
+#=============================================================================
+# Special targets provided by cmake.
+
+# Disable implicit rules so canonical targets will work.
+.SUFFIXES:
+
+
+# Remove some rules from gmake that .SUFFIXES does not remove.
+SUFFIXES =
+
+.SUFFIXES: .hpux_make_needs_suffix_list
+
+
+# Suppress display of executed commands.
+$(VERBOSE).SILENT:
+
+
+# A target that is always out of date.
+cmake_force:
+
+.PHONY : cmake_force
+
+#=============================================================================
+# Set environment variables for the build.
+
+# The shell in which to execute make rules.
+SHELL = /bin/sh
+
+# The CMake executable.
+CMAKE_COMMAND = /usr/bin/cmake
+
+# The command to remove a file.
+RM = /usr/bin/cmake -E remove -f
+
+# Escaping for special characters.
+EQUALS = =
+
+# The top-level source directory on which CMake was run.
+CMAKE_SOURCE_DIR = /soe/renau/projs/synth/slang
+
+# The top-level build directory on which CMake was run.
+CMAKE_BINARY_DIR = /soe/renau/projs/synth/slang/build
+
+#=============================================================================
+# Targets provided globally by CMake.
+
+# Special rule for the target install/strip
+install/strip: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
+	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
+.PHONY : install/strip
+
+# Special rule for the target install/strip
+install/strip/fast: preinstall/fast
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing the project stripped..."
+	/usr/bin/cmake -DCMAKE_INSTALL_DO_STRIP=1 -P cmake_install.cmake
+.PHONY : install/strip/fast
+
+# Special rule for the target install/local
+install/local: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing only the local directory..."
+	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
+.PHONY : install/local
+
+# Special rule for the target install/local
+install/local/fast: preinstall/fast
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing only the local directory..."
+	/usr/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
+.PHONY : install/local/fast
+
+# Special rule for the target install
+install: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
+	/usr/bin/cmake -P cmake_install.cmake
+.PHONY : install
+
+# Special rule for the target install
+install/fast: preinstall/fast
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
+	/usr/bin/cmake -P cmake_install.cmake
+.PHONY : install/fast
+
+# Special rule for the target list_install_components
+list_install_components:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Available install components are: \"Unspecified\""
+.PHONY : list_install_components
+
+# Special rule for the target list_install_components
+list_install_components/fast: list_install_components
+
+.PHONY : list_install_components/fast
+
+# Special rule for the target rebuild_cache
+rebuild_cache:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
+	/usr/bin/cmake -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
+.PHONY : rebuild_cache
+
+# Special rule for the target rebuild_cache
+rebuild_cache/fast: rebuild_cache
+
+.PHONY : rebuild_cache/fast
+
+# Special rule for the target edit_cache
+edit_cache:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "No interactive CMake dialog available..."
+	/usr/bin/cmake -E echo No\ interactive\ CMake\ dialog\ available.
+.PHONY : edit_cache
+
+# Special rule for the target edit_cache
+edit_cache/fast: edit_cache
+
+.PHONY : edit_cache/fast
+
+# Special rule for the target test
+test:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running tests..."
+	/usr/bin/ctest --force-new-ctest-process $(ARGS)
+.PHONY : test
+
+# Special rule for the target test
+test/fast: test
+
+.PHONY : test/fast
+
+# The main all target
+all: cmake_check_build_system
+	cd /soe/renau/projs/synth/slang/build && $(CMAKE_COMMAND) -E cmake_progress_start /soe/renau/projs/synth/slang/build/CMakeFiles /soe/renau/projs/synth/slang/build/source/CMakeFiles/progress.marks
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/all
+	$(CMAKE_COMMAND) -E cmake_progress_start /soe/renau/projs/synth/slang/build/CMakeFiles 0
+.PHONY : all
+
+# The main clean target
+clean:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/clean
+.PHONY : clean
+
+# The main clean target
+clean/fast: clean
+
+.PHONY : clean/fast
+
+# Prepare targets for installation.
+preinstall: all
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/preinstall
+.PHONY : preinstall
+
+# Prepare targets for installation.
+preinstall/fast:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/preinstall
+.PHONY : preinstall/fast
+
+# clear depends
+depend:
+	cd /soe/renau/projs/synth/slang/build && $(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
+.PHONY : depend
+
+# Convenience name for target.
+source/CMakeFiles/slang.dir/rule:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/CMakeFiles/slang.dir/rule
+.PHONY : source/CMakeFiles/slang.dir/rule
+
+# Convenience name for target.
+slang: source/CMakeFiles/slang.dir/rule
+
+.PHONY : slang
+
+# fast build rule for target.
+slang/fast:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/build
+.PHONY : slang/fast
+
+# Convenience name for target.
+source/CMakeFiles/gen_version.dir/rule:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f CMakeFiles/Makefile2 source/CMakeFiles/gen_version.dir/rule
+.PHONY : source/CMakeFiles/gen_version.dir/rule
+
+# Convenience name for target.
+gen_version: source/CMakeFiles/gen_version.dir/rule
+
+.PHONY : gen_version
+
+# fast build rule for target.
+gen_version/fast:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/gen_version.dir/build.make source/CMakeFiles/gen_version.dir/build
+.PHONY : gen_version/fast
+
+AllSyntax.o: AllSyntax.cpp.o
+
+.PHONY : AllSyntax.o
+
+# target to build an object file
+AllSyntax.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/AllSyntax.cpp.o
+.PHONY : AllSyntax.cpp.o
+
+AllSyntax.i: AllSyntax.cpp.i
+
+.PHONY : AllSyntax.i
+
+# target to preprocess a source file
+AllSyntax.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/AllSyntax.cpp.i
+.PHONY : AllSyntax.cpp.i
+
+AllSyntax.s: AllSyntax.cpp.s
+
+.PHONY : AllSyntax.s
+
+# target to generate assembly for a file
+AllSyntax.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/AllSyntax.cpp.s
+.PHONY : AllSyntax.cpp.s
+
+DiagCode.o: DiagCode.cpp.o
+
+.PHONY : DiagCode.o
+
+# target to build an object file
+DiagCode.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/DiagCode.cpp.o
+.PHONY : DiagCode.cpp.o
+
+DiagCode.i: DiagCode.cpp.i
+
+.PHONY : DiagCode.i
+
+# target to preprocess a source file
+DiagCode.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/DiagCode.cpp.i
+.PHONY : DiagCode.cpp.i
+
+DiagCode.s: DiagCode.cpp.s
+
+.PHONY : DiagCode.s
+
+# target to generate assembly for a file
+DiagCode.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/DiagCode.cpp.s
+.PHONY : DiagCode.cpp.s
+
+Version.o: Version.cpp.o
+
+.PHONY : Version.o
+
+# target to build an object file
+Version.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/Version.cpp.o
+.PHONY : Version.cpp.o
+
+Version.i: Version.cpp.i
+
+.PHONY : Version.i
+
+# target to preprocess a source file
+Version.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/Version.cpp.i
+.PHONY : Version.cpp.i
+
+Version.s: Version.cpp.s
+
+.PHONY : Version.s
+
+# target to generate assembly for a file
+Version.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/Version.cpp.s
+.PHONY : Version.cpp.s
+
+binding/AssignmentExpressions.o: binding/AssignmentExpressions.cpp.o
+
+.PHONY : binding/AssignmentExpressions.o
+
+# target to build an object file
+binding/AssignmentExpressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/AssignmentExpressions.cpp.o
+.PHONY : binding/AssignmentExpressions.cpp.o
+
+binding/AssignmentExpressions.i: binding/AssignmentExpressions.cpp.i
+
+.PHONY : binding/AssignmentExpressions.i
+
+# target to preprocess a source file
+binding/AssignmentExpressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/AssignmentExpressions.cpp.i
+.PHONY : binding/AssignmentExpressions.cpp.i
+
+binding/AssignmentExpressions.s: binding/AssignmentExpressions.cpp.s
+
+.PHONY : binding/AssignmentExpressions.s
+
+# target to generate assembly for a file
+binding/AssignmentExpressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/AssignmentExpressions.cpp.s
+.PHONY : binding/AssignmentExpressions.cpp.s
+
+binding/BindContext.o: binding/BindContext.cpp.o
+
+.PHONY : binding/BindContext.o
+
+# target to build an object file
+binding/BindContext.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/BindContext.cpp.o
+.PHONY : binding/BindContext.cpp.o
+
+binding/BindContext.i: binding/BindContext.cpp.i
+
+.PHONY : binding/BindContext.i
+
+# target to preprocess a source file
+binding/BindContext.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/BindContext.cpp.i
+.PHONY : binding/BindContext.cpp.i
+
+binding/BindContext.s: binding/BindContext.cpp.s
+
+.PHONY : binding/BindContext.s
+
+# target to generate assembly for a file
+binding/BindContext.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/BindContext.cpp.s
+.PHONY : binding/BindContext.cpp.s
+
+binding/ConstantValue.o: binding/ConstantValue.cpp.o
+
+.PHONY : binding/ConstantValue.o
+
+# target to build an object file
+binding/ConstantValue.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/ConstantValue.cpp.o
+.PHONY : binding/ConstantValue.cpp.o
+
+binding/ConstantValue.i: binding/ConstantValue.cpp.i
+
+.PHONY : binding/ConstantValue.i
+
+# target to preprocess a source file
+binding/ConstantValue.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/ConstantValue.cpp.i
+.PHONY : binding/ConstantValue.cpp.i
+
+binding/ConstantValue.s: binding/ConstantValue.cpp.s
+
+.PHONY : binding/ConstantValue.s
+
+# target to generate assembly for a file
+binding/ConstantValue.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/ConstantValue.cpp.s
+.PHONY : binding/ConstantValue.cpp.s
+
+binding/EvalContext.o: binding/EvalContext.cpp.o
+
+.PHONY : binding/EvalContext.o
+
+# target to build an object file
+binding/EvalContext.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/EvalContext.cpp.o
+.PHONY : binding/EvalContext.cpp.o
+
+binding/EvalContext.i: binding/EvalContext.cpp.i
+
+.PHONY : binding/EvalContext.i
+
+# target to preprocess a source file
+binding/EvalContext.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/EvalContext.cpp.i
+.PHONY : binding/EvalContext.cpp.i
+
+binding/EvalContext.s: binding/EvalContext.cpp.s
+
+.PHONY : binding/EvalContext.s
+
+# target to generate assembly for a file
+binding/EvalContext.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/EvalContext.cpp.s
+.PHONY : binding/EvalContext.cpp.s
+
+binding/Expression.o: binding/Expression.cpp.o
+
+.PHONY : binding/Expression.o
+
+# target to build an object file
+binding/Expression.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Expression.cpp.o
+.PHONY : binding/Expression.cpp.o
+
+binding/Expression.i: binding/Expression.cpp.i
+
+.PHONY : binding/Expression.i
+
+# target to preprocess a source file
+binding/Expression.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Expression.cpp.i
+.PHONY : binding/Expression.cpp.i
+
+binding/Expression.s: binding/Expression.cpp.s
+
+.PHONY : binding/Expression.s
+
+# target to generate assembly for a file
+binding/Expression.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Expression.cpp.s
+.PHONY : binding/Expression.cpp.s
+
+binding/LiteralExpressions.o: binding/LiteralExpressions.cpp.o
+
+.PHONY : binding/LiteralExpressions.o
+
+# target to build an object file
+binding/LiteralExpressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/LiteralExpressions.cpp.o
+.PHONY : binding/LiteralExpressions.cpp.o
+
+binding/LiteralExpressions.i: binding/LiteralExpressions.cpp.i
+
+.PHONY : binding/LiteralExpressions.i
+
+# target to preprocess a source file
+binding/LiteralExpressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/LiteralExpressions.cpp.i
+.PHONY : binding/LiteralExpressions.cpp.i
+
+binding/LiteralExpressions.s: binding/LiteralExpressions.cpp.s
+
+.PHONY : binding/LiteralExpressions.s
+
+# target to generate assembly for a file
+binding/LiteralExpressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/LiteralExpressions.cpp.s
+.PHONY : binding/LiteralExpressions.cpp.s
+
+binding/MiscExpressions.o: binding/MiscExpressions.cpp.o
+
+.PHONY : binding/MiscExpressions.o
+
+# target to build an object file
+binding/MiscExpressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/MiscExpressions.cpp.o
+.PHONY : binding/MiscExpressions.cpp.o
+
+binding/MiscExpressions.i: binding/MiscExpressions.cpp.i
+
+.PHONY : binding/MiscExpressions.i
+
+# target to preprocess a source file
+binding/MiscExpressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/MiscExpressions.cpp.i
+.PHONY : binding/MiscExpressions.cpp.i
+
+binding/MiscExpressions.s: binding/MiscExpressions.cpp.s
+
+.PHONY : binding/MiscExpressions.s
+
+# target to generate assembly for a file
+binding/MiscExpressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/MiscExpressions.cpp.s
+.PHONY : binding/MiscExpressions.cpp.s
+
+binding/OperatorExpressions.o: binding/OperatorExpressions.cpp.o
+
+.PHONY : binding/OperatorExpressions.o
+
+# target to build an object file
+binding/OperatorExpressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/OperatorExpressions.cpp.o
+.PHONY : binding/OperatorExpressions.cpp.o
+
+binding/OperatorExpressions.i: binding/OperatorExpressions.cpp.i
+
+.PHONY : binding/OperatorExpressions.i
+
+# target to preprocess a source file
+binding/OperatorExpressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/OperatorExpressions.cpp.i
+.PHONY : binding/OperatorExpressions.cpp.i
+
+binding/OperatorExpressions.s: binding/OperatorExpressions.cpp.s
+
+.PHONY : binding/OperatorExpressions.s
+
+# target to generate assembly for a file
+binding/OperatorExpressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/OperatorExpressions.cpp.s
+.PHONY : binding/OperatorExpressions.cpp.s
+
+binding/PatternExpressions.o: binding/PatternExpressions.cpp.o
+
+.PHONY : binding/PatternExpressions.o
+
+# target to build an object file
+binding/PatternExpressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/PatternExpressions.cpp.o
+.PHONY : binding/PatternExpressions.cpp.o
+
+binding/PatternExpressions.i: binding/PatternExpressions.cpp.i
+
+.PHONY : binding/PatternExpressions.i
+
+# target to preprocess a source file
+binding/PatternExpressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/PatternExpressions.cpp.i
+.PHONY : binding/PatternExpressions.cpp.i
+
+binding/PatternExpressions.s: binding/PatternExpressions.cpp.s
+
+.PHONY : binding/PatternExpressions.s
+
+# target to generate assembly for a file
+binding/PatternExpressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/PatternExpressions.cpp.s
+.PHONY : binding/PatternExpressions.cpp.s
+
+binding/Statements.o: binding/Statements.cpp.o
+
+.PHONY : binding/Statements.o
+
+# target to build an object file
+binding/Statements.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Statements.cpp.o
+.PHONY : binding/Statements.cpp.o
+
+binding/Statements.i: binding/Statements.cpp.i
+
+.PHONY : binding/Statements.i
+
+# target to preprocess a source file
+binding/Statements.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Statements.cpp.i
+.PHONY : binding/Statements.cpp.i
+
+binding/Statements.s: binding/Statements.cpp.s
+
+.PHONY : binding/Statements.s
+
+# target to generate assembly for a file
+binding/Statements.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/Statements.cpp.s
+.PHONY : binding/Statements.cpp.s
+
+binding/SystemSubroutine.o: binding/SystemSubroutine.cpp.o
+
+.PHONY : binding/SystemSubroutine.o
+
+# target to build an object file
+binding/SystemSubroutine.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/SystemSubroutine.cpp.o
+.PHONY : binding/SystemSubroutine.cpp.o
+
+binding/SystemSubroutine.i: binding/SystemSubroutine.cpp.i
+
+.PHONY : binding/SystemSubroutine.i
+
+# target to preprocess a source file
+binding/SystemSubroutine.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/SystemSubroutine.cpp.i
+.PHONY : binding/SystemSubroutine.cpp.i
+
+binding/SystemSubroutine.s: binding/SystemSubroutine.cpp.s
+
+.PHONY : binding/SystemSubroutine.s
+
+# target to generate assembly for a file
+binding/SystemSubroutine.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/SystemSubroutine.cpp.s
+.PHONY : binding/SystemSubroutine.cpp.s
+
+binding/TimingControl.o: binding/TimingControl.cpp.o
+
+.PHONY : binding/TimingControl.o
+
+# target to build an object file
+binding/TimingControl.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/TimingControl.cpp.o
+.PHONY : binding/TimingControl.cpp.o
+
+binding/TimingControl.i: binding/TimingControl.cpp.i
+
+.PHONY : binding/TimingControl.i
+
+# target to preprocess a source file
+binding/TimingControl.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/TimingControl.cpp.i
+.PHONY : binding/TimingControl.cpp.i
+
+binding/TimingControl.s: binding/TimingControl.cpp.s
+
+.PHONY : binding/TimingControl.s
+
+# target to generate assembly for a file
+binding/TimingControl.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/binding/TimingControl.cpp.s
+.PHONY : binding/TimingControl.cpp.s
+
+compilation/Compilation.o: compilation/Compilation.cpp.o
+
+.PHONY : compilation/Compilation.o
+
+# target to build an object file
+compilation/Compilation.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Compilation.cpp.o
+.PHONY : compilation/Compilation.cpp.o
+
+compilation/Compilation.i: compilation/Compilation.cpp.i
+
+.PHONY : compilation/Compilation.i
+
+# target to preprocess a source file
+compilation/Compilation.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Compilation.cpp.i
+.PHONY : compilation/Compilation.cpp.i
+
+compilation/Compilation.s: compilation/Compilation.cpp.s
+
+.PHONY : compilation/Compilation.s
+
+# target to generate assembly for a file
+compilation/Compilation.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Compilation.cpp.s
+.PHONY : compilation/Compilation.cpp.s
+
+compilation/Definition.o: compilation/Definition.cpp.o
+
+.PHONY : compilation/Definition.o
+
+# target to build an object file
+compilation/Definition.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Definition.cpp.o
+.PHONY : compilation/Definition.cpp.o
+
+compilation/Definition.i: compilation/Definition.cpp.i
+
+.PHONY : compilation/Definition.i
+
+# target to preprocess a source file
+compilation/Definition.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Definition.cpp.i
+.PHONY : compilation/Definition.cpp.i
+
+compilation/Definition.s: compilation/Definition.cpp.s
+
+.PHONY : compilation/Definition.s
+
+# target to generate assembly for a file
+compilation/Definition.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/Definition.cpp.s
+.PHONY : compilation/Definition.cpp.s
+
+compilation/InstanceCache.o: compilation/InstanceCache.cpp.o
+
+.PHONY : compilation/InstanceCache.o
+
+# target to build an object file
+compilation/InstanceCache.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/InstanceCache.cpp.o
+.PHONY : compilation/InstanceCache.cpp.o
+
+compilation/InstanceCache.i: compilation/InstanceCache.cpp.i
+
+.PHONY : compilation/InstanceCache.i
+
+# target to preprocess a source file
+compilation/InstanceCache.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/InstanceCache.cpp.i
+.PHONY : compilation/InstanceCache.cpp.i
+
+compilation/InstanceCache.s: compilation/InstanceCache.cpp.s
+
+.PHONY : compilation/InstanceCache.s
+
+# target to generate assembly for a file
+compilation/InstanceCache.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/InstanceCache.cpp.s
+.PHONY : compilation/InstanceCache.cpp.s
+
+compilation/ScriptSession.o: compilation/ScriptSession.cpp.o
+
+.PHONY : compilation/ScriptSession.o
+
+# target to build an object file
+compilation/ScriptSession.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/ScriptSession.cpp.o
+.PHONY : compilation/ScriptSession.cpp.o
+
+compilation/ScriptSession.i: compilation/ScriptSession.cpp.i
+
+.PHONY : compilation/ScriptSession.i
+
+# target to preprocess a source file
+compilation/ScriptSession.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/ScriptSession.cpp.i
+.PHONY : compilation/ScriptSession.cpp.i
+
+compilation/ScriptSession.s: compilation/ScriptSession.cpp.s
+
+.PHONY : compilation/ScriptSession.s
+
+# target to generate assembly for a file
+compilation/ScriptSession.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/ScriptSession.cpp.s
+.PHONY : compilation/ScriptSession.cpp.s
+
+compilation/SemanticModel.o: compilation/SemanticModel.cpp.o
+
+.PHONY : compilation/SemanticModel.o
+
+# target to build an object file
+compilation/SemanticModel.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/SemanticModel.cpp.o
+.PHONY : compilation/SemanticModel.cpp.o
+
+compilation/SemanticModel.i: compilation/SemanticModel.cpp.i
+
+.PHONY : compilation/SemanticModel.i
+
+# target to preprocess a source file
+compilation/SemanticModel.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/SemanticModel.cpp.i
+.PHONY : compilation/SemanticModel.cpp.i
+
+compilation/SemanticModel.s: compilation/SemanticModel.cpp.s
+
+.PHONY : compilation/SemanticModel.s
+
+# target to generate assembly for a file
+compilation/SemanticModel.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/SemanticModel.cpp.s
+.PHONY : compilation/SemanticModel.cpp.s
+
+compilation/builtins/ArrayMethods.o: compilation/builtins/ArrayMethods.cpp.o
+
+.PHONY : compilation/builtins/ArrayMethods.o
+
+# target to build an object file
+compilation/builtins/ArrayMethods.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ArrayMethods.cpp.o
+.PHONY : compilation/builtins/ArrayMethods.cpp.o
+
+compilation/builtins/ArrayMethods.i: compilation/builtins/ArrayMethods.cpp.i
+
+.PHONY : compilation/builtins/ArrayMethods.i
+
+# target to preprocess a source file
+compilation/builtins/ArrayMethods.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ArrayMethods.cpp.i
+.PHONY : compilation/builtins/ArrayMethods.cpp.i
+
+compilation/builtins/ArrayMethods.s: compilation/builtins/ArrayMethods.cpp.s
+
+.PHONY : compilation/builtins/ArrayMethods.s
+
+# target to generate assembly for a file
+compilation/builtins/ArrayMethods.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ArrayMethods.cpp.s
+.PHONY : compilation/builtins/ArrayMethods.cpp.s
+
+compilation/builtins/ConversionFuncs.o: compilation/builtins/ConversionFuncs.cpp.o
+
+.PHONY : compilation/builtins/ConversionFuncs.o
+
+# target to build an object file
+compilation/builtins/ConversionFuncs.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ConversionFuncs.cpp.o
+.PHONY : compilation/builtins/ConversionFuncs.cpp.o
+
+compilation/builtins/ConversionFuncs.i: compilation/builtins/ConversionFuncs.cpp.i
+
+.PHONY : compilation/builtins/ConversionFuncs.i
+
+# target to preprocess a source file
+compilation/builtins/ConversionFuncs.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ConversionFuncs.cpp.i
+.PHONY : compilation/builtins/ConversionFuncs.cpp.i
+
+compilation/builtins/ConversionFuncs.s: compilation/builtins/ConversionFuncs.cpp.s
+
+.PHONY : compilation/builtins/ConversionFuncs.s
+
+# target to generate assembly for a file
+compilation/builtins/ConversionFuncs.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/ConversionFuncs.cpp.s
+.PHONY : compilation/builtins/ConversionFuncs.cpp.s
+
+compilation/builtins/EnumMethods.o: compilation/builtins/EnumMethods.cpp.o
+
+.PHONY : compilation/builtins/EnumMethods.o
+
+# target to build an object file
+compilation/builtins/EnumMethods.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/EnumMethods.cpp.o
+.PHONY : compilation/builtins/EnumMethods.cpp.o
+
+compilation/builtins/EnumMethods.i: compilation/builtins/EnumMethods.cpp.i
+
+.PHONY : compilation/builtins/EnumMethods.i
+
+# target to preprocess a source file
+compilation/builtins/EnumMethods.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/EnumMethods.cpp.i
+.PHONY : compilation/builtins/EnumMethods.cpp.i
+
+compilation/builtins/EnumMethods.s: compilation/builtins/EnumMethods.cpp.s
+
+.PHONY : compilation/builtins/EnumMethods.s
+
+# target to generate assembly for a file
+compilation/builtins/EnumMethods.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/EnumMethods.cpp.s
+.PHONY : compilation/builtins/EnumMethods.cpp.s
+
+compilation/builtins/MathFuncs.o: compilation/builtins/MathFuncs.cpp.o
+
+.PHONY : compilation/builtins/MathFuncs.o
+
+# target to build an object file
+compilation/builtins/MathFuncs.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MathFuncs.cpp.o
+.PHONY : compilation/builtins/MathFuncs.cpp.o
+
+compilation/builtins/MathFuncs.i: compilation/builtins/MathFuncs.cpp.i
+
+.PHONY : compilation/builtins/MathFuncs.i
+
+# target to preprocess a source file
+compilation/builtins/MathFuncs.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MathFuncs.cpp.i
+.PHONY : compilation/builtins/MathFuncs.cpp.i
+
+compilation/builtins/MathFuncs.s: compilation/builtins/MathFuncs.cpp.s
+
+.PHONY : compilation/builtins/MathFuncs.s
+
+# target to generate assembly for a file
+compilation/builtins/MathFuncs.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MathFuncs.cpp.s
+.PHONY : compilation/builtins/MathFuncs.cpp.s
+
+compilation/builtins/MiscSystemFuncs.o: compilation/builtins/MiscSystemFuncs.cpp.o
+
+.PHONY : compilation/builtins/MiscSystemFuncs.o
+
+# target to build an object file
+compilation/builtins/MiscSystemFuncs.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MiscSystemFuncs.cpp.o
+.PHONY : compilation/builtins/MiscSystemFuncs.cpp.o
+
+compilation/builtins/MiscSystemFuncs.i: compilation/builtins/MiscSystemFuncs.cpp.i
+
+.PHONY : compilation/builtins/MiscSystemFuncs.i
+
+# target to preprocess a source file
+compilation/builtins/MiscSystemFuncs.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MiscSystemFuncs.cpp.i
+.PHONY : compilation/builtins/MiscSystemFuncs.cpp.i
+
+compilation/builtins/MiscSystemFuncs.s: compilation/builtins/MiscSystemFuncs.cpp.s
+
+.PHONY : compilation/builtins/MiscSystemFuncs.s
+
+# target to generate assembly for a file
+compilation/builtins/MiscSystemFuncs.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/MiscSystemFuncs.cpp.s
+.PHONY : compilation/builtins/MiscSystemFuncs.cpp.s
+
+compilation/builtins/NonConstFuncs.o: compilation/builtins/NonConstFuncs.cpp.o
+
+.PHONY : compilation/builtins/NonConstFuncs.o
+
+# target to build an object file
+compilation/builtins/NonConstFuncs.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/NonConstFuncs.cpp.o
+.PHONY : compilation/builtins/NonConstFuncs.cpp.o
+
+compilation/builtins/NonConstFuncs.i: compilation/builtins/NonConstFuncs.cpp.i
+
+.PHONY : compilation/builtins/NonConstFuncs.i
+
+# target to preprocess a source file
+compilation/builtins/NonConstFuncs.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/NonConstFuncs.cpp.i
+.PHONY : compilation/builtins/NonConstFuncs.cpp.i
+
+compilation/builtins/NonConstFuncs.s: compilation/builtins/NonConstFuncs.cpp.s
+
+.PHONY : compilation/builtins/NonConstFuncs.s
+
+# target to generate assembly for a file
+compilation/builtins/NonConstFuncs.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/NonConstFuncs.cpp.s
+.PHONY : compilation/builtins/NonConstFuncs.cpp.s
+
+compilation/builtins/QueryFuncs.o: compilation/builtins/QueryFuncs.cpp.o
+
+.PHONY : compilation/builtins/QueryFuncs.o
+
+# target to build an object file
+compilation/builtins/QueryFuncs.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/QueryFuncs.cpp.o
+.PHONY : compilation/builtins/QueryFuncs.cpp.o
+
+compilation/builtins/QueryFuncs.i: compilation/builtins/QueryFuncs.cpp.i
+
+.PHONY : compilation/builtins/QueryFuncs.i
+
+# target to preprocess a source file
+compilation/builtins/QueryFuncs.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/QueryFuncs.cpp.i
+.PHONY : compilation/builtins/QueryFuncs.cpp.i
+
+compilation/builtins/QueryFuncs.s: compilation/builtins/QueryFuncs.cpp.s
+
+.PHONY : compilation/builtins/QueryFuncs.s
+
+# target to generate assembly for a file
+compilation/builtins/QueryFuncs.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/QueryFuncs.cpp.s
+.PHONY : compilation/builtins/QueryFuncs.cpp.s
+
+compilation/builtins/StringMethods.o: compilation/builtins/StringMethods.cpp.o
+
+.PHONY : compilation/builtins/StringMethods.o
+
+# target to build an object file
+compilation/builtins/StringMethods.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/StringMethods.cpp.o
+.PHONY : compilation/builtins/StringMethods.cpp.o
+
+compilation/builtins/StringMethods.i: compilation/builtins/StringMethods.cpp.i
+
+.PHONY : compilation/builtins/StringMethods.i
+
+# target to preprocess a source file
+compilation/builtins/StringMethods.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/StringMethods.cpp.i
+.PHONY : compilation/builtins/StringMethods.cpp.i
+
+compilation/builtins/StringMethods.s: compilation/builtins/StringMethods.cpp.s
+
+.PHONY : compilation/builtins/StringMethods.s
+
+# target to generate assembly for a file
+compilation/builtins/StringMethods.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/StringMethods.cpp.s
+.PHONY : compilation/builtins/StringMethods.cpp.s
+
+compilation/builtins/SystemTasks.o: compilation/builtins/SystemTasks.cpp.o
+
+.PHONY : compilation/builtins/SystemTasks.o
+
+# target to build an object file
+compilation/builtins/SystemTasks.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/SystemTasks.cpp.o
+.PHONY : compilation/builtins/SystemTasks.cpp.o
+
+compilation/builtins/SystemTasks.i: compilation/builtins/SystemTasks.cpp.i
+
+.PHONY : compilation/builtins/SystemTasks.i
+
+# target to preprocess a source file
+compilation/builtins/SystemTasks.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/SystemTasks.cpp.i
+.PHONY : compilation/builtins/SystemTasks.cpp.i
+
+compilation/builtins/SystemTasks.s: compilation/builtins/SystemTasks.cpp.s
+
+.PHONY : compilation/builtins/SystemTasks.s
+
+# target to generate assembly for a file
+compilation/builtins/SystemTasks.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/compilation/builtins/SystemTasks.cpp.s
+.PHONY : compilation/builtins/SystemTasks.cpp.s
+
+diagnostics/DiagnosticClient.o: diagnostics/DiagnosticClient.cpp.o
+
+.PHONY : diagnostics/DiagnosticClient.o
+
+# target to build an object file
+diagnostics/DiagnosticClient.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticClient.cpp.o
+.PHONY : diagnostics/DiagnosticClient.cpp.o
+
+diagnostics/DiagnosticClient.i: diagnostics/DiagnosticClient.cpp.i
+
+.PHONY : diagnostics/DiagnosticClient.i
+
+# target to preprocess a source file
+diagnostics/DiagnosticClient.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticClient.cpp.i
+.PHONY : diagnostics/DiagnosticClient.cpp.i
+
+diagnostics/DiagnosticClient.s: diagnostics/DiagnosticClient.cpp.s
+
+.PHONY : diagnostics/DiagnosticClient.s
+
+# target to generate assembly for a file
+diagnostics/DiagnosticClient.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticClient.cpp.s
+.PHONY : diagnostics/DiagnosticClient.cpp.s
+
+diagnostics/DiagnosticEngine.o: diagnostics/DiagnosticEngine.cpp.o
+
+.PHONY : diagnostics/DiagnosticEngine.o
+
+# target to build an object file
+diagnostics/DiagnosticEngine.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticEngine.cpp.o
+.PHONY : diagnostics/DiagnosticEngine.cpp.o
+
+diagnostics/DiagnosticEngine.i: diagnostics/DiagnosticEngine.cpp.i
+
+.PHONY : diagnostics/DiagnosticEngine.i
+
+# target to preprocess a source file
+diagnostics/DiagnosticEngine.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticEngine.cpp.i
+.PHONY : diagnostics/DiagnosticEngine.cpp.i
+
+diagnostics/DiagnosticEngine.s: diagnostics/DiagnosticEngine.cpp.s
+
+.PHONY : diagnostics/DiagnosticEngine.s
+
+# target to generate assembly for a file
+diagnostics/DiagnosticEngine.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/DiagnosticEngine.cpp.s
+.PHONY : diagnostics/DiagnosticEngine.cpp.s
+
+diagnostics/Diagnostics.o: diagnostics/Diagnostics.cpp.o
+
+.PHONY : diagnostics/Diagnostics.o
+
+# target to build an object file
+diagnostics/Diagnostics.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/Diagnostics.cpp.o
+.PHONY : diagnostics/Diagnostics.cpp.o
+
+diagnostics/Diagnostics.i: diagnostics/Diagnostics.cpp.i
+
+.PHONY : diagnostics/Diagnostics.i
+
+# target to preprocess a source file
+diagnostics/Diagnostics.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/Diagnostics.cpp.i
+.PHONY : diagnostics/Diagnostics.cpp.i
+
+diagnostics/Diagnostics.s: diagnostics/Diagnostics.cpp.s
+
+.PHONY : diagnostics/Diagnostics.s
+
+# target to generate assembly for a file
+diagnostics/Diagnostics.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/Diagnostics.cpp.s
+.PHONY : diagnostics/Diagnostics.cpp.s
+
+diagnostics/TextDiagnosticClient.o: diagnostics/TextDiagnosticClient.cpp.o
+
+.PHONY : diagnostics/TextDiagnosticClient.o
+
+# target to build an object file
+diagnostics/TextDiagnosticClient.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/TextDiagnosticClient.cpp.o
+.PHONY : diagnostics/TextDiagnosticClient.cpp.o
+
+diagnostics/TextDiagnosticClient.i: diagnostics/TextDiagnosticClient.cpp.i
+
+.PHONY : diagnostics/TextDiagnosticClient.i
+
+# target to preprocess a source file
+diagnostics/TextDiagnosticClient.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/TextDiagnosticClient.cpp.i
+.PHONY : diagnostics/TextDiagnosticClient.cpp.i
+
+diagnostics/TextDiagnosticClient.s: diagnostics/TextDiagnosticClient.cpp.s
+
+.PHONY : diagnostics/TextDiagnosticClient.s
+
+# target to generate assembly for a file
+diagnostics/TextDiagnosticClient.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/diagnostics/TextDiagnosticClient.cpp.s
+.PHONY : diagnostics/TextDiagnosticClient.cpp.s
+
+numeric/SVInt.o: numeric/SVInt.cpp.o
+
+.PHONY : numeric/SVInt.o
+
+# target to build an object file
+numeric/SVInt.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/SVInt.cpp.o
+.PHONY : numeric/SVInt.cpp.o
+
+numeric/SVInt.i: numeric/SVInt.cpp.i
+
+.PHONY : numeric/SVInt.i
+
+# target to preprocess a source file
+numeric/SVInt.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/SVInt.cpp.i
+.PHONY : numeric/SVInt.cpp.i
+
+numeric/SVInt.s: numeric/SVInt.cpp.s
+
+.PHONY : numeric/SVInt.s
+
+# target to generate assembly for a file
+numeric/SVInt.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/SVInt.cpp.s
+.PHONY : numeric/SVInt.cpp.s
+
+numeric/Time.o: numeric/Time.cpp.o
+
+.PHONY : numeric/Time.o
+
+# target to build an object file
+numeric/Time.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/Time.cpp.o
+.PHONY : numeric/Time.cpp.o
+
+numeric/Time.i: numeric/Time.cpp.i
+
+.PHONY : numeric/Time.i
+
+# target to preprocess a source file
+numeric/Time.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/Time.cpp.i
+.PHONY : numeric/Time.cpp.i
+
+numeric/Time.s: numeric/Time.cpp.s
+
+.PHONY : numeric/Time.s
+
+# target to generate assembly for a file
+numeric/Time.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/numeric/Time.cpp.s
+.PHONY : numeric/Time.cpp.s
+
+parsing/Lexer.o: parsing/Lexer.cpp.o
+
+.PHONY : parsing/Lexer.o
+
+# target to build an object file
+parsing/Lexer.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Lexer.cpp.o
+.PHONY : parsing/Lexer.cpp.o
+
+parsing/Lexer.i: parsing/Lexer.cpp.i
+
+.PHONY : parsing/Lexer.i
+
+# target to preprocess a source file
+parsing/Lexer.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Lexer.cpp.i
+.PHONY : parsing/Lexer.cpp.i
+
+parsing/Lexer.s: parsing/Lexer.cpp.s
+
+.PHONY : parsing/Lexer.s
+
+# target to generate assembly for a file
+parsing/Lexer.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Lexer.cpp.s
+.PHONY : parsing/Lexer.cpp.s
+
+parsing/LexerFacts.o: parsing/LexerFacts.cpp.o
+
+.PHONY : parsing/LexerFacts.o
+
+# target to build an object file
+parsing/LexerFacts.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/LexerFacts.cpp.o
+.PHONY : parsing/LexerFacts.cpp.o
+
+parsing/LexerFacts.i: parsing/LexerFacts.cpp.i
+
+.PHONY : parsing/LexerFacts.i
+
+# target to preprocess a source file
+parsing/LexerFacts.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/LexerFacts.cpp.i
+.PHONY : parsing/LexerFacts.cpp.i
+
+parsing/LexerFacts.s: parsing/LexerFacts.cpp.s
+
+.PHONY : parsing/LexerFacts.s
+
+# target to generate assembly for a file
+parsing/LexerFacts.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/LexerFacts.cpp.s
+.PHONY : parsing/LexerFacts.cpp.s
+
+parsing/NumberParser.o: parsing/NumberParser.cpp.o
+
+.PHONY : parsing/NumberParser.o
+
+# target to build an object file
+parsing/NumberParser.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/NumberParser.cpp.o
+.PHONY : parsing/NumberParser.cpp.o
+
+parsing/NumberParser.i: parsing/NumberParser.cpp.i
+
+.PHONY : parsing/NumberParser.i
+
+# target to preprocess a source file
+parsing/NumberParser.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/NumberParser.cpp.i
+.PHONY : parsing/NumberParser.cpp.i
+
+parsing/NumberParser.s: parsing/NumberParser.cpp.s
+
+.PHONY : parsing/NumberParser.s
+
+# target to generate assembly for a file
+parsing/NumberParser.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/NumberParser.cpp.s
+.PHONY : parsing/NumberParser.cpp.s
+
+parsing/Parser.o: parsing/Parser.cpp.o
+
+.PHONY : parsing/Parser.o
+
+# target to build an object file
+parsing/Parser.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser.cpp.o
+.PHONY : parsing/Parser.cpp.o
+
+parsing/Parser.i: parsing/Parser.cpp.i
+
+.PHONY : parsing/Parser.i
+
+# target to preprocess a source file
+parsing/Parser.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser.cpp.i
+.PHONY : parsing/Parser.cpp.i
+
+parsing/Parser.s: parsing/Parser.cpp.s
+
+.PHONY : parsing/Parser.s
+
+# target to generate assembly for a file
+parsing/Parser.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser.cpp.s
+.PHONY : parsing/Parser.cpp.s
+
+parsing/ParserBase.o: parsing/ParserBase.cpp.o
+
+.PHONY : parsing/ParserBase.o
+
+# target to build an object file
+parsing/ParserBase.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/ParserBase.cpp.o
+.PHONY : parsing/ParserBase.cpp.o
+
+parsing/ParserBase.i: parsing/ParserBase.cpp.i
+
+.PHONY : parsing/ParserBase.i
+
+# target to preprocess a source file
+parsing/ParserBase.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/ParserBase.cpp.i
+.PHONY : parsing/ParserBase.cpp.i
+
+parsing/ParserBase.s: parsing/ParserBase.cpp.s
+
+.PHONY : parsing/ParserBase.s
+
+# target to generate assembly for a file
+parsing/ParserBase.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/ParserBase.cpp.s
+.PHONY : parsing/ParserBase.cpp.s
+
+parsing/Parser_expressions.o: parsing/Parser_expressions.cpp.o
+
+.PHONY : parsing/Parser_expressions.o
+
+# target to build an object file
+parsing/Parser_expressions.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_expressions.cpp.o
+.PHONY : parsing/Parser_expressions.cpp.o
+
+parsing/Parser_expressions.i: parsing/Parser_expressions.cpp.i
+
+.PHONY : parsing/Parser_expressions.i
+
+# target to preprocess a source file
+parsing/Parser_expressions.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_expressions.cpp.i
+.PHONY : parsing/Parser_expressions.cpp.i
+
+parsing/Parser_expressions.s: parsing/Parser_expressions.cpp.s
+
+.PHONY : parsing/Parser_expressions.s
+
+# target to generate assembly for a file
+parsing/Parser_expressions.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_expressions.cpp.s
+.PHONY : parsing/Parser_expressions.cpp.s
+
+parsing/Parser_members.o: parsing/Parser_members.cpp.o
+
+.PHONY : parsing/Parser_members.o
+
+# target to build an object file
+parsing/Parser_members.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_members.cpp.o
+.PHONY : parsing/Parser_members.cpp.o
+
+parsing/Parser_members.i: parsing/Parser_members.cpp.i
+
+.PHONY : parsing/Parser_members.i
+
+# target to preprocess a source file
+parsing/Parser_members.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_members.cpp.i
+.PHONY : parsing/Parser_members.cpp.i
+
+parsing/Parser_members.s: parsing/Parser_members.cpp.s
+
+.PHONY : parsing/Parser_members.s
+
+# target to generate assembly for a file
+parsing/Parser_members.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_members.cpp.s
+.PHONY : parsing/Parser_members.cpp.s
+
+parsing/Parser_statements.o: parsing/Parser_statements.cpp.o
+
+.PHONY : parsing/Parser_statements.o
+
+# target to build an object file
+parsing/Parser_statements.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_statements.cpp.o
+.PHONY : parsing/Parser_statements.cpp.o
+
+parsing/Parser_statements.i: parsing/Parser_statements.cpp.i
+
+.PHONY : parsing/Parser_statements.i
+
+# target to preprocess a source file
+parsing/Parser_statements.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_statements.cpp.i
+.PHONY : parsing/Parser_statements.cpp.i
+
+parsing/Parser_statements.s: parsing/Parser_statements.cpp.s
+
+.PHONY : parsing/Parser_statements.s
+
+# target to generate assembly for a file
+parsing/Parser_statements.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Parser_statements.cpp.s
+.PHONY : parsing/Parser_statements.cpp.s
+
+parsing/Preprocessor.o: parsing/Preprocessor.cpp.o
+
+.PHONY : parsing/Preprocessor.o
+
+# target to build an object file
+parsing/Preprocessor.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor.cpp.o
+.PHONY : parsing/Preprocessor.cpp.o
+
+parsing/Preprocessor.i: parsing/Preprocessor.cpp.i
+
+.PHONY : parsing/Preprocessor.i
+
+# target to preprocess a source file
+parsing/Preprocessor.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor.cpp.i
+.PHONY : parsing/Preprocessor.cpp.i
+
+parsing/Preprocessor.s: parsing/Preprocessor.cpp.s
+
+.PHONY : parsing/Preprocessor.s
+
+# target to generate assembly for a file
+parsing/Preprocessor.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor.cpp.s
+.PHONY : parsing/Preprocessor.cpp.s
+
+parsing/Preprocessor_macros.o: parsing/Preprocessor_macros.cpp.o
+
+.PHONY : parsing/Preprocessor_macros.o
+
+# target to build an object file
+parsing/Preprocessor_macros.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor_macros.cpp.o
+.PHONY : parsing/Preprocessor_macros.cpp.o
+
+parsing/Preprocessor_macros.i: parsing/Preprocessor_macros.cpp.i
+
+.PHONY : parsing/Preprocessor_macros.i
+
+# target to preprocess a source file
+parsing/Preprocessor_macros.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor_macros.cpp.i
+.PHONY : parsing/Preprocessor_macros.cpp.i
+
+parsing/Preprocessor_macros.s: parsing/Preprocessor_macros.cpp.s
+
+.PHONY : parsing/Preprocessor_macros.s
+
+# target to generate assembly for a file
+parsing/Preprocessor_macros.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Preprocessor_macros.cpp.s
+.PHONY : parsing/Preprocessor_macros.cpp.s
+
+parsing/Token.o: parsing/Token.cpp.o
+
+.PHONY : parsing/Token.o
+
+# target to build an object file
+parsing/Token.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Token.cpp.o
+.PHONY : parsing/Token.cpp.o
+
+parsing/Token.i: parsing/Token.cpp.i
+
+.PHONY : parsing/Token.i
+
+# target to preprocess a source file
+parsing/Token.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Token.cpp.i
+.PHONY : parsing/Token.cpp.i
+
+parsing/Token.s: parsing/Token.cpp.s
+
+.PHONY : parsing/Token.s
+
+# target to generate assembly for a file
+parsing/Token.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/parsing/Token.cpp.s
+.PHONY : parsing/Token.cpp.s
+
+symbols/ASTSerializer.o: symbols/ASTSerializer.cpp.o
+
+.PHONY : symbols/ASTSerializer.o
+
+# target to build an object file
+symbols/ASTSerializer.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ASTSerializer.cpp.o
+.PHONY : symbols/ASTSerializer.cpp.o
+
+symbols/ASTSerializer.i: symbols/ASTSerializer.cpp.i
+
+.PHONY : symbols/ASTSerializer.i
+
+# target to preprocess a source file
+symbols/ASTSerializer.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ASTSerializer.cpp.i
+.PHONY : symbols/ASTSerializer.cpp.i
+
+symbols/ASTSerializer.s: symbols/ASTSerializer.cpp.s
+
+.PHONY : symbols/ASTSerializer.s
+
+# target to generate assembly for a file
+symbols/ASTSerializer.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ASTSerializer.cpp.s
+.PHONY : symbols/ASTSerializer.cpp.s
+
+symbols/AllTypes.o: symbols/AllTypes.cpp.o
+
+.PHONY : symbols/AllTypes.o
+
+# target to build an object file
+symbols/AllTypes.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AllTypes.cpp.o
+.PHONY : symbols/AllTypes.cpp.o
+
+symbols/AllTypes.i: symbols/AllTypes.cpp.i
+
+.PHONY : symbols/AllTypes.i
+
+# target to preprocess a source file
+symbols/AllTypes.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AllTypes.cpp.i
+.PHONY : symbols/AllTypes.cpp.i
+
+symbols/AllTypes.s: symbols/AllTypes.cpp.s
+
+.PHONY : symbols/AllTypes.s
+
+# target to generate assembly for a file
+symbols/AllTypes.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AllTypes.cpp.s
+.PHONY : symbols/AllTypes.cpp.s
+
+symbols/AttributeSymbol.o: symbols/AttributeSymbol.cpp.o
+
+.PHONY : symbols/AttributeSymbol.o
+
+# target to build an object file
+symbols/AttributeSymbol.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AttributeSymbol.cpp.o
+.PHONY : symbols/AttributeSymbol.cpp.o
+
+symbols/AttributeSymbol.i: symbols/AttributeSymbol.cpp.i
+
+.PHONY : symbols/AttributeSymbol.i
+
+# target to preprocess a source file
+symbols/AttributeSymbol.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AttributeSymbol.cpp.i
+.PHONY : symbols/AttributeSymbol.cpp.i
+
+symbols/AttributeSymbol.s: symbols/AttributeSymbol.cpp.s
+
+.PHONY : symbols/AttributeSymbol.s
+
+# target to generate assembly for a file
+symbols/AttributeSymbol.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/AttributeSymbol.cpp.s
+.PHONY : symbols/AttributeSymbol.cpp.s
+
+symbols/BlockSymbols.o: symbols/BlockSymbols.cpp.o
+
+.PHONY : symbols/BlockSymbols.o
+
+# target to build an object file
+symbols/BlockSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/BlockSymbols.cpp.o
+.PHONY : symbols/BlockSymbols.cpp.o
+
+symbols/BlockSymbols.i: symbols/BlockSymbols.cpp.i
+
+.PHONY : symbols/BlockSymbols.i
+
+# target to preprocess a source file
+symbols/BlockSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/BlockSymbols.cpp.i
+.PHONY : symbols/BlockSymbols.cpp.i
+
+symbols/BlockSymbols.s: symbols/BlockSymbols.cpp.s
+
+.PHONY : symbols/BlockSymbols.s
+
+# target to generate assembly for a file
+symbols/BlockSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/BlockSymbols.cpp.s
+.PHONY : symbols/BlockSymbols.cpp.s
+
+symbols/CompilationUnitSymbols.o: symbols/CompilationUnitSymbols.cpp.o
+
+.PHONY : symbols/CompilationUnitSymbols.o
+
+# target to build an object file
+symbols/CompilationUnitSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/CompilationUnitSymbols.cpp.o
+.PHONY : symbols/CompilationUnitSymbols.cpp.o
+
+symbols/CompilationUnitSymbols.i: symbols/CompilationUnitSymbols.cpp.i
+
+.PHONY : symbols/CompilationUnitSymbols.i
+
+# target to preprocess a source file
+symbols/CompilationUnitSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/CompilationUnitSymbols.cpp.i
+.PHONY : symbols/CompilationUnitSymbols.cpp.i
+
+symbols/CompilationUnitSymbols.s: symbols/CompilationUnitSymbols.cpp.s
+
+.PHONY : symbols/CompilationUnitSymbols.s
+
+# target to generate assembly for a file
+symbols/CompilationUnitSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/CompilationUnitSymbols.cpp.s
+.PHONY : symbols/CompilationUnitSymbols.cpp.s
+
+symbols/DeclaredType.o: symbols/DeclaredType.cpp.o
+
+.PHONY : symbols/DeclaredType.o
+
+# target to build an object file
+symbols/DeclaredType.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/DeclaredType.cpp.o
+.PHONY : symbols/DeclaredType.cpp.o
+
+symbols/DeclaredType.i: symbols/DeclaredType.cpp.i
+
+.PHONY : symbols/DeclaredType.i
+
+# target to preprocess a source file
+symbols/DeclaredType.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/DeclaredType.cpp.i
+.PHONY : symbols/DeclaredType.cpp.i
+
+symbols/DeclaredType.s: symbols/DeclaredType.cpp.s
+
+.PHONY : symbols/DeclaredType.s
+
+# target to generate assembly for a file
+symbols/DeclaredType.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/DeclaredType.cpp.s
+.PHONY : symbols/DeclaredType.cpp.s
+
+symbols/InstanceSymbols.o: symbols/InstanceSymbols.cpp.o
+
+.PHONY : symbols/InstanceSymbols.o
+
+# target to build an object file
+symbols/InstanceSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/InstanceSymbols.cpp.o
+.PHONY : symbols/InstanceSymbols.cpp.o
+
+symbols/InstanceSymbols.i: symbols/InstanceSymbols.cpp.i
+
+.PHONY : symbols/InstanceSymbols.i
+
+# target to preprocess a source file
+symbols/InstanceSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/InstanceSymbols.cpp.i
+.PHONY : symbols/InstanceSymbols.cpp.i
+
+symbols/InstanceSymbols.s: symbols/InstanceSymbols.cpp.s
+
+.PHONY : symbols/InstanceSymbols.s
+
+# target to generate assembly for a file
+symbols/InstanceSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/InstanceSymbols.cpp.s
+.PHONY : symbols/InstanceSymbols.cpp.s
+
+symbols/Lookup.o: symbols/Lookup.cpp.o
+
+.PHONY : symbols/Lookup.o
+
+# target to build an object file
+symbols/Lookup.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Lookup.cpp.o
+.PHONY : symbols/Lookup.cpp.o
+
+symbols/Lookup.i: symbols/Lookup.cpp.i
+
+.PHONY : symbols/Lookup.i
+
+# target to preprocess a source file
+symbols/Lookup.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Lookup.cpp.i
+.PHONY : symbols/Lookup.cpp.i
+
+symbols/Lookup.s: symbols/Lookup.cpp.s
+
+.PHONY : symbols/Lookup.s
+
+# target to generate assembly for a file
+symbols/Lookup.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Lookup.cpp.s
+.PHONY : symbols/Lookup.cpp.s
+
+symbols/MemberSymbols.o: symbols/MemberSymbols.cpp.o
+
+.PHONY : symbols/MemberSymbols.o
+
+# target to build an object file
+symbols/MemberSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/MemberSymbols.cpp.o
+.PHONY : symbols/MemberSymbols.cpp.o
+
+symbols/MemberSymbols.i: symbols/MemberSymbols.cpp.i
+
+.PHONY : symbols/MemberSymbols.i
+
+# target to preprocess a source file
+symbols/MemberSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/MemberSymbols.cpp.i
+.PHONY : symbols/MemberSymbols.cpp.i
+
+symbols/MemberSymbols.s: symbols/MemberSymbols.cpp.s
+
+.PHONY : symbols/MemberSymbols.s
+
+# target to generate assembly for a file
+symbols/MemberSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/MemberSymbols.cpp.s
+.PHONY : symbols/MemberSymbols.cpp.s
+
+symbols/ParameterSymbols.o: symbols/ParameterSymbols.cpp.o
+
+.PHONY : symbols/ParameterSymbols.o
+
+# target to build an object file
+symbols/ParameterSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ParameterSymbols.cpp.o
+.PHONY : symbols/ParameterSymbols.cpp.o
+
+symbols/ParameterSymbols.i: symbols/ParameterSymbols.cpp.i
+
+.PHONY : symbols/ParameterSymbols.i
+
+# target to preprocess a source file
+symbols/ParameterSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ParameterSymbols.cpp.i
+.PHONY : symbols/ParameterSymbols.cpp.i
+
+symbols/ParameterSymbols.s: symbols/ParameterSymbols.cpp.s
+
+.PHONY : symbols/ParameterSymbols.s
+
+# target to generate assembly for a file
+symbols/ParameterSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/ParameterSymbols.cpp.s
+.PHONY : symbols/ParameterSymbols.cpp.s
+
+symbols/PortSymbols.o: symbols/PortSymbols.cpp.o
+
+.PHONY : symbols/PortSymbols.o
+
+# target to build an object file
+symbols/PortSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/PortSymbols.cpp.o
+.PHONY : symbols/PortSymbols.cpp.o
+
+symbols/PortSymbols.i: symbols/PortSymbols.cpp.i
+
+.PHONY : symbols/PortSymbols.i
+
+# target to preprocess a source file
+symbols/PortSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/PortSymbols.cpp.i
+.PHONY : symbols/PortSymbols.cpp.i
+
+symbols/PortSymbols.s: symbols/PortSymbols.cpp.s
+
+.PHONY : symbols/PortSymbols.s
+
+# target to generate assembly for a file
+symbols/PortSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/PortSymbols.cpp.s
+.PHONY : symbols/PortSymbols.cpp.s
+
+symbols/Scope.o: symbols/Scope.cpp.o
+
+.PHONY : symbols/Scope.o
+
+# target to build an object file
+symbols/Scope.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Scope.cpp.o
+.PHONY : symbols/Scope.cpp.o
+
+symbols/Scope.i: symbols/Scope.cpp.i
+
+.PHONY : symbols/Scope.i
+
+# target to preprocess a source file
+symbols/Scope.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Scope.cpp.i
+.PHONY : symbols/Scope.cpp.i
+
+symbols/Scope.s: symbols/Scope.cpp.s
+
+.PHONY : symbols/Scope.s
+
+# target to generate assembly for a file
+symbols/Scope.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Scope.cpp.s
+.PHONY : symbols/Scope.cpp.s
+
+symbols/SemanticFacts.o: symbols/SemanticFacts.cpp.o
+
+.PHONY : symbols/SemanticFacts.o
+
+# target to build an object file
+symbols/SemanticFacts.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/SemanticFacts.cpp.o
+.PHONY : symbols/SemanticFacts.cpp.o
+
+symbols/SemanticFacts.i: symbols/SemanticFacts.cpp.i
+
+.PHONY : symbols/SemanticFacts.i
+
+# target to preprocess a source file
+symbols/SemanticFacts.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/SemanticFacts.cpp.i
+.PHONY : symbols/SemanticFacts.cpp.i
+
+symbols/SemanticFacts.s: symbols/SemanticFacts.cpp.s
+
+.PHONY : symbols/SemanticFacts.s
+
+# target to generate assembly for a file
+symbols/SemanticFacts.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/SemanticFacts.cpp.s
+.PHONY : symbols/SemanticFacts.cpp.s
+
+symbols/Symbol.o: symbols/Symbol.cpp.o
+
+.PHONY : symbols/Symbol.o
+
+# target to build an object file
+symbols/Symbol.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Symbol.cpp.o
+.PHONY : symbols/Symbol.cpp.o
+
+symbols/Symbol.i: symbols/Symbol.cpp.i
+
+.PHONY : symbols/Symbol.i
+
+# target to preprocess a source file
+symbols/Symbol.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Symbol.cpp.i
+.PHONY : symbols/Symbol.cpp.i
+
+symbols/Symbol.s: symbols/Symbol.cpp.s
+
+.PHONY : symbols/Symbol.s
+
+# target to generate assembly for a file
+symbols/Symbol.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Symbol.cpp.s
+.PHONY : symbols/Symbol.cpp.s
+
+symbols/Type.o: symbols/Type.cpp.o
+
+.PHONY : symbols/Type.o
+
+# target to build an object file
+symbols/Type.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Type.cpp.o
+.PHONY : symbols/Type.cpp.o
+
+symbols/Type.i: symbols/Type.cpp.i
+
+.PHONY : symbols/Type.i
+
+# target to preprocess a source file
+symbols/Type.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Type.cpp.i
+.PHONY : symbols/Type.cpp.i
+
+symbols/Type.s: symbols/Type.cpp.s
+
+.PHONY : symbols/Type.s
+
+# target to generate assembly for a file
+symbols/Type.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/Type.cpp.s
+.PHONY : symbols/Type.cpp.s
+
+symbols/TypePrinter.o: symbols/TypePrinter.cpp.o
+
+.PHONY : symbols/TypePrinter.o
+
+# target to build an object file
+symbols/TypePrinter.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/TypePrinter.cpp.o
+.PHONY : symbols/TypePrinter.cpp.o
+
+symbols/TypePrinter.i: symbols/TypePrinter.cpp.i
+
+.PHONY : symbols/TypePrinter.i
+
+# target to preprocess a source file
+symbols/TypePrinter.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/TypePrinter.cpp.i
+.PHONY : symbols/TypePrinter.cpp.i
+
+symbols/TypePrinter.s: symbols/TypePrinter.cpp.s
+
+.PHONY : symbols/TypePrinter.s
+
+# target to generate assembly for a file
+symbols/TypePrinter.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/TypePrinter.cpp.s
+.PHONY : symbols/TypePrinter.cpp.s
+
+symbols/VariableSymbols.o: symbols/VariableSymbols.cpp.o
+
+.PHONY : symbols/VariableSymbols.o
+
+# target to build an object file
+symbols/VariableSymbols.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/VariableSymbols.cpp.o
+.PHONY : symbols/VariableSymbols.cpp.o
+
+symbols/VariableSymbols.i: symbols/VariableSymbols.cpp.i
+
+.PHONY : symbols/VariableSymbols.i
+
+# target to preprocess a source file
+symbols/VariableSymbols.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/VariableSymbols.cpp.i
+.PHONY : symbols/VariableSymbols.cpp.i
+
+symbols/VariableSymbols.s: symbols/VariableSymbols.cpp.s
+
+.PHONY : symbols/VariableSymbols.s
+
+# target to generate assembly for a file
+symbols/VariableSymbols.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/symbols/VariableSymbols.cpp.s
+.PHONY : symbols/VariableSymbols.cpp.s
+
+syntax/SyntaxFacts.o: syntax/SyntaxFacts.cpp.o
+
+.PHONY : syntax/SyntaxFacts.o
+
+# target to build an object file
+syntax/SyntaxFacts.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxFacts.cpp.o
+.PHONY : syntax/SyntaxFacts.cpp.o
+
+syntax/SyntaxFacts.i: syntax/SyntaxFacts.cpp.i
+
+.PHONY : syntax/SyntaxFacts.i
+
+# target to preprocess a source file
+syntax/SyntaxFacts.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxFacts.cpp.i
+.PHONY : syntax/SyntaxFacts.cpp.i
+
+syntax/SyntaxFacts.s: syntax/SyntaxFacts.cpp.s
+
+.PHONY : syntax/SyntaxFacts.s
+
+# target to generate assembly for a file
+syntax/SyntaxFacts.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxFacts.cpp.s
+.PHONY : syntax/SyntaxFacts.cpp.s
+
+syntax/SyntaxNode.o: syntax/SyntaxNode.cpp.o
+
+.PHONY : syntax/SyntaxNode.o
+
+# target to build an object file
+syntax/SyntaxNode.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxNode.cpp.o
+.PHONY : syntax/SyntaxNode.cpp.o
+
+syntax/SyntaxNode.i: syntax/SyntaxNode.cpp.i
+
+.PHONY : syntax/SyntaxNode.i
+
+# target to preprocess a source file
+syntax/SyntaxNode.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxNode.cpp.i
+.PHONY : syntax/SyntaxNode.cpp.i
+
+syntax/SyntaxNode.s: syntax/SyntaxNode.cpp.s
+
+.PHONY : syntax/SyntaxNode.s
+
+# target to generate assembly for a file
+syntax/SyntaxNode.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxNode.cpp.s
+.PHONY : syntax/SyntaxNode.cpp.s
+
+syntax/SyntaxPrinter.o: syntax/SyntaxPrinter.cpp.o
+
+.PHONY : syntax/SyntaxPrinter.o
+
+# target to build an object file
+syntax/SyntaxPrinter.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxPrinter.cpp.o
+.PHONY : syntax/SyntaxPrinter.cpp.o
+
+syntax/SyntaxPrinter.i: syntax/SyntaxPrinter.cpp.i
+
+.PHONY : syntax/SyntaxPrinter.i
+
+# target to preprocess a source file
+syntax/SyntaxPrinter.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxPrinter.cpp.i
+.PHONY : syntax/SyntaxPrinter.cpp.i
+
+syntax/SyntaxPrinter.s: syntax/SyntaxPrinter.cpp.s
+
+.PHONY : syntax/SyntaxPrinter.s
+
+# target to generate assembly for a file
+syntax/SyntaxPrinter.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxPrinter.cpp.s
+.PHONY : syntax/SyntaxPrinter.cpp.s
+
+syntax/SyntaxTree.o: syntax/SyntaxTree.cpp.o
+
+.PHONY : syntax/SyntaxTree.o
+
+# target to build an object file
+syntax/SyntaxTree.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxTree.cpp.o
+.PHONY : syntax/SyntaxTree.cpp.o
+
+syntax/SyntaxTree.i: syntax/SyntaxTree.cpp.i
+
+.PHONY : syntax/SyntaxTree.i
+
+# target to preprocess a source file
+syntax/SyntaxTree.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxTree.cpp.i
+.PHONY : syntax/SyntaxTree.cpp.i
+
+syntax/SyntaxTree.s: syntax/SyntaxTree.cpp.s
+
+.PHONY : syntax/SyntaxTree.s
+
+# target to generate assembly for a file
+syntax/SyntaxTree.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxTree.cpp.s
+.PHONY : syntax/SyntaxTree.cpp.s
+
+syntax/SyntaxVisitor.o: syntax/SyntaxVisitor.cpp.o
+
+.PHONY : syntax/SyntaxVisitor.o
+
+# target to build an object file
+syntax/SyntaxVisitor.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxVisitor.cpp.o
+.PHONY : syntax/SyntaxVisitor.cpp.o
+
+syntax/SyntaxVisitor.i: syntax/SyntaxVisitor.cpp.i
+
+.PHONY : syntax/SyntaxVisitor.i
+
+# target to preprocess a source file
+syntax/SyntaxVisitor.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxVisitor.cpp.i
+.PHONY : syntax/SyntaxVisitor.cpp.i
+
+syntax/SyntaxVisitor.s: syntax/SyntaxVisitor.cpp.s
+
+.PHONY : syntax/SyntaxVisitor.s
+
+# target to generate assembly for a file
+syntax/SyntaxVisitor.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/syntax/SyntaxVisitor.cpp.s
+.PHONY : syntax/SyntaxVisitor.cpp.s
+
+text/Json.o: text/Json.cpp.o
+
+.PHONY : text/Json.o
+
+# target to build an object file
+text/Json.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/Json.cpp.o
+.PHONY : text/Json.cpp.o
+
+text/Json.i: text/Json.cpp.i
+
+.PHONY : text/Json.i
+
+# target to preprocess a source file
+text/Json.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/Json.cpp.i
+.PHONY : text/Json.cpp.i
+
+text/Json.s: text/Json.cpp.s
+
+.PHONY : text/Json.s
+
+# target to generate assembly for a file
+text/Json.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/Json.cpp.s
+.PHONY : text/Json.cpp.s
+
+text/SFormat.o: text/SFormat.cpp.o
+
+.PHONY : text/SFormat.o
+
+# target to build an object file
+text/SFormat.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SFormat.cpp.o
+.PHONY : text/SFormat.cpp.o
+
+text/SFormat.i: text/SFormat.cpp.i
+
+.PHONY : text/SFormat.i
+
+# target to preprocess a source file
+text/SFormat.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SFormat.cpp.i
+.PHONY : text/SFormat.cpp.i
+
+text/SFormat.s: text/SFormat.cpp.s
+
+.PHONY : text/SFormat.s
+
+# target to generate assembly for a file
+text/SFormat.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SFormat.cpp.s
+.PHONY : text/SFormat.cpp.s
+
+text/SourceManager.o: text/SourceManager.cpp.o
+
+.PHONY : text/SourceManager.o
+
+# target to build an object file
+text/SourceManager.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SourceManager.cpp.o
+.PHONY : text/SourceManager.cpp.o
+
+text/SourceManager.i: text/SourceManager.cpp.i
+
+.PHONY : text/SourceManager.i
+
+# target to preprocess a source file
+text/SourceManager.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SourceManager.cpp.i
+.PHONY : text/SourceManager.cpp.i
+
+text/SourceManager.s: text/SourceManager.cpp.s
+
+.PHONY : text/SourceManager.s
+
+# target to generate assembly for a file
+text/SourceManager.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/text/SourceManager.cpp.s
+.PHONY : text/SourceManager.cpp.s
+
+util/Assert.o: util/Assert.cpp.o
+
+.PHONY : util/Assert.o
+
+# target to build an object file
+util/Assert.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Assert.cpp.o
+.PHONY : util/Assert.cpp.o
+
+util/Assert.i: util/Assert.cpp.i
+
+.PHONY : util/Assert.i
+
+# target to preprocess a source file
+util/Assert.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Assert.cpp.i
+.PHONY : util/Assert.cpp.i
+
+util/Assert.s: util/Assert.cpp.s
+
+.PHONY : util/Assert.s
+
+# target to generate assembly for a file
+util/Assert.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Assert.cpp.s
+.PHONY : util/Assert.cpp.s
+
+util/BumpAllocator.o: util/BumpAllocator.cpp.o
+
+.PHONY : util/BumpAllocator.o
+
+# target to build an object file
+util/BumpAllocator.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/BumpAllocator.cpp.o
+.PHONY : util/BumpAllocator.cpp.o
+
+util/BumpAllocator.i: util/BumpAllocator.cpp.i
+
+.PHONY : util/BumpAllocator.i
+
+# target to preprocess a source file
+util/BumpAllocator.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/BumpAllocator.cpp.i
+.PHONY : util/BumpAllocator.cpp.i
+
+util/BumpAllocator.s: util/BumpAllocator.cpp.s
+
+.PHONY : util/BumpAllocator.s
+
+# target to generate assembly for a file
+util/BumpAllocator.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/BumpAllocator.cpp.s
+.PHONY : util/BumpAllocator.cpp.s
+
+util/CommandLine.o: util/CommandLine.cpp.o
+
+.PHONY : util/CommandLine.o
+
+# target to build an object file
+util/CommandLine.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/CommandLine.cpp.o
+.PHONY : util/CommandLine.cpp.o
+
+util/CommandLine.i: util/CommandLine.cpp.i
+
+.PHONY : util/CommandLine.i
+
+# target to preprocess a source file
+util/CommandLine.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/CommandLine.cpp.i
+.PHONY : util/CommandLine.cpp.i
+
+util/CommandLine.s: util/CommandLine.cpp.s
+
+.PHONY : util/CommandLine.s
+
+# target to generate assembly for a file
+util/CommandLine.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/CommandLine.cpp.s
+.PHONY : util/CommandLine.cpp.s
+
+util/Hash.o: util/Hash.cpp.o
+
+.PHONY : util/Hash.o
+
+# target to build an object file
+util/Hash.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Hash.cpp.o
+.PHONY : util/Hash.cpp.o
+
+util/Hash.i: util/Hash.cpp.i
+
+.PHONY : util/Hash.i
+
+# target to preprocess a source file
+util/Hash.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Hash.cpp.i
+.PHONY : util/Hash.cpp.i
+
+util/Hash.s: util/Hash.cpp.s
+
+.PHONY : util/Hash.s
+
+# target to generate assembly for a file
+util/Hash.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/Hash.cpp.s
+.PHONY : util/Hash.cpp.s
+
+util/OS.o: util/OS.cpp.o
+
+.PHONY : util/OS.o
+
+# target to build an object file
+util/OS.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/OS.cpp.o
+.PHONY : util/OS.cpp.o
+
+util/OS.i: util/OS.cpp.i
+
+.PHONY : util/OS.i
+
+# target to preprocess a source file
+util/OS.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/OS.cpp.i
+.PHONY : util/OS.cpp.i
+
+util/OS.s: util/OS.cpp.s
+
+.PHONY : util/OS.s
+
+# target to generate assembly for a file
+util/OS.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/OS.cpp.s
+.PHONY : util/OS.cpp.s
+
+util/String.o: util/String.cpp.o
+
+.PHONY : util/String.o
+
+# target to build an object file
+util/String.cpp.o:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/String.cpp.o
+.PHONY : util/String.cpp.o
+
+util/String.i: util/String.cpp.i
+
+.PHONY : util/String.i
+
+# target to preprocess a source file
+util/String.cpp.i:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/String.cpp.i
+.PHONY : util/String.cpp.i
+
+util/String.s: util/String.cpp.s
+
+.PHONY : util/String.s
+
+# target to generate assembly for a file
+util/String.cpp.s:
+	cd /soe/renau/projs/synth/slang/build && $(MAKE) -f source/CMakeFiles/slang.dir/build.make source/CMakeFiles/slang.dir/util/String.cpp.s
+.PHONY : util/String.cpp.s
+
+# Help Target
+help:
+	@echo "The following are some of the valid targets for this Makefile:"
+	@echo "... all (the default if no target is provided)"
+	@echo "... clean"
+	@echo "... depend"
+	@echo "... install/strip"
+	@echo "... install/local"
+	@echo "... install"
+	@echo "... list_install_components"
+	@echo "... rebuild_cache"
+	@echo "... edit_cache"
+	@echo "... test"
+	@echo "... slang"
+	@echo "... gen_version"
+	@echo "... AllSyntax.o"
+	@echo "... AllSyntax.i"
+	@echo "... AllSyntax.s"
+	@echo "... DiagCode.o"
+	@echo "... DiagCode.i"
+	@echo "... DiagCode.s"
+	@echo "... Version.o"
+	@echo "... Version.i"
+	@echo "... Version.s"
+	@echo "... binding/AssignmentExpressions.o"
+	@echo "... binding/AssignmentExpressions.i"
+	@echo "... binding/AssignmentExpressions.s"
+	@echo "... binding/BindContext.o"
+	@echo "... binding/BindContext.i"
+	@echo "... binding/BindContext.s"
+	@echo "... binding/ConstantValue.o"
+	@echo "... binding/ConstantValue.i"
+	@echo "... binding/ConstantValue.s"
+	@echo "... binding/EvalContext.o"
+	@echo "... binding/EvalContext.i"
+	@echo "... binding/EvalContext.s"
+	@echo "... binding/Expression.o"
+	@echo "... binding/Expression.i"
+	@echo "... binding/Expression.s"
+	@echo "... binding/LiteralExpressions.o"
+	@echo "... binding/LiteralExpressions.i"
+	@echo "... binding/LiteralExpressions.s"
+	@echo "... binding/MiscExpressions.o"
+	@echo "... binding/MiscExpressions.i"
+	@echo "... binding/MiscExpressions.s"
+	@echo "... binding/OperatorExpressions.o"
+	@echo "... binding/OperatorExpressions.i"
+	@echo "... binding/OperatorExpressions.s"
+	@echo "... binding/PatternExpressions.o"
+	@echo "... binding/PatternExpressions.i"
+	@echo "... binding/PatternExpressions.s"
+	@echo "... binding/Statements.o"
+	@echo "... binding/Statements.i"
+	@echo "... binding/Statements.s"
+	@echo "... binding/SystemSubroutine.o"
+	@echo "... binding/SystemSubroutine.i"
+	@echo "... binding/SystemSubroutine.s"
+	@echo "... binding/TimingControl.o"
+	@echo "... binding/TimingControl.i"
+	@echo "... binding/TimingControl.s"
+	@echo "... compilation/Compilation.o"
+	@echo "... compilation/Compilation.i"
+	@echo "... compilation/Compilation.s"
+	@echo "... compilation/Definition.o"
+	@echo "... compilation/Definition.i"
+	@echo "... compilation/Definition.s"
+	@echo "... compilation/InstanceCache.o"
+	@echo "... compilation/InstanceCache.i"
+	@echo "... compilation/InstanceCache.s"
+	@echo "... compilation/ScriptSession.o"
+	@echo "... compilation/ScriptSession.i"
+	@echo "... compilation/ScriptSession.s"
+	@echo "... compilation/SemanticModel.o"
+	@echo "... compilation/SemanticModel.i"
+	@echo "... compilation/SemanticModel.s"
+	@echo "... compilation/builtins/ArrayMethods.o"
+	@echo "... compilation/builtins/ArrayMethods.i"
+	@echo "... compilation/builtins/ArrayMethods.s"
+	@echo "... compilation/builtins/ConversionFuncs.o"
+	@echo "... compilation/builtins/ConversionFuncs.i"
+	@echo "... compilation/builtins/ConversionFuncs.s"
+	@echo "... compilation/builtins/EnumMethods.o"
+	@echo "... compilation/builtins/EnumMethods.i"
+	@echo "... compilation/builtins/EnumMethods.s"
+	@echo "... compilation/builtins/MathFuncs.o"
+	@echo "... compilation/builtins/MathFuncs.i"
+	@echo "... compilation/builtins/MathFuncs.s"
+	@echo "... compilation/builtins/MiscSystemFuncs.o"
+	@echo "... compilation/builtins/MiscSystemFuncs.i"
+	@echo "... compilation/builtins/MiscSystemFuncs.s"
+	@echo "... compilation/builtins/NonConstFuncs.o"
+	@echo "... compilation/builtins/NonConstFuncs.i"
+	@echo "... compilation/builtins/NonConstFuncs.s"
+	@echo "... compilation/builtins/QueryFuncs.o"
+	@echo "... compilation/builtins/QueryFuncs.i"
+	@echo "... compilation/builtins/QueryFuncs.s"
+	@echo "... compilation/builtins/StringMethods.o"
+	@echo "... compilation/builtins/StringMethods.i"
+	@echo "... compilation/builtins/StringMethods.s"
+	@echo "... compilation/builtins/SystemTasks.o"
+	@echo "... compilation/builtins/SystemTasks.i"
+	@echo "... compilation/builtins/SystemTasks.s"
+	@echo "... diagnostics/DiagnosticClient.o"
+	@echo "... diagnostics/DiagnosticClient.i"
+	@echo "... diagnostics/DiagnosticClient.s"
+	@echo "... diagnostics/DiagnosticEngine.o"
+	@echo "... diagnostics/DiagnosticEngine.i"
+	@echo "... diagnostics/DiagnosticEngine.s"
+	@echo "... diagnostics/Diagnostics.o"
+	@echo "... diagnostics/Diagnostics.i"
+	@echo "... diagnostics/Diagnostics.s"
+	@echo "... diagnostics/TextDiagnosticClient.o"
+	@echo "... diagnostics/TextDiagnosticClient.i"
+	@echo "... diagnostics/TextDiagnosticClient.s"
+	@echo "... numeric/SVInt.o"
+	@echo "... numeric/SVInt.i"
+	@echo "... numeric/SVInt.s"
+	@echo "... numeric/Time.o"
+	@echo "... numeric/Time.i"
+	@echo "... numeric/Time.s"
+	@echo "... parsing/Lexer.o"
+	@echo "... parsing/Lexer.i"
+	@echo "... parsing/Lexer.s"
+	@echo "... parsing/LexerFacts.o"
+	@echo "... parsing/LexerFacts.i"
+	@echo "... parsing/LexerFacts.s"
+	@echo "... parsing/NumberParser.o"
+	@echo "... parsing/NumberParser.i"
+	@echo "... parsing/NumberParser.s"
+	@echo "... parsing/Parser.o"
+	@echo "... parsing/Parser.i"
+	@echo "... parsing/Parser.s"
+	@echo "... parsing/ParserBase.o"
+	@echo "... parsing/ParserBase.i"
+	@echo "... parsing/ParserBase.s"
+	@echo "... parsing/Parser_expressions.o"
+	@echo "... parsing/Parser_expressions.i"
+	@echo "... parsing/Parser_expressions.s"
+	@echo "... parsing/Parser_members.o"
+	@echo "... parsing/Parser_members.i"
+	@echo "... parsing/Parser_members.s"
+	@echo "... parsing/Parser_statements.o"
+	@echo "... parsing/Parser_statements.i"
+	@echo "... parsing/Parser_statements.s"
+	@echo "... parsing/Preprocessor.o"
+	@echo "... parsing/Preprocessor.i"
+	@echo "... parsing/Preprocessor.s"
+	@echo "... parsing/Preprocessor_macros.o"
+	@echo "... parsing/Preprocessor_macros.i"
+	@echo "... parsing/Preprocessor_macros.s"
+	@echo "... parsing/Token.o"
+	@echo "... parsing/Token.i"
+	@echo "... parsing/Token.s"
+	@echo "... symbols/ASTSerializer.o"
+	@echo "... symbols/ASTSerializer.i"
+	@echo "... symbols/ASTSerializer.s"
+	@echo "... symbols/AllTypes.o"
+	@echo "... symbols/AllTypes.i"
+	@echo "... symbols/AllTypes.s"
+	@echo "... symbols/AttributeSymbol.o"
+	@echo "... symbols/AttributeSymbol.i"
+	@echo "... symbols/AttributeSymbol.s"
+	@echo "... symbols/BlockSymbols.o"
+	@echo "... symbols/BlockSymbols.i"
+	@echo "... symbols/BlockSymbols.s"
+	@echo "... symbols/CompilationUnitSymbols.o"
+	@echo "... symbols/CompilationUnitSymbols.i"
+	@echo "... symbols/CompilationUnitSymbols.s"
+	@echo "... symbols/DeclaredType.o"
+	@echo "... symbols/DeclaredType.i"
+	@echo "... symbols/DeclaredType.s"
+	@echo "... symbols/InstanceSymbols.o"
+	@echo "... symbols/InstanceSymbols.i"
+	@echo "... symbols/InstanceSymbols.s"
+	@echo "... symbols/Lookup.o"
+	@echo "... symbols/Lookup.i"
+	@echo "... symbols/Lookup.s"
+	@echo "... symbols/MemberSymbols.o"
+	@echo "... symbols/MemberSymbols.i"
+	@echo "... symbols/MemberSymbols.s"
+	@echo "... symbols/ParameterSymbols.o"
+	@echo "... symbols/ParameterSymbols.i"
+	@echo "... symbols/ParameterSymbols.s"
+	@echo "... symbols/PortSymbols.o"
+	@echo "... symbols/PortSymbols.i"
+	@echo "... symbols/PortSymbols.s"
+	@echo "... symbols/Scope.o"
+	@echo "... symbols/Scope.i"
+	@echo "... symbols/Scope.s"
+	@echo "... symbols/SemanticFacts.o"
+	@echo "... symbols/SemanticFacts.i"
+	@echo "... symbols/SemanticFacts.s"
+	@echo "... symbols/Symbol.o"
+	@echo "... symbols/Symbol.i"
+	@echo "... symbols/Symbol.s"
+	@echo "... symbols/Type.o"
+	@echo "... symbols/Type.i"
+	@echo "... symbols/Type.s"
+	@echo "... symbols/TypePrinter.o"
+	@echo "... symbols/TypePrinter.i"
+	@echo "... symbols/TypePrinter.s"
+	@echo "... symbols/VariableSymbols.o"
+	@echo "... symbols/VariableSymbols.i"
+	@echo "... symbols/VariableSymbols.s"
+	@echo "... syntax/SyntaxFacts.o"
+	@echo "... syntax/SyntaxFacts.i"
+	@echo "... syntax/SyntaxFacts.s"
+	@echo "... syntax/SyntaxNode.o"
+	@echo "... syntax/SyntaxNode.i"
+	@echo "... syntax/SyntaxNode.s"
+	@echo "... syntax/SyntaxPrinter.o"
+	@echo "... syntax/SyntaxPrinter.i"
+	@echo "... syntax/SyntaxPrinter.s"
+	@echo "... syntax/SyntaxTree.o"
+	@echo "... syntax/SyntaxTree.i"
+	@echo "... syntax/SyntaxTree.s"
+	@echo "... syntax/SyntaxVisitor.o"
+	@echo "... syntax/SyntaxVisitor.i"
+	@echo "... syntax/SyntaxVisitor.s"
+	@echo "... text/Json.o"
+	@echo "... text/Json.i"
+	@echo "... text/Json.s"
+	@echo "... text/SFormat.o"
+	@echo "... text/SFormat.i"
+	@echo "... text/SFormat.s"
+	@echo "... text/SourceManager.o"
+	@echo "... text/SourceManager.i"
+	@echo "... text/SourceManager.s"
+	@echo "... util/Assert.o"
+	@echo "... util/Assert.i"
+	@echo "... util/Assert.s"
+	@echo "... util/BumpAllocator.o"
+	@echo "... util/BumpAllocator.i"
+	@echo "... util/BumpAllocator.s"
+	@echo "... util/CommandLine.o"
+	@echo "... util/CommandLine.i"
+	@echo "... util/CommandLine.s"
+	@echo "... util/Hash.o"
+	@echo "... util/Hash.i"
+	@echo "... util/Hash.s"
+	@echo "... util/OS.o"
+	@echo "... util/OS.i"
+	@echo "... util/OS.s"
+	@echo "... util/String.o"
+	@echo "... util/String.i"
+	@echo "... util/String.s"
+.PHONY : help
+
+
+
+#=============================================================================
+# Special targets to cleanup operation of make.
+
+# Special rule to run CMake to check the build system integrity.
+# No rule that depends on this can have commands that come from listfiles
+# because they might be regenerated.
+cmake_check_build_system:
+	cd /soe/renau/projs/synth/slang/build && $(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
+.PHONY : cmake_check_build_system
+
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/AllDiags.h ./generated/slang/diagnostics/AllDiags.h
--- ./generated/slang/diagnostics/AllDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/AllDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,23 @@
+//------------------------------------------------------------------------------
+//! @file AllDiags.h
+//! @brief Combined header that includes all subsystem-specific diagnostic headers
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/CompilationDiags.h"
+#include "slang/diagnostics/ConstEvalDiags.h"
+#include "slang/diagnostics/DeclarationsDiags.h"
+#include "slang/diagnostics/ExpressionsDiags.h"
+#include "slang/diagnostics/GeneralDiags.h"
+#include "slang/diagnostics/LexerDiags.h"
+#include "slang/diagnostics/LookupDiags.h"
+#include "slang/diagnostics/MetaDiags.h"
+#include "slang/diagnostics/NumericDiags.h"
+#include "slang/diagnostics/ParserDiags.h"
+#include "slang/diagnostics/PreprocessorDiags.h"
+#include "slang/diagnostics/StatementsDiags.h"
+#include "slang/diagnostics/SysFuncsDiags.h"
+#include "slang/diagnostics/TypesDiags.h"
+
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/CompilationDiags.h ./generated/slang/diagnostics/CompilationDiags.h
--- ./generated/slang/diagnostics/CompilationDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/CompilationDiags.h	2020-04-13 10:23:52.680372298 -0700
@@ -0,0 +1,15 @@
+//------------------------------------------------------------------------------
+//! @file CompilationDiags.h
+//! @brief Generated diagnostic enums for the Compilation subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode MaxInstanceDepthExceeded(DiagSubsystem::Compilation, 0);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/ConstEvalDiags.h ./generated/slang/diagnostics/ConstEvalDiags.h
--- ./generated/slang/diagnostics/ConstEvalDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ConstEvalDiags.h	2020-04-13 10:23:52.680372298 -0700
@@ -0,0 +1,36 @@
+//------------------------------------------------------------------------------
+//! @file ConstEvalDiags.h
+//! @brief Generated diagnostic enums for the ConstEval subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NoteInCallTo(DiagSubsystem::ConstEval, 0);
+inline constexpr DiagCode NoteSkippingFrames(DiagSubsystem::ConstEval, 1);
+inline constexpr DiagCode ConstEvalNonConstVariable(DiagSubsystem::ConstEval, 2);
+inline constexpr DiagCode ConstEvalArrayIndexInvalid(DiagSubsystem::ConstEval, 3);
+inline constexpr DiagCode ConstEvalPartSelectInvalid(DiagSubsystem::ConstEval, 4);
+inline constexpr DiagCode ConstEvalStringIndexInvalid(DiagSubsystem::ConstEval, 5);
+inline constexpr DiagCode ConstEvalReplicationCountInvalid(DiagSubsystem::ConstEval, 6);
+inline constexpr DiagCode ConstEvalHierarchicalNameInCE(DiagSubsystem::ConstEval, 7);
+inline constexpr DiagCode ConstEvalFunctionIdentifiersMustBeLocal(DiagSubsystem::ConstEval, 8);
+inline constexpr DiagCode ConstEvalIdUsedInCEBeforeDecl(DiagSubsystem::ConstEval, 9);
+inline constexpr DiagCode ConstEvalNoCaseItemsMatched(DiagSubsystem::ConstEval, 10);
+inline constexpr DiagCode ConstEvalCaseItemsNotUnique(DiagSubsystem::ConstEval, 11);
+inline constexpr DiagCode ConstEvalTimedStmtNotConst(DiagSubsystem::ConstEval, 12);
+inline constexpr DiagCode ConstEvalAssertionFailed(DiagSubsystem::ConstEval, 13);
+inline constexpr DiagCode ConstEvalParallelBlockNotConst(DiagSubsystem::ConstEval, 14);
+inline constexpr DiagCode ConstEvalExceededMaxCallDepth(DiagSubsystem::ConstEval, 15);
+inline constexpr DiagCode ConstEvalExceededMaxSteps(DiagSubsystem::ConstEval, 16);
+inline constexpr DiagCode ConstEvalTaskNotConstant(DiagSubsystem::ConstEval, 17);
+inline constexpr DiagCode ConstEvalVoidNotConstant(DiagSubsystem::ConstEval, 18);
+inline constexpr DiagCode ConstEvalFunctionArgDirection(DiagSubsystem::ConstEval, 19);
+inline constexpr DiagCode ConstEvalFunctionInsideGenerate(DiagSubsystem::ConstEval, 20);
+inline constexpr DiagCode ConstEvalStaticSkipped(DiagSubsystem::ConstEval, 21);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/DeclarationsDiags.h ./generated/slang/diagnostics/DeclarationsDiags.h
--- ./generated/slang/diagnostics/DeclarationsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/DeclarationsDiags.h	2020-04-13 10:23:52.690372086 -0700
@@ -0,0 +1,66 @@
+//------------------------------------------------------------------------------
+//! @file DeclarationsDiags.h
+//! @brief Generated diagnostic enums for the Declarations subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode LocalParamNoInitializer(DiagSubsystem::Declarations, 0);
+inline constexpr DiagCode BodyParamNoInitializer(DiagSubsystem::Declarations, 1);
+inline constexpr DiagCode InvalidDimensionRange(DiagSubsystem::Declarations, 2);
+inline constexpr DiagCode DimensionRequiresConstRange(DiagSubsystem::Declarations, 3);
+inline constexpr DiagCode PackedDimsRequireFullRange(DiagSubsystem::Declarations, 4);
+inline constexpr DiagCode MixingOrderedAndNamedParams(DiagSubsystem::Declarations, 5);
+inline constexpr DiagCode DuplicateParamAssignment(DiagSubsystem::Declarations, 6);
+inline constexpr DiagCode ParamHasNoValue(DiagSubsystem::Declarations, 7);
+inline constexpr DiagCode TooManyParamAssignments(DiagSubsystem::Declarations, 8);
+inline constexpr DiagCode AssignedToLocalPortParam(DiagSubsystem::Declarations, 9);
+inline constexpr DiagCode AssignedToLocalBodyParam(DiagSubsystem::Declarations, 10);
+inline constexpr DiagCode ParameterDoesNotExist(DiagSubsystem::Declarations, 11);
+inline constexpr DiagCode BadTypeParamExpr(DiagSubsystem::Declarations, 12);
+inline constexpr DiagCode PortTypeNotInterfaceOrData(DiagSubsystem::Declarations, 13);
+inline constexpr DiagCode VarWithInterfacePort(DiagSubsystem::Declarations, 14);
+inline constexpr DiagCode DirectionWithInterfacePort(DiagSubsystem::Declarations, 15);
+inline constexpr DiagCode InOutPortCannotBeVariable(DiagSubsystem::Declarations, 16);
+inline constexpr DiagCode RefPortMustBeVariable(DiagSubsystem::Declarations, 17);
+inline constexpr DiagCode MissingPortIODeclaration(DiagSubsystem::Declarations, 18);
+inline constexpr DiagCode CantDeclarePortSigned(DiagSubsystem::Declarations, 19);
+inline constexpr DiagCode PortDeclDimensionsMismatch(DiagSubsystem::Declarations, 20);
+inline constexpr DiagCode PortDeclInANSIModule(DiagSubsystem::Declarations, 21);
+inline constexpr DiagCode UnknownPackage(DiagSubsystem::Declarations, 22);
+inline constexpr DiagCode UnknownModule(DiagSubsystem::Declarations, 23);
+inline constexpr DiagCode UnknownInterface(DiagSubsystem::Declarations, 24);
+inline constexpr DiagCode MixingOrderedAndNamedPorts(DiagSubsystem::Declarations, 25);
+inline constexpr DiagCode DuplicateWildcardPortConnection(DiagSubsystem::Declarations, 26);
+inline constexpr DiagCode DuplicatePortConnection(DiagSubsystem::Declarations, 27);
+inline constexpr DiagCode TooManyPortConnections(DiagSubsystem::Declarations, 28);
+inline constexpr DiagCode PortDoesNotExist(DiagSubsystem::Declarations, 29);
+inline constexpr DiagCode PortConnDimensionsMismatch(DiagSubsystem::Declarations, 30);
+inline constexpr DiagCode InterfacePortNotConnected(DiagSubsystem::Declarations, 31);
+inline constexpr DiagCode InterfacePortInvalidExpression(DiagSubsystem::Declarations, 32);
+inline constexpr DiagCode InterfacePortTypeMismatch(DiagSubsystem::Declarations, 33);
+inline constexpr DiagCode MismatchedTimeScales(DiagSubsystem::Declarations, 34);
+inline constexpr DiagCode TimeScaleFirstInScope(DiagSubsystem::Declarations, 35);
+inline constexpr DiagCode GenvarDuplicate(DiagSubsystem::Declarations, 36);
+inline constexpr DiagCode GenvarUnknownBits(DiagSubsystem::Declarations, 37);
+inline constexpr DiagCode ImplicitNamedPortNotFound(DiagSubsystem::Declarations, 38);
+inline constexpr DiagCode ImplicitNamedPortTypeMismatch(DiagSubsystem::Declarations, 39);
+inline constexpr DiagCode MaxGenerateStepsExceeded(DiagSubsystem::Declarations, 40);
+inline constexpr DiagCode MixingSubroutinePortKinds(DiagSubsystem::Declarations, 41);
+inline constexpr DiagCode UnpackedArrayParamType(DiagSubsystem::Declarations, 42);
+inline constexpr DiagCode AutomaticNotAllowed(DiagSubsystem::Declarations, 43);
+inline constexpr DiagCode StaticInitializerMustBeExplicit(DiagSubsystem::Declarations, 44);
+inline constexpr DiagCode CaseGenerateDup(DiagSubsystem::Declarations, 45);
+inline constexpr DiagCode CaseGenerateNoBlock(DiagSubsystem::Declarations, 46);
+inline constexpr DiagCode UnconnectedNamedPort(DiagSubsystem::Declarations, 47);
+inline constexpr DiagCode UnconnectedUnnamedPort(DiagSubsystem::Declarations, 48);
+inline constexpr DiagCode ImplicitNetPortNoDefault(DiagSubsystem::Declarations, 49);
+inline constexpr DiagCode DuplicateAttribute(DiagSubsystem::Declarations, 50);
+inline constexpr DiagCode EmptyMember(DiagSubsystem::Declarations, 51);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/ExpressionsDiags.h ./generated/slang/diagnostics/ExpressionsDiags.h
--- ./generated/slang/diagnostics/ExpressionsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ExpressionsDiags.h	2020-04-13 10:23:52.690372086 -0700
@@ -0,0 +1,69 @@
+//------------------------------------------------------------------------------
+//! @file ExpressionsDiags.h
+//! @brief Generated diagnostic enums for the Expressions subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode BadUnaryExpression(DiagSubsystem::Expressions, 0);
+inline constexpr DiagCode BadBinaryExpression(DiagSubsystem::Expressions, 1);
+inline constexpr DiagCode BadConditionalExpression(DiagSubsystem::Expressions, 2);
+inline constexpr DiagCode BadIndexExpression(DiagSubsystem::Expressions, 3);
+inline constexpr DiagCode BadConcatExpression(DiagSubsystem::Expressions, 4);
+inline constexpr DiagCode BadReplicationExpression(DiagSubsystem::Expressions, 5);
+inline constexpr DiagCode BadOpenRange(DiagSubsystem::Expressions, 6);
+inline constexpr DiagCode BadCastType(DiagSubsystem::Expressions, 7);
+inline constexpr DiagCode BadSetMembershipType(DiagSubsystem::Expressions, 8);
+inline constexpr DiagCode ConcatWithStringInt(DiagSubsystem::Expressions, 9);
+inline constexpr DiagCode BadRangeExpression(DiagSubsystem::Expressions, 10);
+inline constexpr DiagCode RangeWidthTooLarge(DiagSubsystem::Expressions, 11);
+inline constexpr DiagCode CannotIndexScalar(DiagSubsystem::Expressions, 12);
+inline constexpr DiagCode ExprMustBeIntegral(DiagSubsystem::Expressions, 13);
+inline constexpr DiagCode IndexValueInvalid(DiagSubsystem::Expressions, 14);
+inline constexpr DiagCode SelectEndianMismatch(DiagSubsystem::Expressions, 15);
+inline constexpr DiagCode BadAssignment(DiagSubsystem::Expressions, 16);
+inline constexpr DiagCode BadConversion(DiagSubsystem::Expressions, 17);
+inline constexpr DiagCode BadIntegerCast(DiagSubsystem::Expressions, 18);
+inline constexpr DiagCode NoImplicitConversion(DiagSubsystem::Expressions, 19);
+inline constexpr DiagCode TooManyArguments(DiagSubsystem::Expressions, 20);
+inline constexpr DiagCode TooFewArguments(DiagSubsystem::Expressions, 21);
+inline constexpr DiagCode ExpressionNotAssignable(DiagSubsystem::Expressions, 22);
+inline constexpr DiagCode ReplicationZeroOutsideConcat(DiagSubsystem::Expressions, 23);
+inline constexpr DiagCode InvalidMemberAccess(DiagSubsystem::Expressions, 24);
+inline constexpr DiagCode ExpressionNotCallable(DiagSubsystem::Expressions, 25);
+inline constexpr DiagCode NotBooleanConvertible(DiagSubsystem::Expressions, 26);
+inline constexpr DiagCode EnumValueSizeMismatch(DiagSubsystem::Expressions, 27);
+inline constexpr DiagCode EnumValueUnknownBits(DiagSubsystem::Expressions, 28);
+inline constexpr DiagCode NoCommonComparisonType(DiagSubsystem::Expressions, 29);
+inline constexpr DiagCode AssignmentPatternNoContext(DiagSubsystem::Expressions, 30);
+inline constexpr DiagCode BadAssignmentPatternType(DiagSubsystem::Expressions, 31);
+inline constexpr DiagCode WrongNumberAssignmentPatterns(DiagSubsystem::Expressions, 32);
+inline constexpr DiagCode AssignmentPatternKeyExpr(DiagSubsystem::Expressions, 33);
+inline constexpr DiagCode AssignmentPatternKeyDupDefault(DiagSubsystem::Expressions, 34);
+inline constexpr DiagCode AssignmentPatternKeyDupValue(DiagSubsystem::Expressions, 35);
+inline constexpr DiagCode AssignmentPatternKeyDupName(DiagSubsystem::Expressions, 36);
+inline constexpr DiagCode AssignmentPatternNoMember(DiagSubsystem::Expressions, 37);
+inline constexpr DiagCode AssignmentPatternNestedNoMember(DiagSubsystem::Expressions, 38);
+inline constexpr DiagCode AssignmentPatternMissingElements(DiagSubsystem::Expressions, 39);
+inline constexpr DiagCode EmptyArgNotAllowed(DiagSubsystem::Expressions, 40);
+inline constexpr DiagCode NamedArgNotAllowed(DiagSubsystem::Expressions, 41);
+inline constexpr DiagCode DuplicateArgAssignment(DiagSubsystem::Expressions, 42);
+inline constexpr DiagCode MixingOrderedAndNamedArgs(DiagSubsystem::Expressions, 43);
+inline constexpr DiagCode ArgDoesNotExist(DiagSubsystem::Expressions, 44);
+inline constexpr DiagCode ArgCannotBeEmpty(DiagSubsystem::Expressions, 45);
+inline constexpr DiagCode UnconnectedArg(DiagSubsystem::Expressions, 46);
+inline constexpr DiagCode MissingReturnValue(DiagSubsystem::Expressions, 47);
+inline constexpr DiagCode AssignmentNotAllowed(DiagSubsystem::Expressions, 48);
+inline constexpr DiagCode IncDecNotAllowed(DiagSubsystem::Expressions, 49);
+inline constexpr DiagCode AssignmentRequiresParens(DiagSubsystem::Expressions, 50);
+inline constexpr DiagCode PortConnArrayMismatch(DiagSubsystem::Expressions, 51);
+inline constexpr DiagCode AutoFromStaticInit(DiagSubsystem::Expressions, 52);
+inline constexpr DiagCode NonblockingAssignmentToAuto(DiagSubsystem::Expressions, 53);
+inline constexpr DiagCode AssignmentToConst(DiagSubsystem::Expressions, 54);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/GeneralDiags.h ./generated/slang/diagnostics/GeneralDiags.h
--- ./generated/slang/diagnostics/GeneralDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/GeneralDiags.h	2020-04-13 10:23:52.690372086 -0700
@@ -0,0 +1,22 @@
+//------------------------------------------------------------------------------
+//! @file GeneralDiags.h
+//! @brief Generated diagnostic enums for the General subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NotYetSupported(DiagSubsystem::General, 0);
+inline constexpr DiagCode ExpectedExpression(DiagSubsystem::General, 1);
+inline constexpr DiagCode NotePreviousDefinition(DiagSubsystem::General, 2);
+inline constexpr DiagCode NotePreviousUsage(DiagSubsystem::General, 3);
+inline constexpr DiagCode NoteDeclarationHere(DiagSubsystem::General, 4);
+inline constexpr DiagCode NotePreviousMatch(DiagSubsystem::General, 5);
+inline constexpr DiagCode AttributesNotAllowed(DiagSubsystem::General, 6);
+inline constexpr DiagCode WarnNotYetSupported(DiagSubsystem::General, 7);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/LexerDiags.h ./generated/slang/diagnostics/LexerDiags.h
--- ./generated/slang/diagnostics/LexerDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/LexerDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,36 @@
+//------------------------------------------------------------------------------
+//! @file LexerDiags.h
+//! @brief Generated diagnostic enums for the Lexer subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode NonPrintableChar(DiagSubsystem::Lexer, 0);
+inline constexpr DiagCode UTF8Char(DiagSubsystem::Lexer, 1);
+inline constexpr DiagCode UnicodeBOM(DiagSubsystem::Lexer, 2);
+inline constexpr DiagCode EmbeddedNull(DiagSubsystem::Lexer, 3);
+inline constexpr DiagCode MisplacedDirectiveChar(DiagSubsystem::Lexer, 4);
+inline constexpr DiagCode EscapedWhitespace(DiagSubsystem::Lexer, 5);
+inline constexpr DiagCode ExpectedClosingQuote(DiagSubsystem::Lexer, 6);
+inline constexpr DiagCode UnterminatedBlockComment(DiagSubsystem::Lexer, 7);
+inline constexpr DiagCode NestedBlockComment(DiagSubsystem::Lexer, 8);
+inline constexpr DiagCode ExpectedIntegerBaseAfterSigned(DiagSubsystem::Lexer, 9);
+inline constexpr DiagCode MissingFractionalDigits(DiagSubsystem::Lexer, 10);
+inline constexpr DiagCode OctalEscapeCodeTooBig(DiagSubsystem::Lexer, 11);
+inline constexpr DiagCode InvalidHexEscapeCode(DiagSubsystem::Lexer, 12);
+inline constexpr DiagCode UnknownEscapeCode(DiagSubsystem::Lexer, 13);
+inline constexpr DiagCode MissingExponentDigits(DiagSubsystem::Lexer, 14);
+inline constexpr DiagCode DigitsLeadingUnderscore(DiagSubsystem::Lexer, 15);
+inline constexpr DiagCode DecimalDigitMultipleUnknown(DiagSubsystem::Lexer, 16);
+inline constexpr DiagCode BadBinaryDigit(DiagSubsystem::Lexer, 17);
+inline constexpr DiagCode BadOctalDigit(DiagSubsystem::Lexer, 18);
+inline constexpr DiagCode BadDecimalDigit(DiagSubsystem::Lexer, 19);
+inline constexpr DiagCode BadHexDigit(DiagSubsystem::Lexer, 20);
+inline constexpr DiagCode TooManyLexerErrors(DiagSubsystem::Lexer, 21);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/LookupDiags.h ./generated/slang/diagnostics/LookupDiags.h
--- ./generated/slang/diagnostics/LookupDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/LookupDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,48 @@
+//------------------------------------------------------------------------------
+//! @file LookupDiags.h
+//! @brief Generated diagnostic enums for the Lookup subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode Redefinition(DiagSubsystem::Lookup, 0);
+inline constexpr DiagCode RedefinitionDifferentType(DiagSubsystem::Lookup, 1);
+inline constexpr DiagCode RedefinitionDifferentSymbolKind(DiagSubsystem::Lookup, 2);
+inline constexpr DiagCode AmbiguousWildcardImport(DiagSubsystem::Lookup, 3);
+inline constexpr DiagCode NoteImportedFrom(DiagSubsystem::Lookup, 4);
+inline constexpr DiagCode NoteHierarchicalNameInCE(DiagSubsystem::Lookup, 5);
+inline constexpr DiagCode ImportNameCollision(DiagSubsystem::Lookup, 6);
+inline constexpr DiagCode UndeclaredIdentifier(DiagSubsystem::Lookup, 7);
+inline constexpr DiagCode TypoIdentifier(DiagSubsystem::Lookup, 8);
+inline constexpr DiagCode UnknownSystemName(DiagSubsystem::Lookup, 9);
+inline constexpr DiagCode UnknownClassOrPackage(DiagSubsystem::Lookup, 10);
+inline constexpr DiagCode UsedBeforeDeclared(DiagSubsystem::Lookup, 11);
+inline constexpr DiagCode NotAType(DiagSubsystem::Lookup, 12);
+inline constexpr DiagCode NotAValue(DiagSubsystem::Lookup, 13);
+inline constexpr DiagCode NotAHierarchicalScope(DiagSubsystem::Lookup, 14);
+inline constexpr DiagCode NotAModport(DiagSubsystem::Lookup, 15);
+inline constexpr DiagCode NotAnInterface(DiagSubsystem::Lookup, 16);
+inline constexpr DiagCode NotAGenvar(DiagSubsystem::Lookup, 17);
+inline constexpr DiagCode DotOnType(DiagSubsystem::Lookup, 18);
+inline constexpr DiagCode HierarchicalNotAllowedInConstant(DiagSubsystem::Lookup, 19);
+inline constexpr DiagCode UnknownMember(DiagSubsystem::Lookup, 20);
+inline constexpr DiagCode UnknownPackageMember(DiagSubsystem::Lookup, 21);
+inline constexpr DiagCode UnknownUnitMember(DiagSubsystem::Lookup, 22);
+inline constexpr DiagCode RecursiveDefinition(DiagSubsystem::Lookup, 23);
+inline constexpr DiagCode UnknownSystemMethod(DiagSubsystem::Lookup, 24);
+inline constexpr DiagCode ScopeNotIndexable(DiagSubsystem::Lookup, 25);
+inline constexpr DiagCode InvalidScopeIndexExpression(DiagSubsystem::Lookup, 26);
+inline constexpr DiagCode ScopeIndexOutOfRange(DiagSubsystem::Lookup, 27);
+inline constexpr DiagCode CouldNotResolveHierarchicalPath(DiagSubsystem::Lookup, 28);
+inline constexpr DiagCode UnresolvedForwardTypedef(DiagSubsystem::Lookup, 29);
+inline constexpr DiagCode DefinitionUsedAsType(DiagSubsystem::Lookup, 30);
+inline constexpr DiagCode DefinitionUsedAsValue(DiagSubsystem::Lookup, 31);
+inline constexpr DiagCode AutoVariableHierarchical(DiagSubsystem::Lookup, 32);
+inline constexpr DiagCode DuplicateImport(DiagSubsystem::Lookup, 33);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/MetaDiags.h ./generated/slang/diagnostics/MetaDiags.h
--- ./generated/slang/diagnostics/MetaDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/MetaDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,16 @@
+//------------------------------------------------------------------------------
+//! @file MetaDiags.h
+//! @brief Generated diagnostic enums for the Meta subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode TooManyErrors(DiagSubsystem::Meta, 0);
+inline constexpr DiagCode UnknownWarningOption(DiagSubsystem::Meta, 1);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/NumericDiags.h ./generated/slang/diagnostics/NumericDiags.h
--- ./generated/slang/diagnostics/NumericDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/NumericDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,26 @@
+//------------------------------------------------------------------------------
+//! @file NumericDiags.h
+//! @brief Generated diagnostic enums for the Numeric subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode LiteralSizeIsZero(DiagSubsystem::Numeric, 0);
+inline constexpr DiagCode LiteralSizeTooLarge(DiagSubsystem::Numeric, 1);
+inline constexpr DiagCode SignedIntegerOverflow(DiagSubsystem::Numeric, 2);
+inline constexpr DiagCode ValueMustBeIntegral(DiagSubsystem::Numeric, 3);
+inline constexpr DiagCode ValueMustNotBeUnknown(DiagSubsystem::Numeric, 4);
+inline constexpr DiagCode ValueMustBePositive(DiagSubsystem::Numeric, 5);
+inline constexpr DiagCode ValueExceedsMaxBitWidth(DiagSubsystem::Numeric, 6);
+inline constexpr DiagCode ValueOutOfRange(DiagSubsystem::Numeric, 7);
+inline constexpr DiagCode ExpectedVectorDigits(DiagSubsystem::Numeric, 8);
+inline constexpr DiagCode RealLiteralUnderflow(DiagSubsystem::Numeric, 9);
+inline constexpr DiagCode RealLiteralOverflow(DiagSubsystem::Numeric, 10);
+inline constexpr DiagCode VectorLiteralOverflow(DiagSubsystem::Numeric, 11);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/ParserDiags.h ./generated/slang/diagnostics/ParserDiags.h
--- ./generated/slang/diagnostics/ParserDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/ParserDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,77 @@
+//------------------------------------------------------------------------------
+//! @file ParserDiags.h
+//! @brief Generated diagnostic enums for the Parser subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode ExpectedIdentifier(DiagSubsystem::Parser, 0);
+inline constexpr DiagCode ExpectedStringLiteral(DiagSubsystem::Parser, 1);
+inline constexpr DiagCode ExpectedIntegerLiteral(DiagSubsystem::Parser, 2);
+inline constexpr DiagCode ExpectedToken(DiagSubsystem::Parser, 3);
+inline constexpr DiagCode MisplacedTrailingSeparator(DiagSubsystem::Parser, 4);
+inline constexpr DiagCode ImplicitNotAllowed(DiagSubsystem::Parser, 5);
+inline constexpr DiagCode InvalidAccessDotColon(DiagSubsystem::Parser, 6);
+inline constexpr DiagCode ExpectedMember(DiagSubsystem::Parser, 7);
+inline constexpr DiagCode ExpectedStatement(DiagSubsystem::Parser, 8);
+inline constexpr DiagCode ExpectedParameterPort(DiagSubsystem::Parser, 9);
+inline constexpr DiagCode ExpectedNonAnsiPort(DiagSubsystem::Parser, 10);
+inline constexpr DiagCode ExpectedAnsiPort(DiagSubsystem::Parser, 11);
+inline constexpr DiagCode ExpectedModportPort(DiagSubsystem::Parser, 12);
+inline constexpr DiagCode ExpectedFunctionPort(DiagSubsystem::Parser, 13);
+inline constexpr DiagCode ExpectedAssertionItemPort(DiagSubsystem::Parser, 14);
+inline constexpr DiagCode ExpectedForInitializer(DiagSubsystem::Parser, 15);
+inline constexpr DiagCode ExpectedOpenRangeElement(DiagSubsystem::Parser, 16);
+inline constexpr DiagCode ExpectedStreamExpression(DiagSubsystem::Parser, 17);
+inline constexpr DiagCode ExpectedArgument(DiagSubsystem::Parser, 18);
+inline constexpr DiagCode ExpectedDeclarator(DiagSubsystem::Parser, 19);
+inline constexpr DiagCode ExpectedConditionalPattern(DiagSubsystem::Parser, 20);
+inline constexpr DiagCode ExpectedAttribute(DiagSubsystem::Parser, 21);
+inline constexpr DiagCode ExpectedPackageImport(DiagSubsystem::Parser, 22);
+inline constexpr DiagCode ExpectedHierarchicalInstantiation(DiagSubsystem::Parser, 23);
+inline constexpr DiagCode ExpectedGateInstance(DiagSubsystem::Parser, 24);
+inline constexpr DiagCode ExpectedPortConnection(DiagSubsystem::Parser, 25);
+inline constexpr DiagCode ExpectedVariableAssignment(DiagSubsystem::Parser, 26);
+inline constexpr DiagCode ExpectedContinuousAssignment(DiagSubsystem::Parser, 27);
+inline constexpr DiagCode ExpectedInterfaceClassName(DiagSubsystem::Parser, 28);
+inline constexpr DiagCode ExpectedAssignmentKey(DiagSubsystem::Parser, 29);
+inline constexpr DiagCode ExpectedDistItem(DiagSubsystem::Parser, 30);
+inline constexpr DiagCode ExpectedIfOrCase(DiagSubsystem::Parser, 31);
+inline constexpr DiagCode ExpectedClassScope(DiagSubsystem::Parser, 32);
+inline constexpr DiagCode ExpectedNetStrength(DiagSubsystem::Parser, 33);
+inline constexpr DiagCode ExpectedEnumBase(DiagSubsystem::Parser, 34);
+inline constexpr DiagCode ExpectedCaseItem(DiagSubsystem::Parser, 35);
+inline constexpr DiagCode NoLabelOnSemicolon(DiagSubsystem::Parser, 36);
+inline constexpr DiagCode DeferredDelayMustBeZero(DiagSubsystem::Parser, 37);
+inline constexpr DiagCode InvalidGenvarIterExpression(DiagSubsystem::Parser, 38);
+inline constexpr DiagCode ExpectedGenvarIterVar(DiagSubsystem::Parser, 39);
+inline constexpr DiagCode ConstFunctionPortRequiresRef(DiagSubsystem::Parser, 40);
+inline constexpr DiagCode ExpectedClockingSkew(DiagSubsystem::Parser, 41);
+inline constexpr DiagCode ExpectedDPISpecString(DiagSubsystem::Parser, 42);
+inline constexpr DiagCode ParseTreeTooDeep(DiagSubsystem::Parser, 43);
+inline constexpr DiagCode MissingModportPortDirection(DiagSubsystem::Parser, 44);
+inline constexpr DiagCode CaseStatementEmpty(DiagSubsystem::Parser, 45);
+inline constexpr DiagCode MultipleDefaultCases(DiagSubsystem::Parser, 46);
+inline constexpr DiagCode DirectionOnInterfacePort(DiagSubsystem::Parser, 47);
+inline constexpr DiagCode UnexpectedQualifiers(DiagSubsystem::Parser, 48);
+inline constexpr DiagCode ExpectedSampleKeyword(DiagSubsystem::Parser, 49);
+inline constexpr DiagCode MultipleGenerateDefaultCases(DiagSubsystem::Parser, 50);
+inline constexpr DiagCode CaseGenerateEmpty(DiagSubsystem::Parser, 51);
+inline constexpr DiagCode LabelAndName(DiagSubsystem::Parser, 52);
+inline constexpr DiagCode EndNameMismatch(DiagSubsystem::Parser, 53);
+inline constexpr DiagCode EndNameNotEmpty(DiagSubsystem::Parser, 54);
+inline constexpr DiagCode DeclarationsAtStart(DiagSubsystem::Parser, 55);
+inline constexpr DiagCode VoidNotAllowed(DiagSubsystem::Parser, 56);
+inline constexpr DiagCode DuplicateDeclModifier(DiagSubsystem::Parser, 57);
+inline constexpr DiagCode DeclModifierOrdering(DiagSubsystem::Parser, 58);
+inline constexpr DiagCode DeclModifierConflict(DiagSubsystem::Parser, 59);
+inline constexpr DiagCode TypeRefDeclVar(DiagSubsystem::Parser, 60);
+inline constexpr DiagCode NonStandardGenBlock(DiagSubsystem::Parser, 61);
+inline constexpr DiagCode NoteToMatchThis(DiagSubsystem::Parser, 62);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/PreprocessorDiags.h ./generated/slang/diagnostics/PreprocessorDiags.h
--- ./generated/slang/diagnostics/PreprocessorDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/PreprocessorDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,48 @@
+//------------------------------------------------------------------------------
+//! @file PreprocessorDiags.h
+//! @brief Generated diagnostic enums for the Preprocessor subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode CouldNotOpenIncludeFile(DiagSubsystem::Preprocessor, 0);
+inline constexpr DiagCode ExceededMaxIncludeDepth(DiagSubsystem::Preprocessor, 1);
+inline constexpr DiagCode UnknownDirective(DiagSubsystem::Preprocessor, 2);
+inline constexpr DiagCode UnexpectedConditionalDirective(DiagSubsystem::Preprocessor, 3);
+inline constexpr DiagCode MissingEndIfDirective(DiagSubsystem::Preprocessor, 4);
+inline constexpr DiagCode UnbalancedMacroArgDims(DiagSubsystem::Preprocessor, 5);
+inline constexpr DiagCode ExpectedMacroArgs(DiagSubsystem::Preprocessor, 6);
+inline constexpr DiagCode ExpectedNetType(DiagSubsystem::Preprocessor, 7);
+inline constexpr DiagCode ExpectedDriveStrength(DiagSubsystem::Preprocessor, 8);
+inline constexpr DiagCode InvalidMacroName(DiagSubsystem::Preprocessor, 9);
+inline constexpr DiagCode TooManyActualMacroArgs(DiagSubsystem::Preprocessor, 10);
+inline constexpr DiagCode NotEnoughMacroArgs(DiagSubsystem::Preprocessor, 11);
+inline constexpr DiagCode InvalidLineDirectiveLevel(DiagSubsystem::Preprocessor, 12);
+inline constexpr DiagCode UndefineBuiltinDirective(DiagSubsystem::Preprocessor, 13);
+inline constexpr DiagCode UnrecognizedKeywordVersion(DiagSubsystem::Preprocessor, 14);
+inline constexpr DiagCode MismatchedEndKeywordsDirective(DiagSubsystem::Preprocessor, 15);
+inline constexpr DiagCode InvalidTimeScaleSpecifier(DiagSubsystem::Preprocessor, 16);
+inline constexpr DiagCode InvalidTimeScalePrecision(DiagSubsystem::Preprocessor, 17);
+inline constexpr DiagCode RecursiveMacro(DiagSubsystem::Preprocessor, 18);
+inline constexpr DiagCode MacroOpsOutsideDefinition(DiagSubsystem::Preprocessor, 19);
+inline constexpr DiagCode SplitBlockCommentInDirective(DiagSubsystem::Preprocessor, 20);
+inline constexpr DiagCode ExpectedIncludeFileName(DiagSubsystem::Preprocessor, 21);
+inline constexpr DiagCode ExpectedTimeLiteral(DiagSubsystem::Preprocessor, 22);
+inline constexpr DiagCode ExpectedMacroStringifyEnd(DiagSubsystem::Preprocessor, 23);
+inline constexpr DiagCode ExpectedPragmaName(DiagSubsystem::Preprocessor, 24);
+inline constexpr DiagCode ExpectedPragmaExpression(DiagSubsystem::Preprocessor, 25);
+inline constexpr DiagCode DirectiveInsideDesignElement(DiagSubsystem::Preprocessor, 26);
+inline constexpr DiagCode IgnoredMacroPaste(DiagSubsystem::Preprocessor, 27);
+inline constexpr DiagCode RedefiningMacro(DiagSubsystem::Preprocessor, 28);
+inline constexpr DiagCode UnknownPragma(DiagSubsystem::Preprocessor, 29);
+inline constexpr DiagCode ExtraPragmaArgs(DiagSubsystem::Preprocessor, 30);
+inline constexpr DiagCode ExpectedDiagPragmaArg(DiagSubsystem::Preprocessor, 31);
+inline constexpr DiagCode UnknownDiagPragmaArg(DiagSubsystem::Preprocessor, 32);
+inline constexpr DiagCode ExpectedDiagPragmaLevel(DiagSubsystem::Preprocessor, 33);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/StatementsDiags.h ./generated/slang/diagnostics/StatementsDiags.h
--- ./generated/slang/diagnostics/StatementsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/StatementsDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,29 @@
+//------------------------------------------------------------------------------
+//! @file StatementsDiags.h
+//! @brief Generated diagnostic enums for the Statements subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode ReturnNotInSubroutine(DiagSubsystem::Statements, 0);
+inline constexpr DiagCode DelayNotNumeric(DiagSubsystem::Statements, 1);
+inline constexpr DiagCode InvalidEventExpression(DiagSubsystem::Statements, 2);
+inline constexpr DiagCode CoverStmtNoFail(DiagSubsystem::Statements, 3);
+inline constexpr DiagCode StatementNotInLoop(DiagSubsystem::Statements, 4);
+inline constexpr DiagCode ExprNotStatement(DiagSubsystem::Statements, 5);
+inline constexpr DiagCode VoidCastFuncCall(DiagSubsystem::Statements, 6);
+inline constexpr DiagCode NotAnArray(DiagSubsystem::Statements, 7);
+inline constexpr DiagCode TooManyForeachVars(DiagSubsystem::Statements, 8);
+inline constexpr DiagCode LoopVarShadowsArray(DiagSubsystem::Statements, 9);
+inline constexpr DiagCode CaseInsideKeyword(DiagSubsystem::Statements, 10);
+inline constexpr DiagCode EventExpressionConstant(DiagSubsystem::Statements, 11);
+inline constexpr DiagCode EmptyStatement(DiagSubsystem::Statements, 12);
+inline constexpr DiagCode PointlessVoidCast(DiagSubsystem::Statements, 13);
+inline constexpr DiagCode UnusedResult(DiagSubsystem::Statements, 14);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/SysFuncsDiags.h ./generated/slang/diagnostics/SysFuncsDiags.h
--- ./generated/slang/diagnostics/SysFuncsDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/SysFuncsDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,29 @@
+//------------------------------------------------------------------------------
+//! @file SysFuncsDiags.h
+//! @brief Generated diagnostic enums for the SysFuncs subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode BadSystemSubroutineArg(DiagSubsystem::SysFuncs, 0);
+inline constexpr DiagCode UnknownFormatSpecifier(DiagSubsystem::SysFuncs, 1);
+inline constexpr DiagCode MissingFormatSpecifier(DiagSubsystem::SysFuncs, 2);
+inline constexpr DiagCode FormatSpecifierWidthNotAllowed(DiagSubsystem::SysFuncs, 3);
+inline constexpr DiagCode FormatSpecifierInvalidWidth(DiagSubsystem::SysFuncs, 4);
+inline constexpr DiagCode FormatSpecifierNotFloat(DiagSubsystem::SysFuncs, 5);
+inline constexpr DiagCode FormatUnspecifiedType(DiagSubsystem::SysFuncs, 6);
+inline constexpr DiagCode FormatMismatchedType(DiagSubsystem::SysFuncs, 7);
+inline constexpr DiagCode FormatNoArgument(DiagSubsystem::SysFuncs, 8);
+inline constexpr DiagCode FormatEmptyArg(DiagSubsystem::SysFuncs, 9);
+inline constexpr DiagCode FormatTooManyArgs(DiagSubsystem::SysFuncs, 10);
+inline constexpr DiagCode InvalidStringArg(DiagSubsystem::SysFuncs, 11);
+inline constexpr DiagCode ArrayReductionIntegral(DiagSubsystem::SysFuncs, 12);
+inline constexpr DiagCode BadFinishNum(DiagSubsystem::SysFuncs, 13);
+inline constexpr DiagCode FormatRealInt(DiagSubsystem::SysFuncs, 14);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/diagnostics/TypesDiags.h ./generated/slang/diagnostics/TypesDiags.h
--- ./generated/slang/diagnostics/TypesDiags.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/diagnostics/TypesDiags.h	2020-04-13 10:23:52.700371875 -0700
@@ -0,0 +1,24 @@
+//------------------------------------------------------------------------------
+//! @file TypesDiags.h
+//! @brief Generated diagnostic enums for the Types subsystem
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/diagnostics/Diagnostics.h"
+
+namespace slang::diag {
+
+inline constexpr DiagCode InvalidEnumBase(DiagSubsystem::Types, 0);
+inline constexpr DiagCode EnumValueOverflow(DiagSubsystem::Types, 1);
+inline constexpr DiagCode EnumIncrementUnknown(DiagSubsystem::Types, 2);
+inline constexpr DiagCode EnumValueDuplicate(DiagSubsystem::Types, 3);
+inline constexpr DiagCode EnumRangeMultiDimensional(DiagSubsystem::Types, 4);
+inline constexpr DiagCode ForwardTypedefDoesNotMatch(DiagSubsystem::Types, 5);
+inline constexpr DiagCode PackedMemberNotIntegral(DiagSubsystem::Types, 6);
+inline constexpr DiagCode PackedMemberHasInitializer(DiagSubsystem::Types, 7);
+inline constexpr DiagCode PackedDimsOnPredefinedType(DiagSubsystem::Types, 8);
+inline constexpr DiagCode PackedUnionWidthMismatch(DiagSubsystem::Types, 9);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/syntax/AllSyntax.h ./generated/slang/syntax/AllSyntax.h
--- ./generated/slang/syntax/AllSyntax.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/syntax/AllSyntax.h	2020-04-13 10:23:52.690372086 -0700
@@ -0,0 +1,6551 @@
+//------------------------------------------------------------------------------
+//! @file AllSyntax.h
+//! @brief All generated syntax node data structures
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "slang/parsing/Token.h"
+#include "slang/syntax/SyntaxNode.h"
+#include "slang/util/BumpAllocator.h"
+
+// This file contains all parse tree syntax nodes.
+// It is auto-generated by the syntax_gen.py script under the scripts/ directory.
+
+namespace slang {
+
+struct ExpressionSyntax : public SyntaxNode {
+
+    ExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DataTypeSyntax : public ExpressionSyntax {
+
+    DataTypeSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+// ----- ATTRIBUTES -----
+
+struct EqualsValueClauseSyntax : public SyntaxNode {
+    Token equals;
+    not_null<ExpressionSyntax*> expr;
+
+    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EqualsValueClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AttributeSpecSyntax : public SyntaxNode {
+    Token name;
+    EqualsValueClauseSyntax* value;
+
+    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
+        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value) {
+        if (this->value) this->value->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AttributeSpecSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AttributeInstanceSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<AttributeSpecSyntax> specs;
+    Token closeParen;
+
+    AttributeInstanceSyntax(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen) :
+        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen) {
+        this->specs.parent = this;
+        for (auto child : this->specs)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AttributeInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedLabelSyntax : public SyntaxNode {
+    Token name;
+    Token colon;
+
+    NamedLabelSyntax(Token name, Token colon) :
+        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedLabelSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StatementSyntax : public SyntaxNode {
+    NamedLabelSyntax* label;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), label(label), attributes(attributes) {
+        if (this->label) this->label->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MemberSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    MemberSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), attributes(attributes) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- ARGUMENTS -----
+
+struct ArgumentSyntax : public SyntaxNode {
+
+    ArgumentSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct EmptyArgumentSyntax : public ArgumentSyntax {
+    Token placeholder;
+
+    EmptyArgumentSyntax(Token placeholder) :
+        ArgumentSyntax(SyntaxKind::EmptyArgument), placeholder(placeholder) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OrderedArgumentSyntax : public ArgumentSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    OrderedArgumentSyntax(ExpressionSyntax& expr) :
+        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedArgumentSyntax : public ArgumentSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<ArgumentSyntax> parameters;
+    Token closeParen;
+
+    ArgumentListSyntax(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen) :
+        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen) {
+        this->parameters.parent = this;
+        for (auto child : this->parameters)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterValueAssignmentSyntax : public SyntaxNode {
+    Token hash;
+    not_null<ArgumentListSyntax*> assignments;
+
+    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& assignments) :
+        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), assignments(&assignments) {
+        this->assignments->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterValueAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- PATTERNS -----
+
+struct PatternSyntax : public SyntaxNode {
+
+    PatternSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct VariablePatternSyntax : public PatternSyntax {
+    Token dot;
+    Token variableName;
+
+    VariablePatternSyntax(Token dot, Token variableName) :
+        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariablePatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPatternSyntax : public PatternSyntax {
+    Token dotStar;
+
+    WildcardPatternSyntax(Token dotStar) :
+        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionPatternSyntax : public PatternSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    ExpressionPatternSyntax(ExpressionSyntax& expr) :
+        PatternSyntax(SyntaxKind::ExpressionPattern), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TaggedPatternSyntax : public PatternSyntax {
+    Token tagged;
+    Token memberName;
+    PatternSyntax* pattern;
+
+    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
+        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern) {
+        if (this->pattern) this->pattern->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TaggedPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructurePatternMemberSyntax : public SyntaxNode {
+
+    StructurePatternMemberSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
+    not_null<PatternSyntax*> pattern;
+
+    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
+        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
+    Token name;
+    Token colon;
+    not_null<PatternSyntax*> pattern;
+
+    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
+        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructurePatternSyntax : public PatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
+    Token closeBrace;
+
+    StructurePatternSyntax(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace) :
+        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructurePatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MatchesClauseSyntax : public SyntaxNode {
+    Token matchesKeyword;
+    not_null<PatternSyntax*> pattern;
+
+    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
+        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(&pattern) {
+        this->pattern->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MatchesClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalPatternSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expr;
+    MatchesClauseSyntax* matchesClause;
+
+    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
+        SyntaxNode(SyntaxKind::ConditionalPattern), expr(&expr), matchesClause(matchesClause) {
+        this->expr->parent = this;
+        if (this->matchesClause) this->matchesClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalPredicateSyntax : public SyntaxNode {
+    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;
+
+    ConditionalPredicateSyntax(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions) :
+        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions) {
+        this->conditions.parent = this;
+        for (auto child : this->conditions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalPredicateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternSyntax : public SyntaxNode {
+
+    AssignmentPatternSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    Token closeBrace;
+
+    SimpleAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimpleAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> key;
+    Token colon;
+    not_null<ExpressionSyntax*> expr;
+
+    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(&key), colon(colon), expr(&expr) {
+        this->key->parent = this;
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssignmentPatternItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
+    Token closeBrace;
+
+    StructuredAssignmentPatternSyntax(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructuredAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
+    Token openBrace;
+    not_null<ExpressionSyntax*> countExpr;
+    Token innerOpenBrace;
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    Token innerCloseBrace;
+    Token closeBrace;
+
+    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace) :
+        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(&countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
+        this->countExpr->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ReplicatedAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- EXPRESSIONS -----
+
+struct BadExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    BadExpressionSyntax(ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::BadExpression), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BadExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PrimaryExpressionSyntax : public ExpressionSyntax {
+
+    PrimaryExpressionSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
+    Token operatorToken;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> operand;
+
+    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand) :
+        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(&operand) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->operand->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PrefixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> operand;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token operatorToken;
+
+    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken) :
+        ExpressionSyntax(kind), operand(&operand), attributes(attributes), operatorToken(operatorToken) {
+        this->operand->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PostfixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BinaryExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token operatorToken;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> right;
+
+    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right) :
+        ExpressionSyntax(kind), left(&left), operatorToken(operatorToken), attributes(attributes), right(&right) {
+        this->left->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> min;
+    Token colon1;
+    not_null<ExpressionSyntax*> typ;
+    Token colon2;
+    not_null<ExpressionSyntax*> max;
+
+    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
+        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(&min), colon1(colon1), typ(&typ), colon2(colon2), max(&max) {
+        this->min->parent = this;
+        this->typ->parent = this;
+        this->max->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MinTypMaxExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
+    Token tagged;
+    Token member;
+    ExpressionSyntax* expr;
+
+    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
+        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TaggedUnionExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OpenRangeExpressionSyntax : public ExpressionSyntax {
+    Token openBracket;
+    not_null<ExpressionSyntax*> left;
+    Token colon;
+    not_null<ExpressionSyntax*> right;
+    Token closeBracket;
+
+    OpenRangeExpressionSyntax(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket) :
+        ExpressionSyntax(SyntaxKind::OpenRangeExpression), openBracket(openBracket), left(&left), colon(colon), right(&right), closeBracket(closeBracket) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OpenRangeExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OpenRangeListSyntax : public SyntaxNode {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
+    Token closeBrace;
+
+    OpenRangeListSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace) :
+        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace) {
+        this->valueRanges.parent = this;
+        for (auto child : this->valueRanges)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OpenRangeListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InsideExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+    Token inside;
+    not_null<OpenRangeListSyntax*> ranges;
+
+    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
+        ExpressionSyntax(SyntaxKind::InsideExpression), expr(&expr), inside(inside), ranges(&ranges) {
+        this->expr->parent = this;
+        this->ranges->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InsideExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalExpressionSyntax : public ExpressionSyntax {
+    not_null<ConditionalPredicateSyntax*> predicate;
+    Token question;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    not_null<ExpressionSyntax*> left;
+    Token colon;
+    not_null<ExpressionSyntax*> right;
+
+    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(&predicate), question(question), attributes(attributes), left(&left), colon(colon), right(&right) {
+        this->predicate->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
+    DataTypeSyntax* type;
+    not_null<AssignmentPatternSyntax*> pattern;
+
+    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
+        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(&pattern) {
+        if (this->type) this->type->parent = this;
+        this->pattern->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssignmentPatternExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- SELECTORS -----
+
+struct SelectorSyntax : public SyntaxNode {
+
+    SelectorSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct BitSelectSyntax : public SelectorSyntax {
+    not_null<ExpressionSyntax*> expr;
+
+    BitSelectSyntax(ExpressionSyntax& expr) :
+        SelectorSyntax(SyntaxKind::BitSelect), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BitSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RangeSelectSyntax : public SelectorSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token range;
+    not_null<ExpressionSyntax*> right;
+
+    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
+        SelectorSyntax(kind), left(&left), range(range), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElementSelectSyntax : public SyntaxNode {
+    Token openBracket;
+    SelectorSyntax* selector;
+    Token closeBracket;
+
+    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
+        SyntaxNode(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket) {
+        if (this->selector) this->selector->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElementSelectSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- NAMES -----
+
+struct NameSyntax : public ExpressionSyntax {
+
+    NameSyntax(SyntaxKind kind) :
+        ExpressionSyntax(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct IdentifierNameSyntax : public NameSyntax {
+    Token identifier;
+
+    IdentifierNameSyntax(Token identifier) :
+        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IdentifierNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SystemNameSyntax : public NameSyntax {
+    Token systemIdentifier;
+
+    SystemNameSyntax(Token systemIdentifier) :
+        NameSyntax(SyntaxKind::SystemName), systemIdentifier(systemIdentifier) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SystemNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IdentifierSelectNameSyntax : public NameSyntax {
+    Token identifier;
+    SyntaxList<ElementSelectSyntax> selectors;
+
+    IdentifierSelectNameSyntax(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors) :
+        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors) {
+        this->selectors.parent = this;
+        for (auto child : this->selectors)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IdentifierSelectNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EmptyIdentifierNameSyntax : public NameSyntax {
+    Token placeholder;
+
+    EmptyIdentifierNameSyntax(Token placeholder) :
+        NameSyntax(SyntaxKind::EmptyIdentifierName), placeholder(placeholder) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyIdentifierNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct KeywordNameSyntax : public NameSyntax {
+    Token keyword;
+
+    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
+        NameSyntax(kind), keyword(keyword) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    KeywordNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassNameSyntax : public NameSyntax {
+    Token identifier;
+    not_null<ParameterValueAssignmentSyntax*> parameters;
+
+    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
+        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(&parameters) {
+        this->parameters->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ScopedNameSyntax : public NameSyntax {
+    not_null<NameSyntax*> left;
+    Token separator;
+    not_null<NameSyntax*> right;
+
+    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
+        NameSyntax(SyntaxKind::ScopedName), left(&left), separator(separator), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ScopedNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassScopeSyntax : public NameSyntax {
+    not_null<NameSyntax*> left;
+    Token separator;
+
+    ClassScopeSyntax(NameSyntax& left, Token separator) :
+        NameSyntax(SyntaxKind::ClassScope), left(&left), separator(separator) {
+        this->left->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassScopeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- PRIMARY EXPRESSIONS -----
+
+struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
+    Token literal;
+
+    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
+        PrimaryExpressionSyntax(kind), literal(literal) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LiteralExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
+    Token size;
+    Token base;
+    Token value;
+
+    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
+        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IntegerVectorExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    Token closeBrace;
+
+    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyQueueExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token closeBrace;
+
+    ConcatenationExpressionSyntax(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    not_null<ExpressionSyntax*> expression;
+    not_null<ConcatenationExpressionSyntax*> concatenation;
+    Token closeBrace;
+
+    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(&expression), concatenation(&concatenation), closeBrace(closeBrace) {
+        this->expression->parent = this;
+        this->concatenation->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MultipleConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamExpressionWithRangeSyntax : public SyntaxNode {
+    Token withKeyword;
+    not_null<ElementSelectSyntax*> range;
+
+    StreamExpressionWithRangeSyntax(Token withKeyword, ElementSelectSyntax& range) :
+        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(&range) {
+        this->range->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamExpressionWithRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamExpressionSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expression;
+    StreamExpressionWithRangeSyntax* withRange;
+
+    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange) :
+        SyntaxNode(SyntaxKind::StreamExpression), expression(&expression), withRange(withRange) {
+        this->expression->parent = this;
+        if (this->withRange) this->withRange->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openBrace;
+    Token operatorToken;
+    ExpressionSyntax* sliceSize;
+    Token innerOpenBrace;
+    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
+    Token innerCloseBrace;
+    Token closeBrace;
+
+    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace) :
+        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
+        if (this->sliceSize) this->sliceSize->parent = this;
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StreamingConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
+    Token openParen;
+    not_null<ExpressionSyntax*> expression;
+    Token closeParen;
+
+    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
+        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(&expression), closeParen(closeParen) {
+        this->expression->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenthesizedExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NewClassExpressionSyntax : public ExpressionSyntax {
+    ClassScopeSyntax* classScope;
+    Token newKeyword;
+    ArgumentListSyntax* arguments;
+
+    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) :
+        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments) {
+        if (this->classScope) this->classScope->parent = this;
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NewClassExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NewArrayExpressionSyntax : public ExpressionSyntax {
+    Token newKeyword;
+    Token openBracket;
+    not_null<ExpressionSyntax*> sizeExpr;
+    Token closeBracket;
+    ParenthesizedExpressionSyntax* initializer;
+
+    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
+        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(&sizeExpr), closeBracket(closeBracket), initializer(initializer) {
+        this->sizeExpr->parent = this;
+        if (this->initializer) this->initializer->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NewArrayExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NewExpressionSyntax : public ExpressionSyntax {
+    Token newKeyword;
+    not_null<ExpressionSyntax*> expr;
+
+    NewExpressionSyntax(Token newKeyword, ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::NewExpression), newKeyword(newKeyword), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NewExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- POSTFIX EXPRESSIONS -----
+
+struct ElementSelectExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    not_null<ElementSelectSyntax*> select;
+
+    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
+        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(&left), select(&select) {
+        this->left->parent = this;
+        this->select->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElementSelectExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MemberAccessExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token dot;
+    Token name;
+
+    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
+        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(&left), dot(dot), name(name) {
+        this->left->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MemberAccessExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InvocationExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    ArgumentListSyntax* arguments;
+
+    InvocationExpressionSyntax(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments) :
+        ExpressionSyntax(SyntaxKind::InvocationExpression), left(&left), attributes(attributes), arguments(arguments) {
+        this->left->parent = this;
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InvocationExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CastExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token apostrophe;
+    not_null<ParenthesizedExpressionSyntax*> right;
+
+    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::CastExpression), left(&left), apostrophe(apostrophe), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CastExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SignedCastExpressionSyntax : public ExpressionSyntax {
+    Token signing;
+    Token apostrophe;
+    not_null<ParenthesizedExpressionSyntax*> inner;
+
+    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
+        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(&inner) {
+        this->inner->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SignedCastExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TIMING CONTROL -----
+
+struct TimingControlSyntax : public SyntaxNode {
+
+    TimingControlSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DelaySyntax : public TimingControlSyntax {
+    Token hash;
+    not_null<ExpressionSyntax*> delayValue;
+
+    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
+        TimingControlSyntax(kind), hash(hash), delayValue(&delayValue) {
+        this->delayValue->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DelaySyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct Delay3Syntax : public TimingControlSyntax {
+    Token hash;
+    Token openParen;
+    not_null<ExpressionSyntax*> delay1;
+    Token comma1;
+    ExpressionSyntax* delay2;
+    Token comma2;
+    ExpressionSyntax* delay3;
+    Token closeParen;
+
+    Delay3Syntax(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen) :
+        TimingControlSyntax(SyntaxKind::Delay3), hash(hash), openParen(openParen), delay1(&delay1), comma1(comma1), delay2(delay2), comma2(comma2), delay3(delay3), closeParen(closeParen) {
+        this->delay1->parent = this;
+        if (this->delay2) this->delay2->parent = this;
+        if (this->delay3) this->delay3->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    Delay3Syntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventControlSyntax : public TimingControlSyntax {
+    Token at;
+    not_null<NameSyntax*> eventName;
+
+    EventControlSyntax(Token at, NameSyntax& eventName) :
+        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(&eventName) {
+        this->eventName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventExpressionSyntax : public SyntaxNode {
+
+    EventExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SignalEventExpressionSyntax : public EventExpressionSyntax {
+    Token edge;
+    not_null<ExpressionSyntax*> expr;
+
+    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr) :
+        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SignalEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
+    not_null<EventExpressionSyntax*> left;
+    Token operatorToken;
+    not_null<EventExpressionSyntax*> right;
+
+    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
+        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(&left), operatorToken(operatorToken), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
+    Token openParen;
+    not_null<EventExpressionSyntax*> expr;
+    Token closeParen;
+
+    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
+        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenthesizedEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitEventControlSyntax : public TimingControlSyntax {
+    Token at;
+    Token openParen;
+    Token star;
+    Token closeParen;
+
+    ImplicitEventControlSyntax(Token at, Token openParen, Token star, Token closeParen) :
+        TimingControlSyntax(SyntaxKind::ImplicitEventControl), at(at), openParen(openParen), star(star), closeParen(closeParen) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitEventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventControlWithExpressionSyntax : public TimingControlSyntax {
+    Token at;
+    not_null<EventExpressionSyntax*> expr;
+
+    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
+        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventControlWithExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RepeatedEventControlSyntax : public TimingControlSyntax {
+    Token repeat;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    TimingControlSyntax* eventControl;
+
+    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
+        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(&expr), closeParen(closeParen), eventControl(eventControl) {
+        this->expr->parent = this;
+        if (this->eventControl) this->eventControl->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RepeatedEventControlSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlExpressionSyntax : public ExpressionSyntax {
+    not_null<TimingControlSyntax*> timing;
+    not_null<ExpressionSyntax*> expr;
+
+    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
+        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(&timing), expr(&expr) {
+        this->timing->parent = this;
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> left;
+    not_null<TimingControlSyntax*> timing;
+    not_null<ExpressionSyntax*> right;
+
+    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
+        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(&left), timing(&timing), right(&right) {
+        this->left->parent = this;
+        this->timing->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlExpressionConcatenationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
+    Token doubleHash;
+    Token openBracket;
+    Token op;
+    Token closeBracket;
+
+    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
+        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ShortcutCycleDelayRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- DECLARATIONS -----
+
+struct DimensionSpecifierSyntax : public SyntaxNode {
+
+    DimensionSpecifierSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    not_null<SelectorSyntax*> selector;
+
+    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
+        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(&selector) {
+        this->selector->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    Token star;
+
+    WildcardDimensionSpecifierSyntax(Token star) :
+        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ColonExpressionClauseSyntax : public SyntaxNode {
+    Token colon;
+    not_null<ExpressionSyntax*> expr;
+
+    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ColonExpressionClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
+    Token dollar;
+    ColonExpressionClauseSyntax* maxSizeClause;
+
+    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
+        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause) {
+        if (this->maxSizeClause) this->maxSizeClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    QueueDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VariableDimensionSyntax : public SyntaxNode {
+    Token openBracket;
+    DimensionSpecifierSyntax* specifier;
+    Token closeBracket;
+
+    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
+        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket) {
+        if (this->specifier) this->specifier->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariableDimensionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DeclaratorSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    EqualsValueClauseSyntax* initializer;
+
+    DeclaratorSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer) :
+        SyntaxNode(SyntaxKind::Declarator), name(name), dimensions(dimensions), initializer(initializer) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+        if (this->initializer) this->initializer->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DeclaratorSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DataDeclarationSyntax : public MemberSyntax {
+    TokenList modifiers;
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    DataDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(&type), declarators(declarators), semi(semi) {
+        this->modifiers.parent = this;
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DataDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    not_null<DataTypeSyntax*> type;
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    Token semi;
+
+    TypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi) :
+        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(&type), name(name), dimensions(dimensions), semi(semi) {
+        this->type->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForwardTypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    Token keyword;
+    Token name;
+    Token semi;
+
+    ForwardTypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::ForwardTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForwardTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForwardInterfaceClassTypedefDeclarationSyntax : public MemberSyntax {
+    Token typedefKeyword;
+    Token interfaceKeyword;
+    Token classKeyword;
+    Token name;
+    Token semi;
+
+    ForwardInterfaceClassTypedefDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::ForwardInterfaceClassTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForwardInterfaceClassTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetStrengthSyntax : public SyntaxNode {
+
+    NetStrengthSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct ChargeStrengthSyntax : public NetStrengthSyntax {
+    Token openParen;
+    Token strength;
+    Token closeParen;
+
+    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
+        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ChargeStrengthSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DriveStrengthSyntax : public NetStrengthSyntax {
+    Token openParen;
+    Token strength0;
+    Token comma;
+    Token strength1;
+    Token closeParen;
+
+    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
+        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DriveStrengthSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetDeclarationSyntax : public MemberSyntax {
+    Token netType;
+    NetStrengthSyntax* strength;
+    Token expansionHint;
+    not_null<DataTypeSyntax*> type;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    NetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(&type), delay(delay), declarators(declarators), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        this->type->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WithFunctionClauseSyntax : public SyntaxNode {
+    Token with;
+    not_null<NameSyntax*> name;
+
+    WithFunctionClauseSyntax(Token with, NameSyntax& name) :
+        SyntaxNode(SyntaxKind::WithFunctionClause), with(with), name(&name) {
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithFunctionClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetTypeDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<DataTypeSyntax*> type;
+    Token name;
+    WithFunctionClauseSyntax* withFunction;
+    Token semi;
+
+    NetTypeDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi) :
+        MemberSyntax(SyntaxKind::NetTypeDeclaration, attributes), keyword(keyword), type(&type), name(name), withFunction(withFunction), semi(semi) {
+        this->type->parent = this;
+        if (this->withFunction) this->withFunction->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetTypeDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PackageImportItemSyntax : public SyntaxNode {
+    Token package;
+    Token doubleColon;
+    Token item;
+
+    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
+        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PackageImportItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PackageImportDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<PackageImportItemSyntax> items;
+    Token semi;
+
+    PackageImportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi) :
+        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PackageImportDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationBaseSyntax : public SyntaxNode {
+    Token keyword;
+
+    ParameterDeclarationBaseSyntax(SyntaxKind kind, Token keyword) :
+        SyntaxNode(kind), keyword(keyword) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationBaseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+
+    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators) :
+        ParameterDeclarationBaseSyntax(SyntaxKind::ParameterDeclaration, keyword), type(&type), declarators(declarators) {
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EqualsTypeClauseSyntax : public SyntaxNode {
+    Token equals;
+    not_null<DataTypeSyntax*> type;
+
+    EqualsTypeClauseSyntax(Token equals, DataTypeSyntax& type) :
+        SyntaxNode(SyntaxKind::EqualsTypeClause), equals(equals), type(&type) {
+        this->type->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EqualsTypeClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeAssignmentSyntax : public SyntaxNode {
+    Token name;
+    EqualsTypeClauseSyntax* assignment;
+
+    TypeAssignmentSyntax(Token name, EqualsTypeClauseSyntax* assignment) :
+        SyntaxNode(SyntaxKind::TypeAssignment), name(name), assignment(assignment) {
+        if (this->assignment) this->assignment->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeParameterDeclarationSyntax : public ParameterDeclarationBaseSyntax {
+    Token typeKeyword;
+    SeparatedSyntaxList<TypeAssignmentSyntax> declarators;
+
+    TypeParameterDeclarationSyntax(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators) :
+        ParameterDeclarationBaseSyntax(SyntaxKind::TypeParameterDeclaration, keyword), typeKeyword(typeKeyword), declarators(declarators) {
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeParameterDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterDeclarationStatementSyntax : public MemberSyntax {
+    not_null<ParameterDeclarationBaseSyntax*> parameter;
+    Token semi;
+
+    ParameterDeclarationStatementSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi) :
+        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(&parameter), semi(semi) {
+        this->parameter->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterDeclarationStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortHeaderSyntax : public SyntaxNode {
+
+    PortHeaderSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortDeclarationSyntax : public MemberSyntax {
+    not_null<PortHeaderSyntax*> header;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    PortDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(&header), declarators(declarators), semi(semi) {
+        this->header->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenvarDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
+    Token semi;
+
+    GenvarDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi) :
+        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi) {
+        this->identifiers.parent = this;
+        for (auto child : this->identifiers)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenvarDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TYPES -----
+
+struct IntegerTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    Token signing;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IntegerTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct KeywordTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+
+    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
+        DataTypeSyntax(kind), keyword(keyword) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    KeywordTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedTypeSyntax : public DataTypeSyntax {
+    not_null<NameSyntax*> name;
+
+    NamedTypeSyntax(NameSyntax& name) :
+        DataTypeSyntax(SyntaxKind::NamedType), name(&name) {
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructUnionMemberSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token randomQualifier;
+    not_null<DataTypeSyntax*> type;
+    SeparatedSyntaxList<DeclaratorSyntax> declarators;
+    Token semi;
+
+    StructUnionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi) :
+        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(&type), declarators(declarators), semi(semi) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->type->parent = this;
+        this->declarators.parent = this;
+        for (auto child : this->declarators)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructUnionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StructUnionTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    Token tagged;
+    Token packed;
+    Token signing;
+    Token openBrace;
+    SyntaxList<StructUnionMemberSyntax> members;
+    Token closeBrace;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StructUnionTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EnumTypeSyntax : public DataTypeSyntax {
+    Token keyword;
+    DataTypeSyntax* baseType;
+    Token openBrace;
+    SeparatedSyntaxList<DeclaratorSyntax> members;
+    Token closeBrace;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
+        if (this->baseType) this->baseType->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EnumTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TypeReferenceSyntax : public DataTypeSyntax {
+    Token typeKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TypeReferenceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DotMemberClauseSyntax : public SyntaxNode {
+    Token dot;
+    Token member;
+
+    DotMemberClauseSyntax(Token dot, Token member) :
+        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DotMemberClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
+    Token virtualKeyword;
+    Token interfaceKeyword;
+    Token name;
+    ParameterValueAssignmentSyntax* parameters;
+    DotMemberClauseSyntax* modport;
+
+    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
+        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport) {
+        if (this->parameters) this->parameters->parent = this;
+        if (this->modport) this->modport->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VirtualInterfaceTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitTypeSyntax : public DataTypeSyntax {
+    Token signing;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    ImplicitTypeSyntax(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitTypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- ASSERTIONS -----
+
+struct DeferredAssertionSyntax : public SyntaxNode {
+    Token hash;
+    Token zero;
+    Token finalKeyword;
+
+    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
+        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DeferredAssertionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElseClauseSyntax : public SyntaxNode {
+    Token elseKeyword;
+    not_null<SyntaxNode*> clause;
+
+    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
+        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(&clause) {
+        this->clause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElseClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ActionBlockSyntax : public SyntaxNode {
+    StatementSyntax* statement;
+    ElseClauseSyntax* elseClause;
+
+    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
+        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause) {
+        if (this->statement) this->statement->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ActionBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImmediateAssertionStatementSyntax : public StatementSyntax {
+    Token keyword;
+    DeferredAssertionSyntax* delay;
+    not_null<ParenthesizedExpressionSyntax*> expr;
+    not_null<ActionBlockSyntax*> action;
+
+    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(&expr), action(&action) {
+        if (this->delay) this->delay->parent = this;
+        this->expr->parent = this;
+        this->action->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImmediateAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableIffSyntax : public SyntaxNode {
+    Token disable;
+    Token iff;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableIffSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PropertySpecSyntax : public SyntaxNode {
+    TimingControlSyntax* clocking;
+    DisableIffSyntax* disable;
+    not_null<ExpressionSyntax*> expr;
+
+    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(&expr) {
+        if (this->clocking) this->clocking->parent = this;
+        if (this->disable) this->disable->parent = this;
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PropertySpecSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
+    Token keyword;
+    Token propertyOrSequence;
+    Token openParen;
+    not_null<PropertySpecSyntax*> propertySpec;
+    Token closeParen;
+    not_null<ActionBlockSyntax*> action;
+
+    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(&propertySpec), closeParen(closeParen), action(&action) {
+        this->propertySpec->parent = this;
+        this->action->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcurrentAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
+    not_null<ConcurrentAssertionStatementSyntax*> statement;
+
+    ConcurrentAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement) :
+        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConcurrentAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImmediateAssertionMemberSyntax : public MemberSyntax {
+    not_null<ImmediateAssertionStatementSyntax*> statement;
+
+    ImmediateAssertionMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement) :
+        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImmediateAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- STATEMENTS -----
+
+struct EmptyStatementSyntax : public StatementSyntax {
+    Token semicolon;
+
+    EmptyStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon) :
+        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalStatementSyntax : public StatementSyntax {
+    Token uniqueOrPriority;
+    Token ifKeyword;
+    Token openParen;
+    not_null<ConditionalPredicateSyntax*> predicate;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+    ElseClauseSyntax* elseClause;
+
+    ConditionalStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
+        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), statement(&statement), elseClause(elseClause) {
+        this->predicate->parent = this;
+        this->statement->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseItemSyntax : public SyntaxNode {
+
+    CaseItemSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DefaultCaseItemSyntax : public CaseItemSyntax {
+    Token defaultKeyword;
+    Token colon;
+    not_null<SyntaxNode*> clause;
+
+    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
+        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(&clause) {
+        this->clause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PatternCaseItemSyntax : public CaseItemSyntax {
+    not_null<PatternSyntax*> pattern;
+    Token tripleAnd;
+    ExpressionSyntax* expr;
+    Token colon;
+    not_null<StatementSyntax*> statement;
+
+    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
+        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(&pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(&statement) {
+        this->pattern->parent = this;
+        if (this->expr) this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PatternCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct StandardCaseItemSyntax : public CaseItemSyntax {
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token colon;
+    not_null<SyntaxNode*> clause;
+
+    StandardCaseItemSyntax(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause) :
+        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(&clause) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+        this->clause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    StandardCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseStatementSyntax : public StatementSyntax {
+    Token uniqueOrPriority;
+    Token caseKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token matchesOrInside;
+    SyntaxList<CaseItemSyntax> items;
+    Token endcase;
+
+    CaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase) :
+        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase) {
+        this->expr->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CaseStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeverStatementSyntax : public StatementSyntax {
+    Token foreverKeyword;
+    not_null<StatementSyntax*> statement;
+
+    ForeverStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeverStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopStatementSyntax : public StatementSyntax {
+    Token repeatOrWhile;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    LoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DoWhileStatementSyntax : public StatementSyntax {
+    Token doKeyword;
+    not_null<StatementSyntax*> statement;
+    Token whileKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token semi;
+
+    DoWhileStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
+        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(&statement), whileKeyword(whileKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
+        this->statement->parent = this;
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DoWhileStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForVariableDeclarationSyntax : public SyntaxNode {
+    Token varKeyword;
+    DataTypeSyntax* type;
+    not_null<DeclaratorSyntax*> declarator;
+
+    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(&declarator) {
+        if (this->type) this->type->parent = this;
+        this->declarator->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForVariableDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForLoopStatementSyntax : public StatementSyntax {
+    Token forKeyword;
+    Token openParen;
+    SeparatedSyntaxList<SyntaxNode> initializers;
+    Token semi1;
+    not_null<ExpressionSyntax*> stopExpr;
+    Token semi2;
+    SeparatedSyntaxList<ExpressionSyntax> steps;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    ForLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(&statement) {
+        this->initializers.parent = this;
+        for (auto child : this->initializers)
+            child->parent = this;
+        this->stopExpr->parent = this;
+        this->steps.parent = this;
+        for (auto child : this->steps)
+            child->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForLoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeachLoopListSyntax : public SyntaxNode {
+    Token openParen;
+    not_null<NameSyntax*> arrayName;
+    Token openBracket;
+    SeparatedSyntaxList<NameSyntax> loopVariables;
+    Token closeBracket;
+    Token closeParen;
+
+    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen) :
+        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(&arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen) {
+        this->arrayName->parent = this;
+        this->loopVariables.parent = this;
+        for (auto child : this->loopVariables)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeachLoopListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ForeachLoopStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ForeachLoopListSyntax*> loopList;
+    not_null<StatementSyntax*> statement;
+
+    ForeachLoopStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(&loopList), statement(&statement) {
+        this->loopList->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ForeachLoopStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ReturnStatementSyntax : public StatementSyntax {
+    Token returnKeyword;
+    ExpressionSyntax* returnValue;
+    Token semi;
+
+    ReturnStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
+        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi) {
+        if (this->returnValue) this->returnValue->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ReturnStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct JumpStatementSyntax : public StatementSyntax {
+    Token breakOrContinue;
+    Token semi;
+
+    JumpStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi) :
+        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    JumpStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimingControlStatementSyntax : public StatementSyntax {
+    not_null<TimingControlSyntax*> timingControl;
+    not_null<StatementSyntax*> statement;
+
+    TimingControlStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(&timingControl), statement(&statement) {
+        this->timingControl->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimingControlStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionStatementSyntax : public StatementSyntax {
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    ExpressionStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi) :
+        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VoidCastedCallStatementSyntax : public StatementSyntax {
+    Token voidKeyword;
+    Token apostrophe;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    Token semi;
+
+    VoidCastedCallStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
+        StatementSyntax(SyntaxKind::VoidCastedCallStatement, label, attributes), voidKeyword(voidKeyword), apostrophe(apostrophe), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VoidCastedCallStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralAssignStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ExpressionSyntax*> lvalue;
+    Token equals;
+    not_null<ExpressionSyntax*> value;
+    Token semi;
+
+    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(&lvalue), equals(equals), value(&value), semi(semi) {
+        this->lvalue->parent = this;
+        this->value->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralAssignStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralDeassignStatementSyntax : public StatementSyntax {
+    Token keyword;
+    not_null<ExpressionSyntax*> variable;
+    Token semi;
+
+    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
+        StatementSyntax(kind, label, attributes), keyword(keyword), variable(&variable), semi(semi) {
+        this->variable->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralDeassignStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableStatementSyntax : public StatementSyntax {
+    Token disable;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    DisableStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi) :
+        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(&name), semi(semi) {
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableForkStatementSyntax : public StatementSyntax {
+    Token disable;
+    Token fork;
+    Token semi;
+
+    DisableForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi) :
+        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableForkStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedBlockClauseSyntax : public SyntaxNode {
+    Token colon;
+    Token name;
+
+    NamedBlockClauseSyntax(Token colon, Token name) :
+        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedBlockClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockStatementSyntax : public StatementSyntax {
+    Token begin;
+    NamedBlockClauseSyntax* blockName;
+    SyntaxList<SyntaxNode> items;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
+        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName) {
+        if (this->blockName) this->blockName->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BlockStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitStatementSyntax : public StatementSyntax {
+    Token wait;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+    not_null<StatementSyntax*> statement;
+
+    WaitStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
+        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitForkStatementSyntax : public StatementSyntax {
+    Token wait;
+    Token fork;
+    Token semi;
+
+    WaitForkStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi) :
+        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitForkStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WaitOrderStatementSyntax : public StatementSyntax {
+    Token wait_order;
+    Token openParen;
+    SeparatedSyntaxList<NameSyntax> names;
+    Token closeParen;
+    not_null<ActionBlockSyntax*> action;
+
+    WaitOrderStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action) :
+        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(&action) {
+        this->names.parent = this;
+        for (auto child : this->names)
+            child->parent = this;
+        this->action->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WaitOrderStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RandCaseItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> expr;
+    Token colon;
+    not_null<StatementSyntax*> statement;
+
+    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
+        SyntaxNode(SyntaxKind::RandCaseItem), expr(&expr), colon(colon), statement(&statement) {
+        this->expr->parent = this;
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RandCaseItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RandCaseStatementSyntax : public StatementSyntax {
+    Token randCase;
+    SyntaxList<RandCaseItemSyntax> items;
+    Token endCase;
+
+    RandCaseStatementSyntax(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase) :
+        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RandCaseStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct EventTriggerStatementSyntax : public StatementSyntax {
+    Token trigger;
+    TimingControlSyntax* timing;
+    not_null<NameSyntax*> name;
+
+    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) :
+        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(&name) {
+        if (this->timing) this->timing->parent = this;
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EventTriggerStatementSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- MODULES -----
+
+struct PortListSyntax : public SyntaxNode {
+
+    PortListSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct NonAnsiPortSyntax : public SyntaxNode {
+
+    NonAnsiPortSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortExpressionSyntax : public SyntaxNode {
+
+    PortExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct PortReferenceSyntax : public PortExpressionSyntax {
+    Token name;
+    ElementSelectSyntax* select;
+
+    PortReferenceSyntax(Token name, ElementSelectSyntax* select) :
+        PortExpressionSyntax(SyntaxKind::PortReference), name(name), select(select) {
+        if (this->select) this->select->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortReferenceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortConcatenationSyntax : public PortExpressionSyntax {
+    Token openBrace;
+    SeparatedSyntaxList<PortReferenceSyntax> references;
+    Token closeBrace;
+
+    PortConcatenationSyntax(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace) :
+        PortExpressionSyntax(SyntaxKind::PortConcatenation), openBrace(openBrace), references(references), closeBrace(closeBrace) {
+        this->references.parent = this;
+        for (auto child : this->references)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortConcatenationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
+    PortExpressionSyntax* expr;
+
+    ImplicitNonAnsiPortSyntax(PortExpressionSyntax* expr) :
+        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    PortExpressionSyntax* expr;
+    Token closeParen;
+
+    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) :
+        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NonAnsiPortListSyntax : public PortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
+    Token closeParen;
+
+    NonAnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen) :
+        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NonAnsiPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
+    Token nameOrKeyword;
+    DotMemberClauseSyntax* modport;
+
+    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
+        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport) {
+        if (this->modport) this->modport->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InterfacePortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct VariablePortHeaderSyntax : public PortHeaderSyntax {
+    Token direction;
+    Token varKeyword;
+    not_null<DataTypeSyntax*> dataType;
+
+    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax& dataType) :
+        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), dataType(&dataType) {
+        this->dataType->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    VariablePortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
+    Token direction;
+    Token interconnect;
+    not_null<ImplicitTypeSyntax*> type;
+
+    InterconnectPortHeaderSyntax(Token direction, Token interconnect, ImplicitTypeSyntax& type) :
+        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(&type) {
+        this->type->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    InterconnectPortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NetPortHeaderSyntax : public PortHeaderSyntax {
+    Token direction;
+    Token netType;
+    not_null<DataTypeSyntax*> dataType;
+
+    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
+        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(&dataType) {
+        this->dataType->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NetPortHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicitAnsiPortSyntax : public MemberSyntax {
+    not_null<PortHeaderSyntax*> header;
+    not_null<DeclaratorSyntax*> declarator;
+
+    ImplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator) :
+        MemberSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(&header), declarator(&declarator) {
+        this->header->parent = this;
+        this->declarator->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExplicitAnsiPortSyntax : public MemberSyntax {
+    Token direction;
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    ExplicitAnsiPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        MemberSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AnsiPortListSyntax : public PortListSyntax {
+    Token openParen;
+    SeparatedSyntaxList<MemberSyntax> ports;
+    Token closeParen;
+
+    AnsiPortListSyntax(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen) :
+        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AnsiPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPortListSyntax : public PortListSyntax {
+    Token openParen;
+    Token dotStar;
+    Token closeParen;
+
+    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
+        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParameterPortListSyntax : public SyntaxNode {
+    Token hash;
+    Token openParen;
+    SeparatedSyntaxList<ParameterDeclarationBaseSyntax> declarations;
+    Token closeParen;
+
+    ParameterPortListSyntax(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen) :
+        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen) {
+        this->declarations.parent = this;
+        for (auto child : this->declarations)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParameterPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModuleHeaderSyntax : public SyntaxNode {
+    Token moduleKeyword;
+    Token lifetime;
+    Token name;
+    SyntaxList<PackageImportDeclarationSyntax> imports;
+    ParameterPortListSyntax* parameters;
+    PortListSyntax* ports;
+    Token semi;
+
+    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
+        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi) {
+        this->imports.parent = this;
+        for (auto child : this->imports)
+            child->parent = this;
+        if (this->parameters) this->parameters->parent = this;
+        if (this->ports) this->ports->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModuleHeaderSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModuleDeclarationSyntax : public MemberSyntax {
+    not_null<ModuleHeaderSyntax*> header;
+    SyntaxList<MemberSyntax> members;
+    Token endmodule;
+    NamedBlockClauseSyntax* blockName;
+
+    ModuleDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName) :
+        MemberSyntax(kind, attributes), header(&header), members(members), endmodule(endmodule), blockName(blockName) {
+        this->header->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->blockName) this->blockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModuleDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExternModuleSyntax : public SyntaxNode {
+    Token externKeyword;
+    not_null<ModuleHeaderSyntax*> header;
+
+    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
+        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(&header) {
+        this->header->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExternModuleSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- MEMBERS -----
+
+struct EmptyMemberSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token semi;
+
+    EmptyMemberSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi) :
+        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi) {
+        this->qualifiers.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    EmptyMemberSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ProceduralBlockSyntax : public MemberSyntax {
+    Token keyword;
+    not_null<StatementSyntax*> statement;
+
+    ProceduralBlockSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement) :
+        MemberSyntax(kind, attributes), keyword(keyword), statement(&statement) {
+        this->statement->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ProceduralBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenerateRegionSyntax : public MemberSyntax {
+    Token keyword;
+    SyntaxList<MemberSyntax> members;
+    Token endgenerate;
+
+    GenerateRegionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate) :
+        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenerateRegionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    Token genvar;
+    Token identifier;
+    Token equals;
+    not_null<ExpressionSyntax*> initialExpr;
+    Token semi1;
+    not_null<ExpressionSyntax*> stopExpr;
+    Token semi2;
+    not_null<ExpressionSyntax*> iterationExpr;
+    Token closeParen;
+    not_null<MemberSyntax*> block;
+
+    LoopGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
+        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(&initialExpr), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), iterationExpr(&iterationExpr), closeParen(closeParen), block(&block) {
+        this->initialExpr->parent = this;
+        this->stopExpr->parent = this;
+        this->iterationExpr->parent = this;
+        this->block->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IfGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    not_null<MemberSyntax*> block;
+    ElseClauseSyntax* elseClause;
+
+    IfGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
+        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), block(&block), elseClause(elseClause) {
+        this->condition->parent = this;
+        this->block->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IfGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CaseGenerateSyntax : public MemberSyntax {
+    Token keyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    SyntaxList<CaseItemSyntax> items;
+    Token endCase;
+
+    CaseGenerateSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase) :
+        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), items(items), endCase(endCase) {
+        this->condition->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CaseGenerateSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GenerateBlockSyntax : public MemberSyntax {
+    NamedLabelSyntax* label;
+    Token begin;
+    NamedBlockClauseSyntax* beginName;
+    SyntaxList<MemberSyntax> members;
+    Token end;
+    NamedBlockClauseSyntax* endName;
+
+    GenerateBlockSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName) :
+        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName) {
+        if (this->label) this->label->parent = this;
+        if (this->beginName) this->beginName->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->endName) this->endName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GenerateBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DividerClauseSyntax : public SyntaxNode {
+    Token divide;
+    Token value;
+
+    DividerClauseSyntax(Token divide, Token value) :
+        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DividerClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimeUnitsDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token time;
+    DividerClauseSyntax* divider;
+    Token semi;
+
+    TimeUnitsDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
+        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi) {
+        if (this->divider) this->divider->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimeUnitsDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PortConnectionSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+
+    PortConnectionSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes) :
+        SyntaxNode(kind), attributes(attributes) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
+    ExpressionSyntax* expr;
+
+    OrderedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax* expr) :
+        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    OrderedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NamedPortConnectionSyntax : public PortConnectionSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    NamedPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NamedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
+    Token dotStar;
+
+    WildcardPortConnectionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar) :
+        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WildcardPortConnectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct HierarchicalInstanceSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+    Token openParen;
+    SeparatedSyntaxList<PortConnectionSyntax> connections;
+    Token closeParen;
+
+    HierarchicalInstanceSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen) :
+        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+        this->connections.parent = this;
+        for (auto child : this->connections)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    HierarchicalInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct HierarchyInstantiationSyntax : public MemberSyntax {
+    Token type;
+    ParameterValueAssignmentSyntax* parameters;
+    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
+    Token semi;
+
+    HierarchyInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi) :
+        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi) {
+        if (this->parameters) this->parameters->parent = this;
+        this->instances.parent = this;
+        for (auto child : this->instances)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    HierarchyInstantiationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstanceNameSyntax : public SyntaxNode {
+    Token name;
+    SyntaxList<VariableDimensionSyntax> dimensions;
+
+    GateInstanceNameSyntax(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions) :
+        SyntaxNode(SyntaxKind::GateInstanceName), name(name), dimensions(dimensions) {
+        this->dimensions.parent = this;
+        for (auto child : this->dimensions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstanceNameSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstanceSyntax : public SyntaxNode {
+    GateInstanceNameSyntax* decl;
+    Token openParen;
+    SeparatedSyntaxList<ExpressionSyntax> connections;
+    Token closeParen;
+
+    GateInstanceSyntax(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen) :
+        SyntaxNode(SyntaxKind::GateInstance), decl(decl), openParen(openParen), connections(connections), closeParen(closeParen) {
+        if (this->decl) this->decl->parent = this;
+        this->connections.parent = this;
+        for (auto child : this->connections)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstanceSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct GateInstantiationSyntax : public MemberSyntax {
+    Token gateType;
+    DriveStrengthSyntax* strength;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<GateInstanceSyntax> instances;
+    Token semi;
+
+    GateInstantiationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi) :
+        MemberSyntax(SyntaxKind::GateInstantiation, attributes), gateType(gateType), strength(strength), delay(delay), instances(instances), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->instances.parent = this;
+        for (auto child : this->instances)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    GateInstantiationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPortSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token constKeyword;
+    Token direction;
+    Token varKeyword;
+    DataTypeSyntax* dataType;
+    not_null<DeclaratorSyntax*> declarator;
+
+    FunctionPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(&declarator) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        if (this->dataType) this->dataType->parent = this;
+        this->declarator->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPortListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<FunctionPortSyntax> ports;
+    Token closeParen;
+
+    FunctionPortListSyntax(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen) :
+        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionPrototypeSyntax : public SyntaxNode {
+    Token keyword;
+    Token lifetime;
+    not_null<DataTypeSyntax*> returnType;
+    not_null<NameSyntax*> name;
+    FunctionPortListSyntax* portList;
+
+    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList) :
+        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(&returnType), name(&name), portList(portList) {
+        this->returnType->parent = this;
+        this->name->parent = this;
+        if (this->portList) this->portList->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct FunctionDeclarationSyntax : public MemberSyntax {
+    not_null<FunctionPrototypeSyntax*> prototype;
+    Token semi;
+    SyntaxList<SyntaxNode> items;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    FunctionDeclarationSyntax(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(kind, attributes), prototype(&prototype), semi(semi), items(items), end(end), endBlockName(endBlockName) {
+        this->prototype->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    FunctionDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssertionItemPortSyntax : public SyntaxNode {
+    SyntaxList<AttributeInstanceSyntax> attributes;
+    Token local;
+    Token direction;
+    not_null<DataTypeSyntax*> type;
+    not_null<DeclaratorSyntax*> declarator;
+
+    AssertionItemPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator) :
+        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(&type), declarator(&declarator) {
+        this->attributes.parent = this;
+        for (auto child : this->attributes)
+            child->parent = this;
+        this->type->parent = this;
+        this->declarator->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssertionItemPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct AssertionItemPortListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
+    Token closeParen;
+
+    AssertionItemPortListSyntax(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen) :
+        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    AssertionItemPortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LetDeclarationSyntax : public MemberSyntax {
+    Token let;
+    Token identifier;
+    AssertionItemPortListSyntax* portList;
+    not_null<EqualsValueClauseSyntax*> initializer;
+    Token semi;
+
+    LetDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
+        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(&initializer), semi(semi) {
+        if (this->portList) this->portList->parent = this;
+        this->initializer->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LetDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PropertyDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token name;
+    AssertionItemPortListSyntax* portList;
+    Token semi;
+    SyntaxList<MemberSyntax> assertionVariables;
+    not_null<PropertySpecSyntax*> propertySpec;
+    Token optionalSemi;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    PropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::PropertyDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(&propertySpec), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        this->assertionVariables.parent = this;
+        for (auto child : this->assertionVariables)
+            child->parent = this;
+        this->propertySpec->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SequenceDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    Token name;
+    AssertionItemPortListSyntax* portList;
+    Token semi;
+    SyntaxList<MemberSyntax> assertionVariables;
+    not_null<ExpressionSyntax*> seqExpr;
+    Token optionalSemi;
+    Token end;
+    NamedBlockClauseSyntax* endBlockName;
+
+    SequenceDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::SequenceDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), seqExpr(&seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        this->assertionVariables.parent = this;
+        for (auto child : this->assertionVariables)
+            child->parent = this;
+        this->seqExpr->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SequenceDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExtendsClauseSyntax : public SyntaxNode {
+    Token keyword;
+    not_null<NameSyntax*> baseName;
+    ArgumentListSyntax* arguments;
+
+    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
+        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(&baseName), arguments(arguments) {
+        this->baseName->parent = this;
+        if (this->arguments) this->arguments->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExtendsClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplementsClauseSyntax : public SyntaxNode {
+    Token keyword;
+    SeparatedSyntaxList<NameSyntax> interfaces;
+
+    ImplementsClauseSyntax(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces) :
+        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces) {
+        this->interfaces.parent = this;
+        for (auto child : this->interfaces)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplementsClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassDeclarationSyntax : public MemberSyntax {
+    Token virtualOrInterface;
+    Token classKeyword;
+    Token lifetime;
+    Token name;
+    ParameterPortListSyntax* parameters;
+    ExtendsClauseSyntax* extendsClause;
+    ImplementsClauseSyntax* implementsClause;
+    Token semi;
+    SyntaxList<MemberSyntax> items;
+    Token endClass;
+    NamedBlockClauseSyntax* endBlockName;
+
+    ClassDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName) {
+        if (this->parameters) this->parameters->parent = this;
+        if (this->extendsClause) this->extendsClause->parent = this;
+        if (this->implementsClause) this->implementsClause->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassPropertyDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<MemberSyntax*> declaration;
+
+    ClassPropertyDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration) :
+        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
+        this->qualifiers.parent = this;
+        this->declaration->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassPropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassMethodDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<FunctionDeclarationSyntax*> declaration;
+
+    ClassMethodDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration) :
+        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
+        this->qualifiers.parent = this;
+        this->declaration->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassMethodDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClassMethodPrototypeSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    not_null<FunctionPrototypeSyntax*> prototype;
+    Token semi;
+
+    ClassMethodPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi) :
+        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(&prototype), semi(semi) {
+        this->qualifiers.parent = this;
+        this->prototype->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClassMethodPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ContinuousAssignSyntax : public MemberSyntax {
+    Token assign;
+    DriveStrengthSyntax* strength;
+    TimingControlSyntax* delay;
+    SeparatedSyntaxList<ExpressionSyntax> assignments;
+    Token semi;
+
+    ContinuousAssignSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi) :
+        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), strength(strength), delay(delay), assignments(assignments), semi(semi) {
+        if (this->strength) this->strength->parent = this;
+        if (this->delay) this->delay->parent = this;
+        this->assignments.parent = this;
+        for (auto child : this->assignments)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ContinuousAssignSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefParamAssignmentSyntax : public SyntaxNode {
+    not_null<NameSyntax*> name;
+    EqualsValueClauseSyntax* setter;
+
+    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax* setter) :
+        SyntaxNode(SyntaxKind::DefParamAssignment), name(&name), setter(setter) {
+        this->name->parent = this;
+        if (this->setter) this->setter->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefParamAssignmentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefParamSyntax : public MemberSyntax {
+    Token defparam;
+    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
+    Token semi;
+
+    DefParamSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi) :
+        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi) {
+        this->assignments.parent = this;
+        for (auto child : this->assignments)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefParamSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportClockingPortSyntax : public MemberSyntax {
+    Token clocking;
+    Token name;
+
+    ModportClockingPortSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name) :
+        MemberSyntax(SyntaxKind::ModportClockingPort, attributes), clocking(clocking), name(name) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportClockingPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportPortSyntax : public SyntaxNode {
+
+    ModportPortSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct ModportNamedPortSyntax : public ModportPortSyntax {
+    Token name;
+
+    ModportNamedPortSyntax(Token name) :
+        ModportPortSyntax(SyntaxKind::ModportNamedPort), name(name) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportNamedPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportExplicitPortSyntax : public ModportPortSyntax {
+    Token dot;
+    Token name;
+    Token openParen;
+    ExpressionSyntax* expr;
+    Token closeParen;
+
+    ModportExplicitPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
+        ModportPortSyntax(SyntaxKind::ModportExplicitPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
+        if (this->expr) this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportExplicitPortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSimplePortListSyntax : public MemberSyntax {
+    Token direction;
+    SeparatedSyntaxList<ModportPortSyntax> ports;
+
+    ModportSimplePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
+        MemberSyntax(SyntaxKind::ModportSimplePortList, attributes), direction(direction), ports(ports) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSimplePortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSubroutinePortSyntax : public ModportPortSyntax {
+    not_null<FunctionPrototypeSyntax*> prototype;
+
+    ModportSubroutinePortSyntax(FunctionPrototypeSyntax& prototype) :
+        ModportPortSyntax(SyntaxKind::ModportSubroutinePort), prototype(&prototype) {
+        this->prototype->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSubroutinePortSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportSubroutinePortListSyntax : public MemberSyntax {
+    Token importExport;
+    SeparatedSyntaxList<ModportPortSyntax> ports;
+
+    ModportSubroutinePortListSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports) :
+        MemberSyntax(SyntaxKind::ModportSubroutinePortList, attributes), importExport(importExport), ports(ports) {
+        this->ports.parent = this;
+        for (auto child : this->ports)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportSubroutinePortListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportItemSyntax : public SyntaxNode {
+    Token name;
+    not_null<AnsiPortListSyntax*> ports;
+
+    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
+        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(&ports) {
+        this->ports->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ModportDeclarationSyntax : public MemberSyntax {
+    Token keyword;
+    SeparatedSyntaxList<ModportItemSyntax> items;
+    Token semi;
+
+    ModportDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi) :
+        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ModportDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingSkewSyntax : public SyntaxNode {
+    Token edge;
+    Token hash;
+    ExpressionSyntax* value;
+
+    ClockingSkewSyntax(Token edge, Token hash, ExpressionSyntax* value) :
+        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), hash(hash), value(value) {
+        if (this->value) this->value->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingSkewSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingDirectionSyntax : public SyntaxNode {
+    Token input;
+    ClockingSkewSyntax* inputSkew;
+    Token output;
+    ClockingSkewSyntax* ouputSkew;
+    Token inout;
+
+    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) :
+        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew), inout(inout) {
+        if (this->inputSkew) this->inputSkew->parent = this;
+        if (this->ouputSkew) this->ouputSkew->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingDirectionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingItemSyntax : public SyntaxNode {
+    Token defaultKeyword;
+    ClockingDirectionSyntax* direction;
+    SeparatedSyntaxList<AttributeSpecSyntax> assignments;
+    Token semi;
+    MemberSyntax* declaration;
+
+    ClockingItemSyntax(Token defaultKeyword, ClockingDirectionSyntax* direction, const SeparatedSyntaxList<AttributeSpecSyntax>& assignments, Token semi, MemberSyntax* declaration) :
+        SyntaxNode(SyntaxKind::ClockingItem), defaultKeyword(defaultKeyword), direction(direction), assignments(assignments), semi(semi), declaration(declaration) {
+        if (this->direction) this->direction->parent = this;
+        this->assignments.parent = this;
+        for (auto child : this->assignments)
+            child->parent = this;
+        if (this->declaration) this->declaration->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ClockingDeclarationSyntax : public MemberSyntax {
+    Token globalOrDefault;
+    Token clocking;
+    Token blockName;
+    Token at;
+    ParenthesizedEventExpressionSyntax* event;
+    Token eventIdentifier;
+    Token semi;
+    SyntaxList<ClockingItemSyntax> items;
+    Token endClocking;
+    NamedBlockClauseSyntax* endBlockName;
+
+    ClockingDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, const SyntaxList<ClockingItemSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(event), eventIdentifier(eventIdentifier), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName) {
+        if (this->event) this->event->parent = this;
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ClockingDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DPIImportExportSyntax : public MemberSyntax {
+    Token keyword;
+    Token stringLiteral;
+    Token property;
+    Token c_identifier;
+    Token equals;
+    not_null<FunctionPrototypeSyntax*> method;
+    Token semi;
+
+    DPIImportExportSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token stringLiteral, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi) :
+        MemberSyntax(SyntaxKind::DPIImportExport, attributes), keyword(keyword), stringLiteral(stringLiteral), property(property), c_identifier(c_identifier), equals(equals), method(&method), semi(semi) {
+        this->method->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DPIImportExportSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- CONSTRAINTS -----
+
+struct ConstraintItemSyntax : public SyntaxNode {
+
+    ConstraintItemSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DistWeightSyntax : public SyntaxNode {
+    Token op;
+    not_null<ExpressionSyntax*> expr;
+
+    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
+        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(&expr) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistWeightSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DistItemSyntax : public SyntaxNode {
+    not_null<ExpressionSyntax*> range;
+    DistWeightSyntax* weight;
+
+    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
+        SyntaxNode(SyntaxKind::DistItem), range(&range), weight(weight) {
+        this->range->parent = this;
+        if (this->weight) this->weight->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistItemSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DistConstraintListSyntax : public SyntaxNode {
+    Token dist;
+    Token openBrace;
+    SeparatedSyntaxList<DistItemSyntax> items;
+    Token closeBrace;
+
+    DistConstraintListSyntax(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace) :
+        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DistConstraintListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionOrDistSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> expr;
+    not_null<DistConstraintListSyntax*> distribution;
+
+    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
+        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(&expr), distribution(&distribution) {
+        this->expr->parent = this;
+        this->distribution->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionOrDistSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
+    Token soft;
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
+    Token unique;
+    not_null<OpenRangeListSyntax*> ranges;
+    Token semi;
+
+    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(&ranges), semi(semi) {
+        this->ranges->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UniquenessConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
+    not_null<ExpressionSyntax*> left;
+    Token arrow;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
+        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(&left), arrow(arrow), constraints(&constraints) {
+        this->left->parent = this;
+        this->constraints->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ImplicationConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ElseConstraintClauseSyntax : public SyntaxNode {
+    Token elseKeyword;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
+        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(&constraints) {
+        this->constraints->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ElseConstraintClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
+    Token ifKeyword;
+    Token openParen;
+    not_null<ExpressionSyntax*> condition;
+    Token closeParen;
+    not_null<ConstraintItemSyntax*> constraints;
+    ElseConstraintClauseSyntax* elseClause;
+
+    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
+        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(&condition), closeParen(closeParen), constraints(&constraints), elseClause(elseClause) {
+        this->condition->parent = this;
+        this->constraints->parent = this;
+        if (this->elseClause) this->elseClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LoopConstraintSyntax : public ConstraintItemSyntax {
+    Token foreachKeyword;
+    not_null<ForeachLoopListSyntax*> loopList;
+    not_null<ConstraintItemSyntax*> constraints;
+
+    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
+        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(&loopList), constraints(&constraints) {
+        this->loopList->parent = this;
+        this->constraints->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LoopConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DisableConstraintSyntax : public ConstraintItemSyntax {
+    Token disable;
+    Token soft;
+    not_null<NameSyntax*> name;
+    Token semi;
+
+    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(&name), semi(semi) {
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DisableConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
+    Token solve;
+    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
+    Token before;
+    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
+    Token semi;
+
+    SolveBeforeConstraintSyntax(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi) :
+        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi) {
+        this->beforeExpr.parent = this;
+        for (auto child : this->beforeExpr)
+            child->parent = this;
+        this->afterExpr.parent = this;
+        for (auto child : this->afterExpr)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SolveBeforeConstraintSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintBlockSyntax : public ConstraintItemSyntax {
+    Token openBrace;
+    SyntaxList<ConstraintItemSyntax> items;
+    Token closeBrace;
+
+    ConstraintBlockSyntax(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace) :
+        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintBlockSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintPrototypeSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token keyword;
+    Token name;
+    Token semi;
+
+    ConstraintPrototypeSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, Token semi) :
+        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi) {
+        this->qualifiers.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintPrototypeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConstraintDeclarationSyntax : public MemberSyntax {
+    TokenList qualifiers;
+    Token keyword;
+    Token name;
+    not_null<ConstraintBlockSyntax*> block;
+
+    ConstraintDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) :
+        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(&block) {
+        this->qualifiers.parent = this;
+        this->block->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConstraintDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenExpressionListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<ExpressionSyntax> expressions;
+    Token closeParen;
+
+    ParenExpressionListSyntax(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen) :
+        SyntaxNode(SyntaxKind::ParenExpressionList), openParen(openParen), expressions(expressions), closeParen(closeParen) {
+        this->expressions.parent = this;
+        for (auto child : this->expressions)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenExpressionListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ArrayOrRandomizeMethodExpressionSyntax : public ExpressionSyntax {
+    not_null<ExpressionSyntax*> method;
+    Token with;
+    ParenExpressionListSyntax* args;
+    ConstraintBlockSyntax* constraints;
+
+    ArrayOrRandomizeMethodExpressionSyntax(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints) :
+        ExpressionSyntax(SyntaxKind::ArrayOrRandomizeMethodExpression), method(&method), with(with), args(args), constraints(constraints) {
+        this->method->parent = this;
+        if (this->args) this->args->parent = this;
+        if (this->constraints) this->constraints->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ArrayOrRandomizeMethodExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- COVER GROUPS -----
+
+struct WithFunctionSampleSyntax : public SyntaxNode {
+    Token with;
+    Token function;
+    Token sample;
+    not_null<AnsiPortListSyntax*> portList;
+
+    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
+        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(&portList) {
+        this->portList->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithFunctionSampleSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockEventExpressionSyntax : public SyntaxNode {
+
+    BlockEventExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
+    not_null<BlockEventExpressionSyntax*> left;
+    Token orKeyword;
+    not_null<BlockEventExpressionSyntax*> right;
+
+    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
+        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(&left), orKeyword(orKeyword), right(&right) {
+        this->left->parent = this;
+        this->right->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BinaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
+    Token keyword;
+    not_null<NameSyntax*> name;
+
+    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
+        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(&name) {
+        this->name->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PrimaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BlockCoverageEventSyntax : public SyntaxNode {
+    Token atat;
+    Token openParen;
+    not_null<BlockEventExpressionSyntax*> expr;
+    Token closeParen;
+
+    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BlockCoverageEventSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CovergroupDeclarationSyntax : public MemberSyntax {
+    Token covergroup;
+    Token name;
+    AnsiPortListSyntax* portList;
+    SyntaxNode* event;
+    Token semi;
+    SyntaxList<MemberSyntax> members;
+    Token endgroup;
+    NamedBlockClauseSyntax* endBlockName;
+
+    CovergroupDeclarationSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
+        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName) {
+        if (this->portList) this->portList->parent = this;
+        if (this->event) this->event->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+        if (this->endBlockName) this->endBlockName->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CovergroupDeclarationSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageOptionSyntax : public MemberSyntax {
+    Token option;
+    Token dot;
+    Token name;
+    Token equals;
+    not_null<ExpressionSyntax*> expr;
+    Token semi;
+
+    CoverageOptionSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
+        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(&expr), semi(semi) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverageOptionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverpointSyntax : public MemberSyntax {
+    DataTypeSyntax* type;
+    NamedLabelSyntax* label;
+    Token coverpoint;
+    not_null<ExpressionSyntax*> expr;
+    Token openBrace;
+    SyntaxList<MemberSyntax> members;
+    Token closeBrace;
+    Token emptySemi;
+
+    CoverpointSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi) :
+        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(&expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi) {
+        if (this->type) this->type->parent = this;
+        if (this->label) this->label->parent = this;
+        this->expr->parent = this;
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverpointSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageBinInitializerSyntax : public SyntaxNode {
+
+    CoverageBinInitializerSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    Token defaultKeyword;
+    Token sequenceKeyword;
+
+    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
+        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct WithClauseSyntax : public SyntaxNode {
+    Token with;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::WithClause), with(with), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    WithClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    not_null<ExpressionSyntax*> expr;
+    WithClauseSyntax* withClause;
+
+    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(&expr), withClause(withClause) {
+        this->expr->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ExpressionCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    not_null<OpenRangeListSyntax*> ranges;
+    WithClauseSyntax* withClause;
+
+    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(&ranges), withClause(withClause) {
+        this->ranges->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    RangeCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransRepeatRangeSyntax : public SyntaxNode {
+    Token openBracket;
+    Token specifier;
+    SelectorSyntax* selector;
+    Token closeBracket;
+
+    TransRepeatRangeSyntax(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) :
+        SyntaxNode(SyntaxKind::TransRepeatRange), openBracket(openBracket), specifier(specifier), selector(selector), closeBracket(closeBracket) {
+        if (this->selector) this->selector->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransRepeatRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransRangeSyntax : public SyntaxNode {
+    SeparatedSyntaxList<ExpressionSyntax> items;
+    TransRepeatRangeSyntax* repeat;
+
+    TransRangeSyntax(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat) :
+        SyntaxNode(SyntaxKind::TransRange), items(items), repeat(repeat) {
+        this->items.parent = this;
+        for (auto child : this->items)
+            child->parent = this;
+        if (this->repeat) this->repeat->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransRangeSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransSetSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<TransRangeSyntax> ranges;
+    Token closeParen;
+
+    TransSetSyntax(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen) :
+        SyntaxNode(SyntaxKind::TransSet), openParen(openParen), ranges(ranges), closeParen(closeParen) {
+        this->ranges.parent = this;
+        for (auto child : this->ranges)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransSetSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TransListCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
+    SeparatedSyntaxList<TransSetSyntax> sets;
+    WithClauseSyntax* withClause;
+
+    TransListCoverageBinInitializerSyntax(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause) :
+        CoverageBinInitializerSyntax(SyntaxKind::TransListCoverageBinInitializer), sets(sets), withClause(withClause) {
+        this->sets.parent = this;
+        for (auto child : this->sets)
+            child->parent = this;
+        if (this->withClause) this->withClause->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TransListCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IffClauseSyntax : public SyntaxNode {
+    Token iff;
+    Token openParen;
+    not_null<ExpressionSyntax*> expr;
+    Token closeParen;
+
+    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
+        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
+        this->expr->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IffClauseSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct CoverageBinsSyntax : public MemberSyntax {
+    Token wildcard;
+    Token keyword;
+    Token name;
+    ElementSelectSyntax* selector;
+    Token equals;
+    not_null<CoverageBinInitializerSyntax*> initializer;
+    IffClauseSyntax* iff;
+    Token semi;
+
+    CoverageBinsSyntax(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) :
+        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(&initializer), iff(iff), semi(semi) {
+        if (this->selector) this->selector->parent = this;
+        this->initializer->parent = this;
+        if (this->iff) this->iff->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CoverageBinsSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- TOP LEVEL -----
+
+struct CompilationUnitSyntax : public SyntaxNode {
+    SyntaxList<MemberSyntax> members;
+    Token endOfFile;
+
+    CompilationUnitSyntax(const SyntaxList<MemberSyntax>& members, Token endOfFile) :
+        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile) {
+        this->members.parent = this;
+        for (auto child : this->members)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    CompilationUnitSyntax* clone(BumpAllocator& alloc) const;
+};
+
+// ----- DIRECTIVES -----
+
+struct DirectiveSyntax : public SyntaxNode {
+    Token directive;
+
+    DirectiveSyntax(SyntaxKind kind, Token directive) :
+        SyntaxNode(kind), directive(directive) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct SimpleDirectiveSyntax : public DirectiveSyntax {
+
+    SimpleDirectiveSyntax(SyntaxKind kind, Token directive) :
+        DirectiveSyntax(kind, directive) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimpleDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct IncludeDirectiveSyntax : public DirectiveSyntax {
+    Token fileName;
+
+    IncludeDirectiveSyntax(Token directive, Token fileName) :
+        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    IncludeDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    TokenList disabledTokens;
+
+    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens) :
+        DirectiveSyntax(kind, directive), name(name), disabledTokens(disabledTokens) {
+        this->disabledTokens.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ConditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
+    TokenList disabledTokens;
+
+    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, const TokenList& disabledTokens) :
+        DirectiveSyntax(kind, directive), disabledTokens(disabledTokens) {
+        this->disabledTokens.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UnconditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroArgumentDefaultSyntax : public SyntaxNode {
+    Token equals;
+    TokenList tokens;
+
+    MacroArgumentDefaultSyntax(Token equals, const TokenList& tokens) :
+        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens) {
+        this->tokens.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroArgumentDefaultSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroFormalArgumentSyntax : public SyntaxNode {
+    Token name;
+    MacroArgumentDefaultSyntax* defaultValue;
+
+    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
+        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue) {
+        if (this->defaultValue) this->defaultValue->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroFormalArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroFormalArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
+    Token closeParen;
+
+    MacroFormalArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen) :
+        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroFormalArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefineDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    MacroFormalArgumentListSyntax* formalArguments;
+    TokenList body;
+
+    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body) :
+        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body) {
+        if (this->formalArguments) this->formalArguments->parent = this;
+        this->body.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefineDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroActualArgumentSyntax : public SyntaxNode {
+    TokenList tokens;
+
+    MacroActualArgumentSyntax(const TokenList& tokens) :
+        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens) {
+        this->tokens.parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroActualArgumentSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroActualArgumentListSyntax : public SyntaxNode {
+    Token openParen;
+    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
+    Token closeParen;
+
+    MacroActualArgumentListSyntax(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen) :
+        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroActualArgumentListSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct MacroUsageSyntax : public DirectiveSyntax {
+    MacroActualArgumentListSyntax* args;
+
+    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
+        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args) {
+        if (this->args) this->args->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    MacroUsageSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct TimeScaleDirectiveSyntax : public DirectiveSyntax {
+    Token timeUnit;
+    Token slash;
+    Token timePrecision;
+
+    TimeScaleDirectiveSyntax(Token directive, Token timeUnit, Token slash, Token timePrecision) :
+        DirectiveSyntax(SyntaxKind::TimeScaleDirective, directive), timeUnit(timeUnit), slash(slash), timePrecision(timePrecision) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    TimeScaleDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
+    Token netType;
+
+    DefaultNetTypeDirectiveSyntax(Token directive, Token netType) :
+        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    DefaultNetTypeDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UnconnectedDriveDirectiveSyntax : public DirectiveSyntax {
+    Token strength;
+
+    UnconnectedDriveDirectiveSyntax(Token directive, Token strength) :
+        DirectiveSyntax(SyntaxKind::UnconnectedDriveDirective, directive), strength(strength) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UnconnectedDriveDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct LineDirectiveSyntax : public DirectiveSyntax {
+    Token lineNumber;
+    Token fileName;
+    Token level;
+
+    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level) :
+        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    LineDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct UndefDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+
+    UndefDirectiveSyntax(Token directive, Token name) :
+        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    UndefDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
+    Token versionSpecifier;
+
+    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier) :
+        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    BeginKeywordsDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PragmaExpressionSyntax : public SyntaxNode {
+
+    PragmaExpressionSyntax(SyntaxKind kind) :
+        SyntaxNode(kind) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+};
+
+struct SimplePragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token value;
+
+    SimplePragmaExpressionSyntax(Token value) :
+        PragmaExpressionSyntax(SyntaxKind::SimplePragmaExpression), value(value) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    SimplePragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NameValuePragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token name;
+    Token equals;
+    not_null<PragmaExpressionSyntax*> value;
+
+    NameValuePragmaExpressionSyntax(Token name, Token equals, PragmaExpressionSyntax& value) :
+        PragmaExpressionSyntax(SyntaxKind::NameValuePragmaExpression), name(name), equals(equals), value(&value) {
+        this->value->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NameValuePragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct NumberPragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token size;
+    Token base;
+    Token value;
+
+    NumberPragmaExpressionSyntax(Token size, Token base, Token value) :
+        PragmaExpressionSyntax(SyntaxKind::NumberPragmaExpression), size(size), base(base), value(value) {
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    NumberPragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct ParenPragmaExpressionSyntax : public PragmaExpressionSyntax {
+    Token openParen;
+    SeparatedSyntaxList<PragmaExpressionSyntax> values;
+    Token closeParen;
+
+    ParenPragmaExpressionSyntax(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen) :
+        PragmaExpressionSyntax(SyntaxKind::ParenPragmaExpression), openParen(openParen), values(values), closeParen(closeParen) {
+        this->values.parent = this;
+        for (auto child : this->values)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    ParenPragmaExpressionSyntax* clone(BumpAllocator& alloc) const;
+};
+
+struct PragmaDirectiveSyntax : public DirectiveSyntax {
+    Token name;
+    SeparatedSyntaxList<PragmaExpressionSyntax> args;
+
+    PragmaDirectiveSyntax(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args) :
+        DirectiveSyntax(SyntaxKind::PragmaDirective, directive), name(name), args(args) {
+        this->args.parent = this;
+        for (auto child : this->args)
+            child->parent = this;
+    }
+
+    static bool isKind(SyntaxKind kind);
+
+    TokenOrSyntax getChild(size_t index);
+    ConstTokenOrSyntax getChild(size_t index) const;
+    void setChild(size_t index, TokenOrSyntax child);
+
+    PragmaDirectiveSyntax* clone(BumpAllocator& alloc) const;
+};
+
+class SyntaxFactory {
+public:
+    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}
+
+    ActionBlockSyntax& actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause);
+    AnsiPortListSyntax& ansiPortList(Token openParen, const SeparatedSyntaxList<MemberSyntax>& ports, Token closeParen);
+    ArgumentListSyntax& argumentList(Token openParen, const SeparatedSyntaxList<ArgumentSyntax>& parameters, Token closeParen);
+    ArrayOrRandomizeMethodExpressionSyntax& arrayOrRandomizeMethodExpression(ExpressionSyntax& method, Token with, ParenExpressionListSyntax* args, ConstraintBlockSyntax* constraints);
+    AssertionItemPortListSyntax& assertionItemPortList(Token openParen, const SeparatedSyntaxList<AssertionItemPortSyntax>& ports, Token closeParen);
+    AssertionItemPortSyntax& assertionItemPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token local, Token direction, DataTypeSyntax& type, DeclaratorSyntax& declarator);
+    AssignmentPatternExpressionSyntax& assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern);
+    AssignmentPatternItemSyntax& assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr);
+    AttributeInstanceSyntax& attributeInstance(Token openParen, const SeparatedSyntaxList<AttributeSpecSyntax>& specs, Token closeParen);
+    AttributeSpecSyntax& attributeSpec(Token name, EqualsValueClauseSyntax* value);
+    BadExpressionSyntax& badExpression(ExpressionSyntax& expr);
+    BeginKeywordsDirectiveSyntax& beginKeywordsDirective(Token directive, Token versionSpecifier);
+    BinaryBlockEventExpressionSyntax& binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right);
+    BinaryEventExpressionSyntax& binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right);
+    BinaryExpressionSyntax& binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& right);
+    BitSelectSyntax& bitSelect(ExpressionSyntax& expr);
+    BlockCoverageEventSyntax& blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen);
+    BlockStatementSyntax& blockStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token begin, NamedBlockClauseSyntax* blockName, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
+    CaseGenerateSyntax& caseGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, const SyntaxList<CaseItemSyntax>& items, Token endCase);
+    CaseStatementSyntax& caseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, const SyntaxList<CaseItemSyntax>& items, Token endcase);
+    CastExpressionSyntax& castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right);
+    ChargeStrengthSyntax& chargeStrength(Token openParen, Token strength, Token closeParen);
+    ClassDeclarationSyntax& classDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, const SyntaxList<MemberSyntax>& items, Token endClass, NamedBlockClauseSyntax* endBlockName);
+    ClassMethodDeclarationSyntax& classMethodDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionDeclarationSyntax& declaration);
+    ClassMethodPrototypeSyntax& classMethodPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, FunctionPrototypeSyntax& prototype, Token semi);
+    ClassNameSyntax& className(Token identifier, ParameterValueAssignmentSyntax& parameters);
+    ClassPropertyDeclarationSyntax& classPropertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, MemberSyntax& declaration);
+    ClassScopeSyntax& classScope(NameSyntax& left, Token separator);
+    ClockingDeclarationSyntax& clockingDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, const SyntaxList<ClockingItemSyntax>& items, Token endClocking, NamedBlockClauseSyntax* endBlockName);
+    ClockingDirectionSyntax& clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout);
+    ClockingItemSyntax& clockingItem(Token defaultKeyword, ClockingDirectionSyntax* direction, const SeparatedSyntaxList<AttributeSpecSyntax>& assignments, Token semi, MemberSyntax* declaration);
+    ClockingSkewSyntax& clockingSkew(Token edge, Token hash, ExpressionSyntax* value);
+    ColonExpressionClauseSyntax& colonExpressionClause(Token colon, ExpressionSyntax& expr);
+    CompilationUnitSyntax& compilationUnit(const SyntaxList<MemberSyntax>& members, Token endOfFile);
+    ConcatenationExpressionSyntax& concatenationExpression(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeBrace);
+    ConcurrentAssertionMemberSyntax& concurrentAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ConcurrentAssertionStatementSyntax& statement);
+    ConcurrentAssertionStatementSyntax& concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action);
+    ConditionalBranchDirectiveSyntax& conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, const TokenList& disabledTokens);
+    ConditionalConstraintSyntax& conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause);
+    ConditionalExpressionSyntax& conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right);
+    ConditionalPatternSyntax& conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
+    ConditionalPredicateSyntax& conditionalPredicate(const SeparatedSyntaxList<ConditionalPatternSyntax>& conditions);
+    ConditionalStatementSyntax& conditionalStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause);
+    ConstraintBlockSyntax& constraintBlock(Token openBrace, const SyntaxList<ConstraintItemSyntax>& items, Token closeBrace);
+    ConstraintDeclarationSyntax& constraintDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block);
+    ConstraintPrototypeSyntax& constraintPrototype(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token keyword, Token name, Token semi);
+    ContinuousAssignSyntax& continuousAssign(const SyntaxList<AttributeInstanceSyntax>& attributes, Token assign, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<ExpressionSyntax>& assignments, Token semi);
+    CoverageBinsSyntax& coverageBins(const SyntaxList<AttributeInstanceSyntax>& attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi);
+    CoverageOptionSyntax& coverageOption(const SyntaxList<AttributeInstanceSyntax>& attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi);
+    CovergroupDeclarationSyntax& covergroupDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, const SyntaxList<MemberSyntax>& members, Token endgroup, NamedBlockClauseSyntax* endBlockName);
+    CoverpointSyntax& coverpoint(const SyntaxList<AttributeInstanceSyntax>& attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, const SyntaxList<MemberSyntax>& members, Token closeBrace, Token emptySemi);
+    DPIImportExportSyntax& dPIImportExport(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token stringLiteral, Token property, Token c_identifier, Token equals, FunctionPrototypeSyntax& method, Token semi);
+    DataDeclarationSyntax& dataDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& modifiers, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    DeclaratorSyntax& declarator(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, EqualsValueClauseSyntax* initializer);
+    DefParamAssignmentSyntax& defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax* setter);
+    DefParamSyntax& defParam(const SyntaxList<AttributeInstanceSyntax>& attributes, Token defparam, const SeparatedSyntaxList<DefParamAssignmentSyntax>& assignments, Token semi);
+    DefaultCaseItemSyntax& defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause);
+    DefaultCoverageBinInitializerSyntax& defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword);
+    DefaultNetTypeDirectiveSyntax& defaultNetTypeDirective(Token directive, Token netType);
+    DeferredAssertionSyntax& deferredAssertion(Token hash, Token zero, Token finalKeyword);
+    DefineDirectiveSyntax& defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, const TokenList& body);
+    Delay3Syntax& delay3(Token hash, Token openParen, ExpressionSyntax& delay1, Token comma1, ExpressionSyntax* delay2, Token comma2, ExpressionSyntax* delay3, Token closeParen);
+    DelaySyntax& delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue);
+    DisableConstraintSyntax& disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi);
+    DisableForkStatementSyntax& disableForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, Token fork, Token semi);
+    DisableIffSyntax& disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    DisableStatementSyntax& disableStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token disable, NameSyntax& name, Token semi);
+    DistConstraintListSyntax& distConstraintList(Token dist, Token openBrace, const SeparatedSyntaxList<DistItemSyntax>& items, Token closeBrace);
+    DistItemSyntax& distItem(ExpressionSyntax& range, DistWeightSyntax* weight);
+    DistWeightSyntax& distWeight(Token op, ExpressionSyntax& expr);
+    DividerClauseSyntax& dividerClause(Token divide, Token value);
+    DoWhileStatementSyntax& doWhileStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
+    DotMemberClauseSyntax& dotMemberClause(Token dot, Token member);
+    DriveStrengthSyntax& driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen);
+    ElementSelectExpressionSyntax& elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select);
+    ElementSelectSyntax& elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket);
+    ElseClauseSyntax& elseClause(Token elseKeyword, SyntaxNode& clause);
+    ElseConstraintClauseSyntax& elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints);
+    EmptyArgumentSyntax& emptyArgument(Token placeholder);
+    EmptyIdentifierNameSyntax& emptyIdentifierName(Token placeholder);
+    EmptyMemberSyntax& emptyMember(const SyntaxList<AttributeInstanceSyntax>& attributes, const TokenList& qualifiers, Token semi);
+    EmptyQueueExpressionSyntax& emptyQueueExpression(Token openBrace, Token closeBrace);
+    EmptyStatementSyntax& emptyStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token semicolon);
+    EnumTypeSyntax& enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, const SeparatedSyntaxList<DeclaratorSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    EqualsTypeClauseSyntax& equalsTypeClause(Token equals, DataTypeSyntax& type);
+    EqualsValueClauseSyntax& equalsValueClause(Token equals, ExpressionSyntax& expr);
+    EventControlSyntax& eventControl(Token at, NameSyntax& eventName);
+    EventControlWithExpressionSyntax& eventControlWithExpression(Token at, EventExpressionSyntax& expr);
+    EventTriggerStatementSyntax& eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name);
+    ExplicitAnsiPortSyntax& explicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    ExplicitNonAnsiPortSyntax& explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen);
+    ExpressionConstraintSyntax& expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi);
+    ExpressionCoverageBinInitializerSyntax& expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause);
+    ExpressionOrDistSyntax& expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution);
+    ExpressionPatternSyntax& expressionPattern(ExpressionSyntax& expr);
+    ExpressionStatementSyntax& expressionStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& expr, Token semi);
+    ExtendsClauseSyntax& extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments);
+    ExternModuleSyntax& externModule(Token externKeyword, ModuleHeaderSyntax& header);
+    ForLoopStatementSyntax& forLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token forKeyword, Token openParen, const SeparatedSyntaxList<SyntaxNode>& initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, const SeparatedSyntaxList<ExpressionSyntax>& steps, Token closeParen, StatementSyntax& statement);
+    ForVariableDeclarationSyntax& forVariableDeclaration(Token varKeyword, DataTypeSyntax* type, DeclaratorSyntax& declarator);
+    ForeachLoopListSyntax& foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, const SeparatedSyntaxList<NameSyntax>& loopVariables, Token closeBracket, Token closeParen);
+    ForeachLoopStatementSyntax& foreachLoopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement);
+    ForeverStatementSyntax& foreverStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token foreverKeyword, StatementSyntax& statement);
+    ForwardInterfaceClassTypedefDeclarationSyntax& forwardInterfaceClassTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi);
+    ForwardTypedefDeclarationSyntax& forwardTypedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, Token keyword, Token name, Token semi);
+    FunctionDeclarationSyntax& functionDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, FunctionPrototypeSyntax& prototype, Token semi, const SyntaxList<SyntaxNode>& items, Token end, NamedBlockClauseSyntax* endBlockName);
+    FunctionPortListSyntax& functionPortList(Token openParen, const SeparatedSyntaxList<FunctionPortSyntax>& ports, Token closeParen);
+    FunctionPortSyntax& functionPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, DeclaratorSyntax& declarator);
+    FunctionPrototypeSyntax& functionPrototype(Token keyword, Token lifetime, DataTypeSyntax& returnType, NameSyntax& name, FunctionPortListSyntax* portList);
+    GateInstanceNameSyntax& gateInstanceName(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    GateInstanceSyntax& gateInstance(GateInstanceNameSyntax* decl, Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& connections, Token closeParen);
+    GateInstantiationSyntax& gateInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token gateType, DriveStrengthSyntax* strength, TimingControlSyntax* delay, const SeparatedSyntaxList<GateInstanceSyntax>& instances, Token semi);
+    GenerateBlockSyntax& generateBlock(const SyntaxList<AttributeInstanceSyntax>& attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, const SyntaxList<MemberSyntax>& members, Token end, NamedBlockClauseSyntax* endName);
+    GenerateRegionSyntax& generateRegion(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SyntaxList<MemberSyntax>& members, Token endgenerate);
+    GenvarDeclarationSyntax& genvarDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<IdentifierNameSyntax>& identifiers, Token semi);
+    HierarchicalInstanceSyntax& hierarchicalInstance(Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token openParen, const SeparatedSyntaxList<PortConnectionSyntax>& connections, Token closeParen);
+    HierarchyInstantiationSyntax& hierarchyInstantiation(const SyntaxList<AttributeInstanceSyntax>& attributes, Token type, ParameterValueAssignmentSyntax* parameters, const SeparatedSyntaxList<HierarchicalInstanceSyntax>& instances, Token semi);
+    IdentifierNameSyntax& identifierName(Token identifier);
+    IdentifierSelectNameSyntax& identifierSelectName(Token identifier, const SyntaxList<ElementSelectSyntax>& selectors);
+    IfGenerateSyntax& ifGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause);
+    IffClauseSyntax& iffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    ImmediateAssertionMemberSyntax& immediateAssertionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, ImmediateAssertionStatementSyntax& statement);
+    ImmediateAssertionStatementSyntax& immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action);
+    ImplementsClauseSyntax& implementsClause(Token keyword, const SeparatedSyntaxList<NameSyntax>& interfaces);
+    ImplicationConstraintSyntax& implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints);
+    ImplicitAnsiPortSyntax& implicitAnsiPort(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, DeclaratorSyntax& declarator);
+    ImplicitEventControlSyntax& implicitEventControl(Token at, Token openParen, Token star, Token closeParen);
+    ImplicitNonAnsiPortSyntax& implicitNonAnsiPort(PortExpressionSyntax* expr);
+    ImplicitTypeSyntax& implicitType(Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    IncludeDirectiveSyntax& includeDirective(Token directive, Token fileName);
+    InsideExpressionSyntax& insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges);
+    IntegerTypeSyntax& integerType(SyntaxKind kind, Token keyword, Token signing, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    IntegerVectorExpressionSyntax& integerVectorExpression(Token size, Token base, Token value);
+    InterconnectPortHeaderSyntax& interconnectPortHeader(Token direction, Token interconnect, ImplicitTypeSyntax& type);
+    InterfacePortHeaderSyntax& interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport);
+    InvocationExpressionSyntax& invocationExpression(ExpressionSyntax& left, const SyntaxList<AttributeInstanceSyntax>& attributes, ArgumentListSyntax* arguments);
+    JumpStatementSyntax& jumpStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token breakOrContinue, Token semi);
+    KeywordNameSyntax& keywordName(SyntaxKind kind, Token keyword);
+    KeywordTypeSyntax& keywordType(SyntaxKind kind, Token keyword);
+    LetDeclarationSyntax& letDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi);
+    LineDirectiveSyntax& lineDirective(Token directive, Token lineNumber, Token fileName, Token level);
+    LiteralExpressionSyntax& literalExpression(SyntaxKind kind, Token literal);
+    LoopConstraintSyntax& loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints);
+    LoopGenerateSyntax& loopGenerate(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block);
+    LoopStatementSyntax& loopStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
+    MacroActualArgumentListSyntax& macroActualArgumentList(Token openParen, const SeparatedSyntaxList<MacroActualArgumentSyntax>& args, Token closeParen);
+    MacroActualArgumentSyntax& macroActualArgument(const TokenList& tokens);
+    MacroArgumentDefaultSyntax& macroArgumentDefault(Token equals, const TokenList& tokens);
+    MacroFormalArgumentListSyntax& macroFormalArgumentList(Token openParen, const SeparatedSyntaxList<MacroFormalArgumentSyntax>& args, Token closeParen);
+    MacroFormalArgumentSyntax& macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue);
+    MacroUsageSyntax& macroUsage(Token directive, MacroActualArgumentListSyntax* args);
+    MatchesClauseSyntax& matchesClause(Token matchesKeyword, PatternSyntax& pattern);
+    MemberAccessExpressionSyntax& memberAccessExpression(ExpressionSyntax& left, Token dot, Token name);
+    MinTypMaxExpressionSyntax& minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max);
+    ModportClockingPortSyntax& modportClockingPort(const SyntaxList<AttributeInstanceSyntax>& attributes, Token clocking, Token name);
+    ModportDeclarationSyntax& modportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<ModportItemSyntax>& items, Token semi);
+    ModportExplicitPortSyntax& modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    ModportItemSyntax& modportItem(Token name, AnsiPortListSyntax& ports);
+    ModportNamedPortSyntax& modportNamedPort(Token name);
+    ModportSimplePortListSyntax& modportSimplePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token direction, const SeparatedSyntaxList<ModportPortSyntax>& ports);
+    ModportSubroutinePortListSyntax& modportSubroutinePortList(const SyntaxList<AttributeInstanceSyntax>& attributes, Token importExport, const SeparatedSyntaxList<ModportPortSyntax>& ports);
+    ModportSubroutinePortSyntax& modportSubroutinePort(FunctionPrototypeSyntax& prototype);
+    ModuleDeclarationSyntax& moduleDeclaration(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, ModuleHeaderSyntax& header, const SyntaxList<MemberSyntax>& members, Token endmodule, NamedBlockClauseSyntax* blockName);
+    ModuleHeaderSyntax& moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, const SyntaxList<PackageImportDeclarationSyntax>& imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi);
+    MultipleConcatenationExpressionSyntax& multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace);
+    NameValuePragmaExpressionSyntax& nameValuePragmaExpression(Token name, Token equals, PragmaExpressionSyntax& value);
+    NamedArgumentSyntax& namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    NamedBlockClauseSyntax& namedBlockClause(Token colon, Token name);
+    NamedLabelSyntax& namedLabel(Token name, Token colon);
+    NamedPortConnectionSyntax& namedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
+    NamedStructurePatternMemberSyntax& namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern);
+    NamedTypeSyntax& namedType(NameSyntax& name);
+    NetDeclarationSyntax& netDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, TimingControlSyntax* delay, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    NetPortHeaderSyntax& netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType);
+    NetTypeDeclarationSyntax& netTypeDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, DataTypeSyntax& type, Token name, WithFunctionClauseSyntax* withFunction, Token semi);
+    NewArrayExpressionSyntax& newArrayExpression(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer);
+    NewClassExpressionSyntax& newClassExpression(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments);
+    NewExpressionSyntax& newExpression(Token newKeyword, ExpressionSyntax& expr);
+    NonAnsiPortListSyntax& nonAnsiPortList(Token openParen, const SeparatedSyntaxList<NonAnsiPortSyntax>& ports, Token closeParen);
+    NumberPragmaExpressionSyntax& numberPragmaExpression(Token size, Token base, Token value);
+    OpenRangeExpressionSyntax& openRangeExpression(Token openBracket, ExpressionSyntax& left, Token colon, ExpressionSyntax& right, Token closeBracket);
+    OpenRangeListSyntax& openRangeList(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& valueRanges, Token closeBrace);
+    OrderedArgumentSyntax& orderedArgument(ExpressionSyntax& expr);
+    OrderedPortConnectionSyntax& orderedPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax* expr);
+    OrderedStructurePatternMemberSyntax& orderedStructurePatternMember(PatternSyntax& pattern);
+    PackageImportDeclarationSyntax& packageImportDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, const SeparatedSyntaxList<PackageImportItemSyntax>& items, Token semi);
+    PackageImportItemSyntax& packageImportItem(Token package, Token doubleColon, Token item);
+    ParameterDeclarationStatementSyntax& parameterDeclarationStatement(const SyntaxList<AttributeInstanceSyntax>& attributes, ParameterDeclarationBaseSyntax& parameter, Token semi);
+    ParameterDeclarationSyntax& parameterDeclaration(Token keyword, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators);
+    ParameterPortListSyntax& parameterPortList(Token hash, Token openParen, const SeparatedSyntaxList<ParameterDeclarationBaseSyntax>& declarations, Token closeParen);
+    ParameterValueAssignmentSyntax& parameterValueAssignment(Token hash, ArgumentListSyntax& assignments);
+    ParenExpressionListSyntax& parenExpressionList(Token openParen, const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token closeParen);
+    ParenPragmaExpressionSyntax& parenPragmaExpression(Token openParen, const SeparatedSyntaxList<PragmaExpressionSyntax>& values, Token closeParen);
+    ParenthesizedEventExpressionSyntax& parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen);
+    ParenthesizedExpressionSyntax& parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen);
+    PatternCaseItemSyntax& patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement);
+    PortConcatenationSyntax& portConcatenation(Token openBrace, const SeparatedSyntaxList<PortReferenceSyntax>& references, Token closeBrace);
+    PortDeclarationSyntax& portDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, PortHeaderSyntax& header, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    PortReferenceSyntax& portReference(Token name, ElementSelectSyntax* select);
+    PostfixUnaryExpressionSyntax& postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, const SyntaxList<AttributeInstanceSyntax>& attributes, Token operatorToken);
+    PragmaDirectiveSyntax& pragmaDirective(Token directive, Token name, const SeparatedSyntaxList<PragmaExpressionSyntax>& args);
+    PrefixUnaryExpressionSyntax& prefixUnaryExpression(SyntaxKind kind, Token operatorToken, const SyntaxList<AttributeInstanceSyntax>& attributes, ExpressionSyntax& operand);
+    PrimaryBlockEventExpressionSyntax& primaryBlockEventExpression(Token keyword, NameSyntax& name);
+    ProceduralAssignStatementSyntax& proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi);
+    ProceduralBlockSyntax& proceduralBlock(SyntaxKind kind, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, StatementSyntax& statement);
+    ProceduralDeassignStatementSyntax& proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, ExpressionSyntax& variable, Token semi);
+    PropertyDeclarationSyntax& propertyDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
+    PropertySpecSyntax& propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr);
+    QueueDimensionSpecifierSyntax& queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause);
+    RandCaseItemSyntax& randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement);
+    RandCaseStatementSyntax& randCaseStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token randCase, const SyntaxList<RandCaseItemSyntax>& items, Token endCase);
+    RangeCoverageBinInitializerSyntax& rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause);
+    RangeDimensionSpecifierSyntax& rangeDimensionSpecifier(SelectorSyntax& selector);
+    RangeSelectSyntax& rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right);
+    RepeatedEventControlSyntax& repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl);
+    ReplicatedAssignmentPatternSyntax& replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token innerCloseBrace, Token closeBrace);
+    ReturnStatementSyntax& returnStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi);
+    ScopedNameSyntax& scopedName(NameSyntax& left, Token separator, NameSyntax& right);
+    SequenceDeclarationSyntax& sequenceDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, const SyntaxList<MemberSyntax>& assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
+    ShortcutCycleDelayRangeSyntax& shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket);
+    SignalEventExpressionSyntax& signalEventExpression(Token edge, ExpressionSyntax& expr);
+    SignedCastExpressionSyntax& signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner);
+    SimpleAssignmentPatternSyntax& simpleAssignmentPattern(Token openBrace, const SeparatedSyntaxList<ExpressionSyntax>& items, Token closeBrace);
+    SimpleDirectiveSyntax& simpleDirective(SyntaxKind kind, Token directive);
+    SimplePragmaExpressionSyntax& simplePragmaExpression(Token value);
+    SolveBeforeConstraintSyntax& solveBeforeConstraint(Token solve, const SeparatedSyntaxList<ExpressionSyntax>& beforeExpr, Token before, const SeparatedSyntaxList<ExpressionSyntax>& afterExpr, Token semi);
+    StandardCaseItemSyntax& standardCaseItem(const SeparatedSyntaxList<ExpressionSyntax>& expressions, Token colon, SyntaxNode& clause);
+    StreamExpressionSyntax& streamExpression(ExpressionSyntax& expression, StreamExpressionWithRangeSyntax* withRange);
+    StreamExpressionWithRangeSyntax& streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range);
+    StreamingConcatenationExpressionSyntax& streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, const SeparatedSyntaxList<StreamExpressionSyntax>& expressions, Token innerCloseBrace, Token closeBrace);
+    StructUnionMemberSyntax& structUnionMember(const SyntaxList<AttributeInstanceSyntax>& attributes, Token randomQualifier, DataTypeSyntax& type, const SeparatedSyntaxList<DeclaratorSyntax>& declarators, Token semi);
+    StructUnionTypeSyntax& structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, const SyntaxList<StructUnionMemberSyntax>& members, Token closeBrace, const SyntaxList<VariableDimensionSyntax>& dimensions);
+    StructurePatternSyntax& structurePattern(Token openBrace, const SeparatedSyntaxList<StructurePatternMemberSyntax>& members, Token closeBrace);
+    StructuredAssignmentPatternSyntax& structuredAssignmentPattern(Token openBrace, const SeparatedSyntaxList<AssignmentPatternItemSyntax>& items, Token closeBrace);
+    SystemNameSyntax& systemName(Token systemIdentifier);
+    TaggedPatternSyntax& taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern);
+    TaggedUnionExpressionSyntax& taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr);
+    TimeScaleDirectiveSyntax& timeScaleDirective(Token directive, Token timeUnit, Token slash, Token timePrecision);
+    TimeUnitsDeclarationSyntax& timeUnitsDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi);
+    TimingControlExpressionConcatenationSyntax& timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right);
+    TimingControlExpressionSyntax& timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr);
+    TimingControlStatementSyntax& timingControlStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, TimingControlSyntax& timingControl, StatementSyntax& statement);
+    TransListCoverageBinInitializerSyntax& transListCoverageBinInitializer(const SeparatedSyntaxList<TransSetSyntax>& sets, WithClauseSyntax* withClause);
+    TransRangeSyntax& transRange(const SeparatedSyntaxList<ExpressionSyntax>& items, TransRepeatRangeSyntax* repeat);
+    TransRepeatRangeSyntax& transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket);
+    TransSetSyntax& transSet(Token openParen, const SeparatedSyntaxList<TransRangeSyntax>& ranges, Token closeParen);
+    TypeAssignmentSyntax& typeAssignment(Token name, EqualsTypeClauseSyntax* assignment);
+    TypeParameterDeclarationSyntax& typeParameterDeclaration(Token keyword, Token typeKeyword, const SeparatedSyntaxList<TypeAssignmentSyntax>& declarators);
+    TypeReferenceSyntax& typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    TypedefDeclarationSyntax& typedefDeclaration(const SyntaxList<AttributeInstanceSyntax>& attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, const SyntaxList<VariableDimensionSyntax>& dimensions, Token semi);
+    UnconditionalBranchDirectiveSyntax& unconditionalBranchDirective(SyntaxKind kind, Token directive, const TokenList& disabledTokens);
+    UnconnectedDriveDirectiveSyntax& unconnectedDriveDirective(Token directive, Token strength);
+    UndefDirectiveSyntax& undefDirective(Token directive, Token name);
+    UniquenessConstraintSyntax& uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi);
+    VariableDimensionSyntax& variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket);
+    VariablePatternSyntax& variablePattern(Token dot, Token variableName);
+    VariablePortHeaderSyntax& variablePortHeader(Token direction, Token varKeyword, DataTypeSyntax& dataType);
+    VirtualInterfaceTypeSyntax& virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport);
+    VoidCastedCallStatementSyntax& voidCastedCallStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token voidKeyword, Token apostrophe, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
+    WaitForkStatementSyntax& waitForkStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token fork, Token semi);
+    WaitOrderStatementSyntax& waitOrderStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait_order, Token openParen, const SeparatedSyntaxList<NameSyntax>& names, Token closeParen, ActionBlockSyntax& action);
+    WaitStatementSyntax& waitStatement(NamedLabelSyntax* label, const SyntaxList<AttributeInstanceSyntax>& attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
+    WildcardDimensionSpecifierSyntax& wildcardDimensionSpecifier(Token star);
+    WildcardPatternSyntax& wildcardPattern(Token dotStar);
+    WildcardPortConnectionSyntax& wildcardPortConnection(const SyntaxList<AttributeInstanceSyntax>& attributes, Token dotStar);
+    WildcardPortListSyntax& wildcardPortList(Token openParen, Token dotStar, Token closeParen);
+    WithClauseSyntax& withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen);
+    WithFunctionClauseSyntax& withFunctionClause(Token with, NameSyntax& name);
+    WithFunctionSampleSyntax& withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList);
+
+private:
+    BumpAllocator& alloc;
+};
+
+namespace detail {
+
+template<typename TNode, typename TVisitor, typename... Args>
+decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {
+    static constexpr bool isConst = std::is_const_v<TNode>;    switch (node->kind) {
+        case SyntaxKind::Unknown: return visitor.visitInvalid(*node, std::forward<Args>(args)...);
+        case SyntaxKind::SyntaxList:
+        case SyntaxKind::TokenList:
+        case SyntaxKind::SeparatedList:
+            return visitor.visit(*static_cast<std::conditional_t<isConst, const SyntaxListBase*, SyntaxListBase*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ActionBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ActionBlockSyntax*, ActionBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AddAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AddExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysCombBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysFFBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysLatchBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AndAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AndSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiPortListSyntax*, AnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArgumentListSyntax*, ArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArithmeticShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayAndMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayOrMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayOrRandomizeMethodExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArrayOrRandomizeMethodExpressionSyntax*, ArrayOrRandomizeMethodExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayUniqueMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ArrayXorMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AscendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertionItemPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortSyntax*, AssertionItemPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssertionItemPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortListSyntax*, AssertionItemPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentPatternExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternExpressionSyntax*, AssignmentPatternExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssignmentPatternItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternItemSyntax*, AssignmentPatternItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AssumePropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AttributeInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeInstanceSyntax*, AttributeInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::AttributeSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeSpecSyntax*, AttributeSpecSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BadExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BadExpressionSyntax*, BadExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BeginKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BeginKeywordsDirectiveSyntax*, BeginKeywordsDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBlockEventExpressionSyntax*, BinaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryEventExpressionSyntax*, BinaryEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BinaryXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BitSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const BitSelectSyntax*, BitSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BlockCoverageEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockCoverageEventSyntax*, BlockCoverageEventSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::BlockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ByteType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CHandleType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseGenerateSyntax*, CaseGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseStatementSyntax*, CaseStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CastExpressionSyntax*, CastExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ChargeStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const ChargeStrengthSyntax*, ChargeStrengthSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassDeclarationSyntax*, ClassDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassMethodDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodDeclarationSyntax*, ClassMethodDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassMethodPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodPrototypeSyntax*, ClassMethodPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassNameSyntax*, ClassNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassPropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassPropertyDeclarationSyntax*, ClassPropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClassScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassScopeSyntax*, ClassScopeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDeclarationSyntax*, ClockingDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingDirection: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDirectionSyntax*, ClockingDirectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingItemSyntax*, ClockingItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ClockingSkew: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSkewSyntax*, ClockingSkewSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ColonExpressionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ColonExpressionClauseSyntax*, ColonExpressionClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CompilationUnit: return visitor.visit(*static_cast<std::conditional_t<isConst, const CompilationUnitSyntax*, CompilationUnitSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcatenationExpressionSyntax*, ConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConcurrentAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionMemberSyntax*, ConcurrentAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalConstraintSyntax*, ConditionalConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalExpressionSyntax*, ConditionalExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPatternSyntax*, ConditionalPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalPredicate: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPredicateSyntax*, ConditionalPredicateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConditionalStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalStatementSyntax*, ConditionalStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintBlockSyntax*, ConstraintBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintDeclarationSyntax*, ConstraintDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstraintPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintPrototypeSyntax*, ConstraintPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ConstructorName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ContinuousAssign: return visitor.visit(*static_cast<std::conditional_t<isConst, const ContinuousAssignSyntax*, ContinuousAssignSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverageBins: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsSyntax*, CoverageBinsSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CoverageOption: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageOptionSyntax*, CoverageOptionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CovergroupDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CovergroupDeclarationSyntax*, CovergroupDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Coverpoint: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverpointSyntax*, CoverpointSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::CycleDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DPIImportExport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIImportExportSyntax*, DPIImportExportSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DataDeclarationSyntax*, DataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Declarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeclaratorSyntax*, DeclaratorSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefParam: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamSyntax*, DefParamSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamAssignmentSyntax*, DefParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCaseItemSyntax*, DefaultCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCoverageBinInitializerSyntax*, DefaultCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultNetTypeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultNetTypeDirectiveSyntax*, DefaultNetTypeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefaultPatternKeyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DeferredAssertion: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeferredAssertionSyntax*, DeferredAssertionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefineDirectiveSyntax*, DefineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Delay3: return visitor.visit(*static_cast<std::conditional_t<isConst, const Delay3Syntax*, Delay3Syntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DelayControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DescendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableConstraintSyntax*, DisableConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableForkStatementSyntax*, DisableForkStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableIff: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableIffSyntax*, DisableIffSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DisableStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableStatementSyntax*, DisableStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistConstraintList: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistConstraintListSyntax*, DistConstraintListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistItemSyntax*, DistItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DistWeight: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistWeightSyntax*, DistWeightSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DivideAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DivideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DividerClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DividerClauseSyntax*, DividerClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DoWhileStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DoWhileStatementSyntax*, DoWhileStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DotMemberClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DotMemberClauseSyntax*, DotMemberClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::DriveStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const DriveStrengthSyntax*, DriveStrengthSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElementSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectSyntax*, ElementSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElementSelectExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectExpressionSyntax*, ElementSelectExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElsIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseClauseSyntax*, ElseClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseConstraintClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseConstraintClauseSyntax*, ElseConstraintClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ElseDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyArgumentSyntax*, EmptyArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyIdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyIdentifierNameSyntax*, EmptyIdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyMemberSyntax*, EmptyMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyQueueExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyQueueExpressionSyntax*, EmptyQueueExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EmptyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyStatementSyntax*, EmptyStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndCellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EndKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EnumType: return visitor.visit(*static_cast<std::conditional_t<isConst, const EnumTypeSyntax*, EnumTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualsTypeClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsTypeClauseSyntax*, EqualsTypeClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EqualsValueClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsValueClauseSyntax*, EqualsValueClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlSyntax*, EventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventControlWithExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlWithExpressionSyntax*, EventControlWithExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::EventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpectPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitAnsiPortSyntax*, ExplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitNonAnsiPortSyntax*, ExplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionConstraintSyntax*, ExpressionConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionCoverageBinInitializerSyntax*, ExpressionCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionOrDist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionOrDistSyntax*, ExpressionOrDistSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionPatternSyntax*, ExpressionPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExpressionStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionStatementSyntax*, ExpressionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExtendsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExtendsClauseSyntax*, ExtendsClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ExternModule: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternModuleSyntax*, ExternModuleSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FinalBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForLoopStatementSyntax*, ForLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForVariableDeclarationSyntax*, ForVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeachLoopList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopListSyntax*, ForeachLoopListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeachLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopStatementSyntax*, ForeachLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForeverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeverStatementSyntax*, ForeverStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardInterfaceClassTypedefDeclarationSyntax*, ForwardInterfaceClassTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ForwardTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypedefDeclarationSyntax*, ForwardTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortSyntax*, FunctionPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortListSyntax*, FunctionPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::FunctionPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPrototypeSyntax*, FunctionPrototypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstanceSyntax*, GateInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstanceName: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstanceNameSyntax*, GateInstanceNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GateInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const GateInstantiationSyntax*, GateInstantiationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenerateBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateBlockSyntax*, GenerateBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenerateRegion: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateRegionSyntax*, GenerateRegionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GenvarDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenvarDeclarationSyntax*, GenvarDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GreaterThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::GreaterThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::HierarchicalInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchicalInstanceSyntax*, HierarchicalInstanceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::HierarchyInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchyInstantiationSyntax*, HierarchyInstantiationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierNameSyntax*, IdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IdentifierSelectName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierSelectNameSyntax*, IdentifierSelectNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfGenerateSyntax*, IfGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IfNDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IffClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IffClauseSyntax*, IffClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IffPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssertStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionMemberSyntax*, ImmediateAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateAssumeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImmediateCoverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplementsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplementsClauseSyntax*, ImplementsClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicationConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicationConstraintSyntax*, ImplicationConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitAnsiPortSyntax*, ImplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitEventControlSyntax*, ImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitNonAnsiPortSyntax*, ImplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImplicitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitTypeSyntax*, ImplicitTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ImpliesPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IncludeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const IncludeDirectiveSyntax*, IncludeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InitialBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InsideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InsideExpressionSyntax*, InsideExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntegerVectorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerVectorExpressionSyntax*, IntegerVectorExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterconnectPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterconnectPortHeaderSyntax*, InterconnectPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfaceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfaceHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InterfacePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterfacePortHeaderSyntax*, InterfacePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::IntersectSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::InvocationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvocationExpressionSyntax*, InvocationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::JumpStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const JumpStatementSyntax*, JumpStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LessThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LessThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LetDeclarationSyntax*, LetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const LineDirectiveSyntax*, LineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LocalScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalEquivalenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalImplicationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LogicalShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LongIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopConstraintSyntax*, LoopConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopGenerateSyntax*, LoopGenerateSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::LoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopStatementSyntax*, LoopStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroActualArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentSyntax*, MacroActualArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroActualArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentListSyntax*, MacroActualArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroArgumentDefault: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroArgumentDefaultSyntax*, MacroArgumentDefaultSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroFormalArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentSyntax*, MacroFormalArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroFormalArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentListSyntax*, MacroFormalArgumentListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MacroUsage: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroUsageSyntax*, MacroUsageSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MatchesClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const MatchesClauseSyntax*, MatchesClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MemberAccessExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MemberAccessExpressionSyntax*, MemberAccessExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MinTypMaxExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MinTypMaxExpressionSyntax*, MinTypMaxExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportClockingPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportClockingPortSyntax*, ModportClockingPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportDeclarationSyntax*, ModportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportExplicitPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportExplicitPortSyntax*, ModportExplicitPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportItemSyntax*, ModportItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportNamedPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportNamedPortSyntax*, ModportNamedPortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSimplePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSimplePortListSyntax*, ModportSimplePortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSubroutinePort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortSyntax*, ModportSubroutinePortSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModportSubroutinePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortListSyntax*, ModportSubroutinePortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModuleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ModuleHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultipleConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MultipleConcatenationExpressionSyntax*, MultipleConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultiplyAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::MultiplyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NameValuePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NameValuePragmaExpressionSyntax*, NameValuePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedArgumentSyntax*, NamedArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedBlockClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedBlockClauseSyntax*, NamedBlockClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedLabel: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedLabelSyntax*, NamedLabelSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedPortConnectionSyntax*, NamedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedStructurePatternMemberSyntax*, NamedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NamedType: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedTypeSyntax*, NamedTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetDeclarationSyntax*, NetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetPortHeaderSyntax*, NetPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NetTypeDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetTypeDeclarationSyntax*, NetTypeDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NewArrayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewArrayExpressionSyntax*, NewArrayExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NewClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewClassExpressionSyntax*, NewClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NewExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewExpressionSyntax*, NewExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NoUnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonAnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiPortListSyntax*, NonAnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonblockingAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NonblockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NullLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::NumberPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NumberPragmaExpressionSyntax*, NumberPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OneStepLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OpenRangeExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeExpressionSyntax*, OpenRangeExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OpenRangeList: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeListSyntax*, OpenRangeListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedArgumentSyntax*, OrderedArgumentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedPortConnectionSyntax*, OrderedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OrderedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedStructurePatternMemberSyntax*, OrderedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::OverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageImportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportDeclarationSyntax*, PackageImportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PackageImportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportItemSyntax*, PackageImportItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParallelBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationSyntax*, ParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterDeclarationStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationStatementSyntax*, ParameterDeclarationStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterPortListSyntax*, ParameterPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParameterValueAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterValueAssignmentSyntax*, ParameterValueAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenExpressionList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenExpressionListSyntax*, ParenExpressionListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenPragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenPragmaExpressionSyntax*, ParenPragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenthesizedEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedEventExpressionSyntax*, ParenthesizedEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ParenthesizedExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedExpressionSyntax*, ParenthesizedExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PatternCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PatternCaseItemSyntax*, PatternCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortConcatenationSyntax*, PortConcatenationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortDeclarationSyntax*, PortDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PortReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortReferenceSyntax*, PortReferenceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PostdecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PostincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PowerExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PragmaDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const PragmaDirectiveSyntax*, PragmaDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PrimaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimaryBlockEventExpressionSyntax*, PrimaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralAssignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralDeassignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralForceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProceduralReleaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProgramDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ProgramHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertyDeclarationSyntax*, PropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertySpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertySpecSyntax*, PropertySpecSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::PropertyType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::QueueDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const QueueDimensionSpecifierSyntax*, QueueDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RandCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseItemSyntax*, RandCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RandCaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseStatementSyntax*, RandCaseStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RangeCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeCoverageBinInitializerSyntax*, RangeCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RangeDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeDimensionSpecifierSyntax*, RangeDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealTimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RegType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RepeatedEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const RepeatedEventControlSyntax*, RepeatedEventControlSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ReplicatedAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReplicatedAssignmentPatternSyntax*, ReplicatedAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ResetAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RestrictPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ReturnStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReturnStatementSyntax*, ReturnStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::RootScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SAlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SEventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SNextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SUntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SUntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ScopedName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ScopedNameSyntax*, ScopedNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequenceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceDeclarationSyntax*, SequenceDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequenceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SequentialBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortRealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ShortcutCycleDelayRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const ShortcutCycleDelayRangeSyntax*, ShortcutCycleDelayRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SignalEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignalEventExpressionSyntax*, SignalEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SignedCastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignedCastExpressionSyntax*, SignedCastExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimpleAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleAssignmentPatternSyntax*, SimpleAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimplePragmaExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimplePragmaExpressionSyntax*, SimplePragmaExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SimpleRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SolveBeforeConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const SolveBeforeConstraintSyntax*, SolveBeforeConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StandardCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardCaseItemSyntax*, StandardCaseItemSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionSyntax*, StreamExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamExpressionWithRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionWithRangeSyntax*, StreamExpressionWithRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StreamingConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamingConcatenationExpressionSyntax*, StreamingConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StringLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StringType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructUnionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionMemberSyntax*, StructUnionMemberSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructurePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructurePatternSyntax*, StructurePatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::StructuredAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructuredAssignmentPatternSyntax*, StructuredAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SubtractAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SubtractExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SuperHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SyncAcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SyncRejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::SystemName: return visitor.visit(*static_cast<std::conditional_t<isConst, const SystemNameSyntax*, SystemNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaggedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedPatternSyntax*, TaggedPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaggedUnionExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedUnionExpressionSyntax*, TaggedUnionExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TaskDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ThisHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::ThroughoutSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeScaleDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeScaleDirectiveSyntax*, TimeScaleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimeUnitsDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeUnitsDeclarationSyntax*, TimeUnitsDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionSyntax*, TimingControlExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlExpressionConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionConcatenationSyntax*, TimingControlExpressionConcatenationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TimingControlStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlStatementSyntax*, TimingControlStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransListCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransListCoverageBinInitializerSyntax*, TransListCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRangeSyntax*, TransRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransRepeatRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRepeatRangeSyntax*, TransRepeatRangeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TransSet: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransSetSyntax*, TransSetSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeAssignmentSyntax*, TypeAssignmentSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeParameterDeclarationSyntax*, TypeParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypeReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeReferenceSyntax*, TypeReferenceSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::TypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypedefDeclarationSyntax*, TypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNandExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryBitwiseXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryLogicalNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryMinusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryNotPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPlusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPredecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnaryPreincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnarySequenceEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnbasedUnsizedLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconnectedDriveDirectiveSyntax*, UnconnectedDriveDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UndefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UndefDirectiveSyntax*, UndefDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UndefineAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnionType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UniquenessConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const UniquenessConstraintSyntax*, UniquenessConstraintSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UnitScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::UntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::Untyped: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariableDimension: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDimensionSyntax*, VariableDimensionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariablePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePatternSyntax*, VariablePatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VariablePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePortHeaderSyntax*, VariablePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VirtualInterfaceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VirtualInterfaceTypeSyntax*, VirtualInterfaceTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VoidCastedCallStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const VoidCastedCallStatementSyntax*, VoidCastedCallStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::VoidType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitForkStatementSyntax*, WaitForkStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitOrderStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitOrderStatementSyntax*, WaitOrderStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WaitStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitStatementSyntax*, WaitStatementSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardDimensionSpecifierSyntax*, WildcardDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPatternSyntax*, WildcardPatternSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortConnectionSyntax*, WildcardPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WildcardPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortListSyntax*, WildcardPortListSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithClauseSyntax*, WithClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithFunctionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionClauseSyntax*, WithFunctionClauseSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithFunctionSample: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionSampleSyntax*, WithFunctionSampleSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::WithinSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+        case SyntaxKind::XorAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
+    }
+    THROW_UNREACHABLE;
+}
+
+}
+
+template<typename TVisitor, typename... Args>
+decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) {
+    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
+}
+
+template<typename TVisitor, typename... Args>
+decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) const {
+    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/slang/syntax/SyntaxKind.h ./generated/slang/syntax/SyntaxKind.h
--- ./generated/slang/syntax/SyntaxKind.h	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/slang/syntax/SyntaxKind.h	2020-04-13 10:23:52.710371660 -0700
@@ -0,0 +1,441 @@
+//------------------------------------------------------------------------------
+//! @file SyntaxKind.h
+//! @brief Generated SyntaxKind enum
+//
+// File is under the MIT license; see LICENSE for details
+//------------------------------------------------------------------------------
+#pragma once
+
+namespace slang {
+
+enum class SyntaxKind {
+    Unknown,
+    SyntaxList,
+    TokenList,
+    SeparatedList,
+    AcceptOnPropertyExpression,
+    ActionBlock,
+    AddAssignmentExpression,
+    AddExpression,
+    AlwaysBlock,
+    AlwaysCombBlock,
+    AlwaysFFBlock,
+    AlwaysLatchBlock,
+    AlwaysPropertyExpression,
+    AndAssignmentExpression,
+    AndSequenceExpression,
+    AnsiPortList,
+    ArgumentList,
+    ArithmeticLeftShiftAssignmentExpression,
+    ArithmeticRightShiftAssignmentExpression,
+    ArithmeticShiftLeftExpression,
+    ArithmeticShiftRightExpression,
+    ArrayAndMethod,
+    ArrayOrMethod,
+    ArrayOrRandomizeMethodExpression,
+    ArrayUniqueMethod,
+    ArrayXorMethod,
+    AscendingRangeSelect,
+    AssertPropertyStatement,
+    AssertionItemPort,
+    AssertionItemPortList,
+    AssignmentExpression,
+    AssignmentPatternExpression,
+    AssignmentPatternItem,
+    AssumePropertyStatement,
+    AttributeInstance,
+    AttributeSpec,
+    BadExpression,
+    BeginKeywordsDirective,
+    BinaryAndExpression,
+    BinaryBlockEventExpression,
+    BinaryEventExpression,
+    BinaryOrExpression,
+    BinarySequenceDelayExpression,
+    BinaryXnorExpression,
+    BinaryXorExpression,
+    BitSelect,
+    BitType,
+    BlockCoverageEvent,
+    BlockingEventTriggerStatement,
+    ByteType,
+    CHandleType,
+    CaseEqualityExpression,
+    CaseGenerate,
+    CaseInequalityExpression,
+    CaseStatement,
+    CastExpression,
+    CellDefineDirective,
+    ChargeStrength,
+    ClassDeclaration,
+    ClassMethodDeclaration,
+    ClassMethodPrototype,
+    ClassName,
+    ClassPropertyDeclaration,
+    ClassScope,
+    ClockingDeclaration,
+    ClockingDirection,
+    ClockingItem,
+    ClockingSkew,
+    ColonExpressionClause,
+    CompilationUnit,
+    ConcatenationExpression,
+    ConcurrentAssertionMember,
+    ConditionalConstraint,
+    ConditionalExpression,
+    ConditionalPattern,
+    ConditionalPredicate,
+    ConditionalStatement,
+    ConstraintBlock,
+    ConstraintDeclaration,
+    ConstraintPrototype,
+    ConstructorName,
+    ContinuousAssign,
+    CoverPropertyStatement,
+    CoverSequenceStatement,
+    CoverageBins,
+    CoverageOption,
+    CovergroupDeclaration,
+    Coverpoint,
+    CycleDelay,
+    DPIImportExport,
+    DataDeclaration,
+    Declarator,
+    DefParam,
+    DefParamAssignment,
+    DefaultCaseItem,
+    DefaultCoverageBinInitializer,
+    DefaultNetTypeDirective,
+    DefaultPatternKeyExpression,
+    DeferredAssertion,
+    DefineDirective,
+    Delay3,
+    DelayControl,
+    DescendingRangeSelect,
+    DisableConstraint,
+    DisableForkStatement,
+    DisableIff,
+    DisableStatement,
+    DistConstraintList,
+    DistItem,
+    DistWeight,
+    DivideAssignmentExpression,
+    DivideExpression,
+    DividerClause,
+    DoWhileStatement,
+    DotMemberClause,
+    DriveStrength,
+    ElementSelect,
+    ElementSelectExpression,
+    ElsIfDirective,
+    ElseClause,
+    ElseConstraintClause,
+    ElseDirective,
+    EmptyArgument,
+    EmptyIdentifierName,
+    EmptyMember,
+    EmptyQueueExpression,
+    EmptyStatement,
+    EndCellDefineDirective,
+    EndIfDirective,
+    EndKeywordsDirective,
+    EnumType,
+    EqualityExpression,
+    EqualsTypeClause,
+    EqualsValueClause,
+    EventControl,
+    EventControlWithExpression,
+    EventType,
+    EventuallyPropertyExpression,
+    ExpectPropertyStatement,
+    ExplicitAnsiPort,
+    ExplicitNonAnsiPort,
+    ExpressionConstraint,
+    ExpressionCoverageBinInitializer,
+    ExpressionOrDist,
+    ExpressionPattern,
+    ExpressionStatement,
+    ExtendsClause,
+    ExternModule,
+    FinalBlock,
+    ForLoopStatement,
+    ForVariableDeclaration,
+    ForeachLoopList,
+    ForeachLoopStatement,
+    ForeverStatement,
+    ForwardInterfaceClassTypedefDeclaration,
+    ForwardTypedefDeclaration,
+    FunctionDeclaration,
+    FunctionPort,
+    FunctionPortList,
+    FunctionPrototype,
+    GateInstance,
+    GateInstanceName,
+    GateInstantiation,
+    GenerateBlock,
+    GenerateRegion,
+    GenvarDeclaration,
+    GreaterThanEqualExpression,
+    GreaterThanExpression,
+    HierarchicalInstance,
+    HierarchyInstantiation,
+    IdentifierName,
+    IdentifierSelectName,
+    IfDefDirective,
+    IfGenerate,
+    IfNDefDirective,
+    IffClause,
+    IffPropertyExpression,
+    ImmediateAssertStatement,
+    ImmediateAssertionMember,
+    ImmediateAssumeStatement,
+    ImmediateCoverStatement,
+    ImplementsClause,
+    ImplicationConstraint,
+    ImplicitAnsiPort,
+    ImplicitEventControl,
+    ImplicitNonAnsiPort,
+    ImplicitType,
+    ImpliesPropertyExpression,
+    IncludeDirective,
+    InequalityExpression,
+    InitialBlock,
+    InsideExpression,
+    IntType,
+    IntegerLiteralExpression,
+    IntegerType,
+    IntegerVectorExpression,
+    InterconnectPortHeader,
+    InterfaceDeclaration,
+    InterfaceHeader,
+    InterfacePortHeader,
+    IntersectSequenceExpression,
+    InvocationExpression,
+    JumpStatement,
+    LessThanEqualExpression,
+    LessThanExpression,
+    LetDeclaration,
+    LineDirective,
+    LocalScope,
+    LogicType,
+    LogicalAndExpression,
+    LogicalEquivalenceExpression,
+    LogicalImplicationExpression,
+    LogicalLeftShiftAssignmentExpression,
+    LogicalOrExpression,
+    LogicalRightShiftAssignmentExpression,
+    LogicalShiftLeftExpression,
+    LogicalShiftRightExpression,
+    LongIntType,
+    LoopConstraint,
+    LoopGenerate,
+    LoopStatement,
+    MacroActualArgument,
+    MacroActualArgumentList,
+    MacroArgumentDefault,
+    MacroFormalArgument,
+    MacroFormalArgumentList,
+    MacroUsage,
+    MatchesClause,
+    MemberAccessExpression,
+    MinTypMaxExpression,
+    ModAssignmentExpression,
+    ModExpression,
+    ModportClockingPort,
+    ModportDeclaration,
+    ModportExplicitPort,
+    ModportItem,
+    ModportNamedPort,
+    ModportSimplePortList,
+    ModportSubroutinePort,
+    ModportSubroutinePortList,
+    ModuleDeclaration,
+    ModuleHeader,
+    MultipleConcatenationExpression,
+    MultiplyAssignmentExpression,
+    MultiplyExpression,
+    NameValuePragmaExpression,
+    NamedArgument,
+    NamedBlockClause,
+    NamedLabel,
+    NamedPortConnection,
+    NamedStructurePatternMember,
+    NamedType,
+    NetDeclaration,
+    NetPortHeader,
+    NetTypeDeclaration,
+    NewArrayExpression,
+    NewClassExpression,
+    NewExpression,
+    NextTimePropertyExpression,
+    NoUnconnectedDriveDirective,
+    NonAnsiPortList,
+    NonOverlappedFollowedByPropertyExpression,
+    NonOverlappedImplicationPropertyExpression,
+    NonblockingAssignmentExpression,
+    NonblockingEventTriggerStatement,
+    NullLiteralExpression,
+    NumberPragmaExpression,
+    OneStepLiteralExpression,
+    OpenRangeExpression,
+    OpenRangeList,
+    OrAssignmentExpression,
+    OrSequenceExpression,
+    OrderedArgument,
+    OrderedPortConnection,
+    OrderedStructurePatternMember,
+    OverlappedFollowedByPropertyExpression,
+    OverlappedImplicationPropertyExpression,
+    PackageDeclaration,
+    PackageHeader,
+    PackageImportDeclaration,
+    PackageImportItem,
+    ParallelBlockStatement,
+    ParameterDeclaration,
+    ParameterDeclarationStatement,
+    ParameterPortList,
+    ParameterValueAssignment,
+    ParenExpressionList,
+    ParenPragmaExpression,
+    ParenthesizedEventExpression,
+    ParenthesizedExpression,
+    PatternCaseItem,
+    PortConcatenation,
+    PortDeclaration,
+    PortReference,
+    PostdecrementExpression,
+    PostincrementExpression,
+    PowerExpression,
+    PragmaDirective,
+    PrimaryBlockEventExpression,
+    ProceduralAssignStatement,
+    ProceduralDeassignStatement,
+    ProceduralForceStatement,
+    ProceduralReleaseStatement,
+    ProgramDeclaration,
+    ProgramHeader,
+    PropertyDeclaration,
+    PropertySpec,
+    PropertyType,
+    QueueDimensionSpecifier,
+    RandCaseItem,
+    RandCaseStatement,
+    RangeCoverageBinInitializer,
+    RangeDimensionSpecifier,
+    RealLiteralExpression,
+    RealTimeType,
+    RealType,
+    RegType,
+    RejectOnPropertyExpression,
+    RepeatedEventControl,
+    ReplicatedAssignmentPattern,
+    ResetAllDirective,
+    RestrictPropertyStatement,
+    ReturnStatement,
+    RootScope,
+    SAlwaysPropertyExpression,
+    SEventuallyPropertyExpression,
+    SNextTimePropertyExpression,
+    SUntilPropertyExpression,
+    SUntilWithPropertyExpression,
+    ScopedName,
+    SequenceDeclaration,
+    SequenceType,
+    SequentialBlockStatement,
+    ShortIntType,
+    ShortRealType,
+    ShortcutCycleDelayRange,
+    SignalEventExpression,
+    SignedCastExpression,
+    SimpleAssignmentPattern,
+    SimplePragmaExpression,
+    SimpleRangeSelect,
+    SolveBeforeConstraint,
+    StandardCaseItem,
+    StreamExpression,
+    StreamExpressionWithRange,
+    StreamingConcatenationExpression,
+    StringLiteralExpression,
+    StringType,
+    StructType,
+    StructUnionMember,
+    StructurePattern,
+    StructuredAssignmentPattern,
+    SubtractAssignmentExpression,
+    SubtractExpression,
+    SuperHandle,
+    SyncAcceptOnPropertyExpression,
+    SyncRejectOnPropertyExpression,
+    SystemName,
+    TaggedPattern,
+    TaggedUnionExpression,
+    TaskDeclaration,
+    ThisHandle,
+    ThroughoutSequenceExpression,
+    TimeLiteralExpression,
+    TimeScaleDirective,
+    TimeType,
+    TimeUnitsDeclaration,
+    TimingControlExpression,
+    TimingControlExpressionConcatenation,
+    TimingControlStatement,
+    TransListCoverageBinInitializer,
+    TransRange,
+    TransRepeatRange,
+    TransSet,
+    TypeAssignment,
+    TypeParameterDeclaration,
+    TypeReference,
+    TypedefDeclaration,
+    UnaryBitwiseAndExpression,
+    UnaryBitwiseNandExpression,
+    UnaryBitwiseNorExpression,
+    UnaryBitwiseNotExpression,
+    UnaryBitwiseOrExpression,
+    UnaryBitwiseXnorExpression,
+    UnaryBitwiseXorExpression,
+    UnaryLogicalNotExpression,
+    UnaryMinusExpression,
+    UnaryNotPropertyExpression,
+    UnaryPlusExpression,
+    UnaryPredecrementExpression,
+    UnaryPreincrementExpression,
+    UnarySequenceDelayExpression,
+    UnarySequenceEventExpression,
+    UnbasedUnsizedLiteralExpression,
+    UnconnectedDriveDirective,
+    UndefDirective,
+    UndefineAllDirective,
+    UnionType,
+    UniquenessConstraint,
+    UnitScope,
+    UntilPropertyExpression,
+    UntilWithPropertyExpression,
+    Untyped,
+    VariableDimension,
+    VariablePattern,
+    VariablePortHeader,
+    VirtualInterfaceType,
+    VoidCastedCallStatement,
+    VoidType,
+    WaitForkStatement,
+    WaitOrderStatement,
+    WaitStatement,
+    WildcardDimensionSpecifier,
+    WildcardEqualityExpression,
+    WildcardInequalityExpression,
+    WildcardLiteralExpression,
+    WildcardPattern,
+    WildcardPortConnection,
+    WildcardPortList,
+    WithClause,
+    WithFunctionClause,
+    WithFunctionSample,
+    WithinSequenceExpression,
+    XorAssignmentExpression,
+};
+
+std::ostream& operator<<(std::ostream& os, SyntaxKind kind);
+string_view toString(SyntaxKind kind);
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./generated/Version.cpp ./generated/Version.cpp
--- ./generated/Version.cpp	1969-12-31 16:00:00.000000000 -0800
+++ ./generated/Version.cpp	2020-04-13 10:23:52.590374210 -0700
@@ -0,0 +1,26 @@
+//------------------------------------------------------------------------------
+// Version.cpp
+// Input file for build-time version source generation
+//
+// File is under the MIT license; see LICENSE for details.
+//------------------------------------------------------------------------------
+#include "slang/util/Version.h"
+
+using std::string_view;
+using namespace std::literals;
+
+namespace slang {
+
+int VersionInfo::getMajor() {
+    return 0;
+}
+
+int VersionInfo::getMinor() {
+    return 4;
+}
+
+string_view VersionInfo::getRevision() {
+    return "f525b308"sv;
+}
+
+}
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./include/slang/text/SourceManager.h ./include/slang/text/SourceManager.h
--- ./include/slang/text/SourceManager.h	2020-04-12 20:09:54.091612606 -0700
+++ ./include/slang/text/SourceManager.h	2020-04-13 11:46:45.445756639 -0700
@@ -13,10 +13,13 @@
 #include <memory>
 #include <mutex>
 #include <set>
 #include <shared_mutex>
 #include <variant>
+#include <unordered_map>
+#include <map>
+#include <vector>
 
 #include "slang/text/SourceLocation.h"
 #include "slang/util/Util.h"
 
 namespace fs = std::filesystem;
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./source/codegen/CodeGenerator.cpp ./source/codegen/CodeGenerator.cpp
--- ./source/codegen/CodeGenerator.cpp	2020-04-12 20:09:54.151611342 -0700
+++ ./source/codegen/CodeGenerator.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,190 +0,0 @@
-//------------------------------------------------------------------------------
-// CodeGenerator.cpp
-// Executable code generation
-// NOTE: Only included if slang is configured to use LLVM
-//
-// File is under the MIT license; see LICENSE for details
-//------------------------------------------------------------------------------
-#include "slang/codegen/CodeGenerator.h"
-
-#include <llvm/IR/BasicBlock.h>
-#include <llvm/IR/IRBuilder.h>
-#include <llvm/IR/LLVMContext.h>
-#include <llvm/IR/Module.h>
-#include <llvm/IR/Verifier.h>
-
-#include "slang/codegen/ExpressionEmitter.h"
-#include "slang/codegen/StatementEmitter.h"
-#include "slang/compilation/Compilation.h"
-#include "slang/symbols/ASTVisitor.h"
-#include "slang/symbols/Symbol.h"
-
-namespace slang {
-
-CodeGenerator::CodeGenerator(Compilation& compilation) : compilation(compilation) {
-    ctx = std::make_unique<llvm::LLVMContext>();
-    module = std::make_unique<llvm::Module>("primary", *ctx);
-
-    // Register built-in types.
-    typeMap.emplace(&compilation.getVoidType(), llvm::Type::getVoidTy(*ctx));
-
-    // Create the main entry point.
-    auto intType = llvm::Type::getInt32Ty(*ctx);
-    auto funcType = llvm::FunctionType::get(intType, /* isVarArg */ false);
-    mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, "main", *module);
-
-    // Create the first basic block that will run at the start of simulation
-    // to initialize all static variables.
-    globalInitBlock = llvm::BasicBlock::Create(*ctx, "", mainFunc);
-}
-
-CodeGenerator::~CodeGenerator() = default;
-
-std::string CodeGenerator::finish() {
-    // Insert all initial blocks into the main function.
-    auto lastBlock = globalInitBlock;
-    for (auto block : initialBlocks) {
-        llvm::IRBuilder<>(lastBlock).CreateBr(block);
-        lastBlock = block;
-    }
-
-    // Finish the main function.
-    auto intType = llvm::Type::getInt32Ty(*ctx);
-    llvm::IRBuilder<>(lastBlock).CreateRet(llvm::ConstantInt::get(intType, 0));
-
-    // Verify all generated code.
-    bool bad = llvm::verifyModule(*module, &llvm::errs());
-    if (bad) {
-        module->dump();
-        return "";
-    }
-
-    // Return the module bitcode.
-    std::string result;
-    llvm::raw_string_ostream os(result);
-    module->print(os, nullptr);
-
-    return os.str();
-}
-
-void CodeGenerator::genInstance(const InstanceSymbol& instance) {
-    instance.visit(makeVisitor([this](const VariableSymbol& symbol) { genGlobal(symbol); },
-                               [this](const ProceduralBlockSymbol& symbol) { genBlock(symbol); }));
-}
-
-void CodeGenerator::genBlock(const ProceduralBlockSymbol& block) {
-    // For now skip everything except initial blocks.
-    if (block.procedureKind != ProceduralBlockKind::Initial)
-        return;
-
-    // Create a block that will contain all of the process's statements.
-    auto bb = llvm::BasicBlock::Create(*ctx, "", mainFunc);
-    genStmt(bb, block.getBody());
-    initialBlocks.push_back(bb);
-}
-
-llvm::Type* CodeGenerator::genType(const Type& type) {
-    // Unwrap aliases.
-    if (type.isAlias())
-        return genType(type.getCanonicalType());
-
-    // Check the cache.
-    if (auto it = typeMap.find(&type); it != typeMap.end())
-        return it->second;
-
-    if (!type.isIntegral())
-        THROW_UNREACHABLE;
-
-    // Underlying representation for integer types:
-    // - Two state types: use the bitwidth as specified
-    // - Four state types: double the specified bitwidth,
-    //                     the upper bits indicate a 1 for unknowns
-    // - If the actual width > configured limit, switch to an array of bytes
-    auto& intType = type.as<IntegralType>();
-    uint32_t bits = intType.bitWidth;
-    if (intType.isFourState)
-        bits *= 2;
-
-    llvm::Type* result;
-    if (bits > options.maxIntBits)
-        result = llvm::ArrayType::get(llvm::Type::getInt64Ty(*ctx), (bits + 63) / 64);
-    else
-        result = llvm::Type::getIntNTy(*ctx, bits);
-
-    typeMap.emplace(&type, result);
-    return result;
-}
-
-llvm::Constant* CodeGenerator::genConstant(const Type& type, const ConstantValue& cv) {
-    // TODO: other value types
-    return genConstant(type, cv.integer());
-}
-
-llvm::Constant* CodeGenerator::genConstant(const Type& type, const SVInt& integer) {
-    auto& intType = type.as<IntegralType>();
-    uint32_t bits = intType.bitWidth;
-    if (intType.isFourState)
-        bits *= 2;
-
-    llvm::ArrayRef<uint64_t> data(integer.getRawPtr(), integer.getNumWords());
-    if (bits <= options.maxIntBits)
-        return llvm::ConstantInt::get(*ctx, llvm::APInt(bits, data));
-    else
-        return llvm::ConstantDataArray::get(*ctx, data);
-}
-
-llvm::Value* CodeGenerator::genExpr(llvm::BasicBlock* bb, const Expression& expr) {
-    ExpressionEmitter emitter(*this, bb);
-    return emitter.emit(expr);
-}
-
-void CodeGenerator::genStmt(llvm::BasicBlock* bb, const Statement& stmt) {
-    StatementEmitter emitter(*this, bb);
-    emitter.emit(stmt);
-}
-
-void CodeGenerator::genGlobal(const VariableSymbol& variable) {
-    ASSERT(variable.lifetime == VariableLifetime::Static);
-
-    auto& type = variable.getType();
-
-    bool needsInitializer = false;
-    llvm::Constant* constVal = nullptr;
-    if (auto init = variable.getInitializer()) {
-        EvalContext evCtx(compilation);
-        ConstantValue val = init->eval(evCtx);
-        if (val)
-            constVal = genConstant(type, val);
-        else
-            needsInitializer = true;
-    }
-
-    // If no initializer provided, use the default for the type.
-    if (!constVal)
-        constVal = genConstant(type, type.getDefaultValue());
-
-    auto global = new llvm::GlobalVariable(*module, genType(type), /* isConstant */ false,
-                                           llvm::GlobalValue::PrivateLinkage, constVal);
-    globalMap.emplace(&variable, global);
-
-    // If we set needsInitializer, the variable has an initializer expression
-    // but it's not constant. Emit it into the basic block that will run at
-    // the start of simulation.
-    if (needsInitializer) {
-        auto expr = genExpr(globalInitBlock, *variable.getInitializer());
-        llvm::IRBuilder<> ir(globalInitBlock);
-        ir.CreateStore(expr, global);
-    }
-}
-
-llvm::Function* CodeGenerator::genSubroutine(const SubroutineSymbol&) {
-    THROW_UNREACHABLE;
-}
-
-llvm::Function* CodeGenerator::genSubroutine(const SystemSubroutine& subroutine) {
-    auto it = sysSubroutineMap.find(&subroutine);
-    ASSERT(it != sysSubroutineMap.end());
-    return it->second;
-}
-
-} // namespace slang
\ No newline at end of file
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./source/codegen/ExpressionEmitter.cpp ./source/codegen/ExpressionEmitter.cpp
--- ./source/codegen/ExpressionEmitter.cpp	2020-04-12 20:09:54.151611342 -0700
+++ ./source/codegen/ExpressionEmitter.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,35 +0,0 @@
-//------------------------------------------------------------------------------
-// ExpressionEmitter.cpp
-// Code emitter for expression trees
-// NOTE: Only included if slang is configured to use LLVM
-//
-// File is under the MIT license; see LICENSE for details
-//------------------------------------------------------------------------------
-#include "slang/codegen/ExpressionEmitter.h"
-
-#include "slang/codegen/CodeGenerator.h"
-#include "slang/symbols/ASTVisitor.h"
-
-namespace slang {
-
-ExpressionEmitter::ExpressionEmitter(CodeGenerator& generator, llvm::BasicBlock* bb) :
-    generator(generator), ir(bb) {
-}
-
-llvm::Value* ExpressionEmitter::emit(const Expression& expr) {
-    return expr.visit(*this);
-}
-
-llvm::Value* ExpressionEmitter::visit(const IntegerLiteral& expr) {
-    return generator.genConstant(*expr.type, expr.getValue());
-}
-
-llvm::Value* ExpressionEmitter::visit(const CallExpression& expr) {
-    return getUndef(*expr.type);
-}
-
-llvm::Value* ExpressionEmitter::getUndef(const Type& type) {
-    return llvm::UndefValue::get(generator.genType(type));
-}
-
-} // namespace slang
\ No newline at end of file
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./source/codegen/StatementEmitter.cpp ./source/codegen/StatementEmitter.cpp
--- ./source/codegen/StatementEmitter.cpp	2020-04-12 20:09:54.151611342 -0700
+++ ./source/codegen/StatementEmitter.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,27 +0,0 @@
-//------------------------------------------------------------------------------
-// StatementEmitter.cpp
-// Code emitter for statements
-// NOTE: Only included if slang is configured to use LLVM
-//
-// File is under the MIT license; see LICENSE for details
-//------------------------------------------------------------------------------
-#include "slang/codegen/StatementEmitter.h"
-
-#include "slang/codegen/CodeGenerator.h"
-#include "slang/symbols/ASTVisitor.h"
-
-namespace slang {
-
-StatementEmitter::StatementEmitter(CodeGenerator& generator, llvm::BasicBlock* bb) :
-    generator(generator), ir(bb) {
-}
-
-void StatementEmitter::emit(const Statement& stmt) {
-    stmt.visit(*this);
-}
-
-void StatementEmitter::visit(const ExpressionStatement& stmt) {
-    generator.genExpr(ir.GetInsertBlock(), stmt.expr);
-}
-
-} // namespace slang
\ No newline at end of file
diff -bBdNrw -U5 '--exclude=*.orig' '--exclude=.git' '--exclude=.svn' '--exclude=esesc.xcode' '--exclude=build' '--exclude=CVS' '--exclude=CVSmain' '--exclude=cscope.files' '--exclude=cscope.out' '--exclude=ChangeLog' '--exclude=CMakeFiles' ./source/codegen/SystemCallEmitter.cpp ./source/codegen/SystemCallEmitter.cpp
--- ./source/codegen/SystemCallEmitter.cpp	2020-04-12 20:09:54.151611342 -0700
+++ ./source/codegen/SystemCallEmitter.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,15 +0,0 @@
-//------------------------------------------------------------------------------
-// SystemCallEmitter.cpp
-// Code emitter for system calls (tasks and functions)
-// NOTE: Only included if slang is configured to use LLVM
-//
-// File is under the MIT license; see LICENSE for details
-//------------------------------------------------------------------------------
-#include "slang/codegen/SystemCallEmitter.h"
-
-#include "slang/binding/SystemSubroutine.h"
-#include "slang/codegen/CodeGenerator.h"
-
-namespace slang {
-
-} // namespace slang
\ No newline at end of file
